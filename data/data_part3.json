[
  {
        "key": "JCR-1040",
        "summary": "JCR2SPI: remove node operation missing in submitted SPI batch",
        "description": "In JCR2SPI, the following sequence of operations seems to lead to an incorrect SPI batch being submitted:\n\n1) remove \"/a\"\n2) add \"/a\"\n3) add \"/a/b\"\n4) session.save()\n\nThis seems to create an SPI batch where the first remove operation is missing.\n\nNote that the problem only seems to occur when step 3 is part of the sequence.\n\nFull Java source for test:\n\n    try {\n      if (session.getRepository().getDescriptor(Repository.LEVEL_2_SUPPORTED).equals(\"true\")) {\n        Node testnode;\n        String name = \"delete-test\";\n          \n        Node root = session.getRootNode();\n        \n        // make sure it's there\n        if (! root.hasNode(name)) {\n          root.addNode(name, \"nt:folder\");\n          session.save();\n        }\n        \n        // now test remove/add in one batch\n        if (root.hasNode(name)) {\n          testnode = root.getNode(name);\n          testnode.remove();\n          // session.save(); // un-commenting this makes the test pass\n        }\n        \n        testnode = root.addNode(name, \"nt:folder\");\n        // add one child\n        testnode.addNode(name, \"nt:folder\"); // commenting this out makes the test pass\n        \n        session.save();\n      }\n    } finally {\n      session.logout();\n    }\n    \n    ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-501",
        "summary": "TCK: SetPropertyValueTest#testCompactValueArrayWithNulls does not respect nodename1 and nodetype configuration properties",
        "description": "Test doesn't respect value of nodename1 and nodetype configuration properties.\n\nProposal: create property under testnode instead of testrootnode.\n\n--- SetPropertyValueTest.java   (revision 422074)\n+++ SetPropertyValueTest.java   (working copy)\n@@ -374,11 +374,11 @@\n      * the value array by removing all null values\n      */\n     public void testCompactValueArrayWithNulls() throws Exception {\n-        testRootNode.setProperty(propertyName2, vArrayWithNulls);\n+        testNode.setProperty(propertyName2, vArrayWithNulls);\n         superuser.save();\n         assertEquals(\"Node.setProperty(String, valueArrayWithNulls[]) did not compact the value array by removing the null values\",\n                 2,\n-                testRootNode.getProperty(propertyName2).getValues().length);\n+                testNode.getProperty(propertyName2).getValues().length);\n     }\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2026",
        "summary": "DbDataStore: garbage collection deadlock",
        "description": "Sometimes, the unit tests hangs with the following threads blocked. It looks like a database level deadlock caused by the DbDataStore implementation. The database used is Apache Derby.\n\norg.apache.jackrabbit.core.data.db.DbDataStore.addRecord line=298\norg.apache.jackrabbit.core.value.BLOBInDataStore.getInstance line=120\norg.apache.jackrabbit.core.value.InternalValue.getBLOBFileValue line=644\norg.apache.jackrabbit.core.value.InternalValue.create line=123\norg.apache.jackrabbit.core.PropertyImpl.setValue line=609\norg.apache.jackrabbit.core.PropertyImpl.setValue line=525\norg.apache.jackrabbit.core.NodeImpl.setProperty line=2312\norg.apache.jackrabbit.core.data.CopyValueTest.doTestCopy line=64\norg.apache.jackrabbit.core.data.CopyValueTest.testCopyStream line=45\n\norg.apache.jackrabbit.core.data.db.DbDataStore.updateLastModifiedDate line=641\norg.apache.jackrabbit.core.data.db.DbDataStore.touch line=631\norg.apache.jackrabbit.core.data.db.DbDataStore.getRecord line=484\norg.apache.jackrabbit.core.value.BLOBInDataStore.getDataRecord line=136\norg.apache.jackrabbit.core.value.BLOBInDataStore.getLength line=92\norg.apache.jackrabbit.core.data.GarbageCollector.scanPersistenceManagers\norg.apache.jackrabbit.core.data.GarbageCollector.scan line=161\norg.apache.jackrabbit.core.data.GCThread.run line=52",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-459",
        "summary": "Add JMX support to register a JCR RMI Server into Jboss",
        "description": " I added two classes and one descriptor file to the jcr-rmi project. These files provide support to make the generated jar deployable into a Jboss server. \n\n The deployment descriptor contains two parameters, the address of the local repository instance, and the target address where the rmi server should be registered. \n\ne.g.\n\n<server>\n <mbean code=\"org.apache.jackrabbit.rmi.server.jmx.JCRServer\"\n     name=\"Jackrabbit.services:RMIServer = JCR RMI Server\">\n    <attribute name=\"Local\">java:jcr/local</attribute>\n    <attribute name=\"Target\">jnp://localhost:1099/jcrServer</attribute>\t\n<depends>jboss.jca:service=ManagedConnectionFactory,name=jcr/local</depends>\t\t\t\t\t\n  </mbean>\n</server>\t\n\nthis configuration registers an RMI server at /jcrServer that wraps the local repository at java:jcr/local.\n\nbr,\nEdgar",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2236",
        "summary": "Malformed excerpt if content contains markup and no highlights found",
        "description": "Any markup in content that is used in an excerpt is encoded with corresponding entity references. However, this process is broken when there are no highlights in the excerpt. In this case, the content is provided as is in the excerpt, which may lead to malformed HTML/XML.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3026",
        "summary": "davex remoting has  a performance bottleneck due limit of 2 http connections",
        "description": "The spi2dav service implementation use of HttpClient did not support configuration of the maximum amount of http connections to the server.  The default value, in the HttpClient code, is two. This was a performance bottleneck.  This work makes the number of connections configurable via a parameter to the map passed to the repository factory.  \n\nIt also fixes a concurrency issue which was exposed by the increased concurrency effected by this work.  This fix is a replacement of a HashMap cache of client connections with a ConcurrentHashMap, thanks to the java 1.5 available in Jackrabbit 2.x\n\nUSAGE: \nSet the number of connections (Spi2davRepositoryServiceFactory.PARAM_MAX_HTTP_CONNECTIONS) when creating a factory via the dav or davex rep factories.  Default is 20.\n\nNOTE: \nSee also the server side fixes: JCR-3027  The patch on that ticket allows configuration of the concurrency level on the server, which should be tuned in conjunction with the client side connection levels.  \n ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2025",
        "summary": "Optimize concurrent queries",
        "description": "There are a number of bottlenecks that prevent scalability of concurrent queries:\n\n- Fake norms are created repeatedly because a new SearchIndex$CombinedIndexReader is created for each query. This prevents caching of fake norms on the level of the CombinedIndexReader. Creating fake norms for index readers that span multiple sub reader is inefficient and should be avoided. Like with other Jackrabbit specific queries, there should be one for TermQuery, which is aware of sub readers. Its weight should then create one scorer for each sub reader. This effectively reuses the fake norms on the sub reader.\n\n- There should be a  UUID cache that maps document number to UUID. This is basically the inverse of the existing DocNumberCache. UUID lookup is regularly a bottleneck in the SegmentReader where the method document() is synchronized and does I/O.\n\n- Queries often contain constraints that limit the result to nodes with a certain flag set to a literal. These constraints should be cached in the query handler.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2631",
        "summary": "Move backwards compatibility tests to trunk",
        "description": "As discussed on dev@, I'd like to move the backwards compatibility tests from the Jackrabbit sandbox to trunk.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2523",
        "summary": "StaleItemStateException during distributed transaction",
        "description": "We use the Jackrabbit JCA Component within a Weblogic 10.3 Application Server with distributed transactions between an Oracle Database an the Jackrabbit JCA.\n\nUpdating a node property multiple times in a transaction results in a XAException. Root cause seems to be a StaleItemStateException (see Stack-Trace).\nGoogling revealed, that a similar bug was fixed for Jackrabbit 1.5.3. Looking through the code showed, that the proposed fix in JCR-1554 seems not to be applied on Jackrabbit 2.0 (tag and trunk).\n\nI tried to apply the proposed fix on the trunk code base, but this seemed not to help.\n\nStack-Trace:\njavax.ejb.TransactionRolledbackLocalException: Error committing transaction:; nested exception is: javax.transaction.xa.XAException                                                                                             \n        at weblogic.ejb.container.internal.EJBRuntimeUtils.throwTransactionRolledbackLocal(EJBRuntimeUtils.java:238)                                                                                                            \n        at weblogic.ejb.container.internal.EJBRuntimeUtils.throwEJBException(EJBRuntimeUtils.java:133)                                                                                                                          \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvoke1(BaseLocalObject.java:623)                                                                                                                                \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvokeTxRetry(BaseLocalObject.java:424)                                                                                                                          \n        at ch.ejpd.sireneit.facade.ejb.ablage.DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.updateStructuredDokument(DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.java:340)                                                      \n        at ch.ejpd.sireneit.access.rest.ablage.DokumentResource.update(DokumentResource.java:453)                                                                                                                               \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                                                                                                                                          \n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)                                                                                                                                        \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)                                                                                                                                \n        at java.lang.reflect.Method.invoke(Method.java:597)                                                                                                                                                                     \n        at com.sun.jersey.server.impl.model.method.dispatch.AbstractResourceMethodDispatchProvider$ResponseOutInvoker._dispatch(AbstractResourceMethodDispatchProvider.java:175)                                                \n        at com.sun.jersey.server.impl.model.method.dispatch.ResourceJavaMethodDispatcher.dispatch(ResourceJavaMethodDispatcher.java:67)                                                                                         \n        at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:208)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:75)                                                                                                                             \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:67)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:724)                                                                                                                \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:689)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:680)                                                                                                                 \n        at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:324)                                                                                                                                     \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:425)                                                                                                                             \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:604)                                                                                                                             \n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)                                                                                                                                                         \n        at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:227)                                                                                                                   \n        at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:125)                                                                                                                              \n        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:292)                                                                                                                                          \n        at weblogic.servlet.internal.TailFilter.doFilter(TailFilter.java:26)                                                                                                                                                    \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at ch.ejpd.lib.webclient.jfa.JfaTokenServletFilter.doFilter(JfaTokenServletFilter.java:108)                                                                                                                             \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3496)                                                                                                           \n        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)                                                                                                                              \n        at weblogic.security.service.SecurityManager.runAs(Unknown Source)                                                                                                                                                      \n        at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2180)                                                                                                                        \n        at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2086)                                                                                                                               \n        at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1406)                                                                                                                                       \n        at weblogic.work.ExecuteThread.execute(ExecuteThread.java:201)                                                                                                                                                          \n        at weblogic.work.ExecuteThread.run(ExecuteThread.java:173)                                                                                                                                                              \njavax.transaction.xa.XAException                                                                                                                                                                                                \n        at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:171)                                                                                                                                   \n        at org.apache.jackrabbit.core.XASessionImpl.commit(XASessionImpl.java:346)                                                                                                                                              \n        at org.apache.jackrabbit.jca.TransactionBoundXAResource.commit(TransactionBoundXAResource.java:39)                                                                                                                      \n        at weblogic.connector.security.layer.AdapterLayer.commit(AdapterLayer.java:252)                                                                                                                                         \n        at weblogic.connector.transaction.outbound.XAWrapper.commit(XAWrapper.java:113)                                                                                                                                         \n        at weblogic.transaction.internal.XAServerResourceInfo.commit(XAServerResourceInfo.java:1334)                                                                                                                            \n        at weblogic.transaction.internal.XAServerResourceInfo.commit(XAServerResourceInfo.java:578)                                                                                                                             \n        at weblogic.transaction.internal.ServerSCInfo.startCommit(ServerSCInfo.java:547)                                                                                                                                        \n        at weblogic.transaction.internal.ServerTransactionImpl.localCommit(ServerTransactionImpl.java:2006)                                                                                                                     \n        at weblogic.transaction.internal.ServerTransactionImpl.globalRetryCommit(ServerTransactionImpl.java:2723)                                                                                                               \n        at weblogic.transaction.internal.ServerTransactionImpl.globalCommit(ServerTransactionImpl.java:2645)                                                                                                                    \n        at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:282)                                                                                                                   \n        at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:230)                                                                                                                           \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvoke1(BaseLocalObject.java:591)                                                                                                                                \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvokeTxRetry(BaseLocalObject.java:424)                                                                                                                          \n        at ch.ejpd.sireneit.facade.ejb.ablage.DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.updateStructuredDokument(DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.java:340)                                                      \n        at ch.ejpd.sireneit.access.rest.ablage.DokumentResource.update(DokumentResource.java:453)                                                                                                                               \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                                                                                                                                          \n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)                                                                                                                                        \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)                                                                                                                                \n        at java.lang.reflect.Method.invoke(Method.java:597)                                                                                                                                                                     \n        at com.sun.jersey.server.impl.model.method.dispatch.AbstractResourceMethodDispatchProvider$ResponseOutInvoker._dispatch(AbstractResourceMethodDispatchProvider.java:175)                                                \n        at com.sun.jersey.server.impl.model.method.dispatch.ResourceJavaMethodDispatcher.dispatch(ResourceJavaMethodDispatcher.java:67)                                                                                         \n        at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:208)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:75)                                                                                                                             \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:67)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:724)                                                                                                                \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:689)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:680)                                                                                                                 \n        at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:324)                                                                                                                                     \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:425)                                                                                                                             \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:604)                                                                                                                             \n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)                                                                                                                                                         \n        at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:227)                                                                                                                   \n        at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:125)                                                                                                                              \n        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:292)                                                                                                                                          \n        at weblogic.servlet.internal.TailFilter.doFilter(TailFilter.java:26)                                                                                                                                                    \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at ch.ejpd.lib.webclient.jfa.JfaTokenServletFilter.doFilter(JfaTokenServletFilter.java:108)                                                                                                                             \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3496)                                                                                                           \n        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)                                                                                                                              \n        at weblogic.security.service.SecurityManager.runAs(Unknown Source)                                                                                                                                                      \n        at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2180)                                                                                                                        \n        at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2086)                                                                                                                               \n        at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1406)                                                                                                                                       \n        at weblogic.work.ExecuteThread.execute(ExecuteThread.java:201)                                                                                                                                                          \n        at weblogic.work.ExecuteThread.run(ExecuteThread.java:173)                                                                                                                                                              \norg.apache.jackrabbit.core.TransactionException: Unable to prepare transaction.                                                                                                                                                 \n        at org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:169)                                                                                                                             \n        at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:154)                                                                                                                                   \n        at org.apache.jackrabbit.core.XASessionImpl.commit(XASessionImpl.java:346)                                                                                                                                              \n        at org.apache.jackrabbit.jca.TransactionBoundXAResource.commit(TransactionBoundXAResource.java:39)                                                                                                                      \n        at weblogic.connector.security.layer.AdapterLayer.commit(AdapterLayer.java:252)                                                                                                                                         \n        at weblogic.connector.transaction.outbound.XAWrapper.commit(XAWrapper.java:113)                                                                                                                                         \n        at weblogic.transaction.internal.XAServerResourceInfo.commit(XAServerResourceInfo.java:1334)                                                                                                                            \n        at weblogic.transaction.internal.XAServerResourceInfo.commit(XAServerResourceInfo.java:578)                                                                                                                             \n        at weblogic.transaction.internal.ServerSCInfo.startCommit(ServerSCInfo.java:547)                                                                                                                                        \n        at weblogic.transaction.internal.ServerTransactionImpl.localCommit(ServerTransactionImpl.java:2006)                                                                                                                     \n        at weblogic.transaction.internal.ServerTransactionImpl.globalRetryCommit(ServerTransactionImpl.java:2723)                                                                                                               \n        at weblogic.transaction.internal.ServerTransactionImpl.globalCommit(ServerTransactionImpl.java:2645)                                                                                                                    \n        at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:282)                                                                                                                   \n        at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:230)                                                                                                                           \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvoke1(BaseLocalObject.java:591)                                                                                                                                \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvokeTxRetry(BaseLocalObject.java:424)                                                                                                                          \n        at ch.ejpd.sireneit.facade.ejb.ablage.DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.updateStructuredDokument(DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.java:340)                                                      \n        at ch.ejpd.sireneit.access.rest.ablage.DokumentResource.update(DokumentResource.java:453)                                                                                                                               \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                                                                                                                                          \n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)                                                                                                                                        \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)                                                                                                                                \n        at java.lang.reflect.Method.invoke(Method.java:597)                                                                                                                                                                     \n        at com.sun.jersey.server.impl.model.method.dispatch.AbstractResourceMethodDispatchProvider$ResponseOutInvoker._dispatch(AbstractResourceMethodDispatchProvider.java:175)                                                \n        at com.sun.jersey.server.impl.model.method.dispatch.ResourceJavaMethodDispatcher.dispatch(ResourceJavaMethodDispatcher.java:67)                                                                                         \n        at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:208)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:75)                                                                                                                             \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:67)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:724)                                                                                                                \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:689)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:680)                                                                                                                 \n        at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:324)                                                                                                                                     \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:425)                                                                                                                             \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:604)                                                                                                                             \n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)                                                                                                                                                         \n        at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:227)                                                                                                                   \n        at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:125)                                                                                                                              \n        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:292)                                                                                                                                          \n        at weblogic.servlet.internal.TailFilter.doFilter(TailFilter.java:26)                                                                                                                                                    \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at ch.ejpd.lib.webclient.jfa.JfaTokenServletFilter.doFilter(JfaTokenServletFilter.java:108)                                                                                                                             \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3496)                                                                                                           \n        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)                                                                                                                              \n        at weblogic.security.service.SecurityManager.runAs(Unknown Source)                                                                                                                                                      \n        at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2180)                                                                                                                        \n        at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2086)                                                                                                                               \n        at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1406)                                                                                                                                       \n        at weblogic.work.ExecuteThread.execute(ExecuteThread.java:201)                                                                                                                                                          \n        at weblogic.work.ExecuteThread.run(ExecuteThread.java:173)                                                                                                                                                              \norg.apache.jackrabbit.core.state.StaleItemStateException: e1863ec3-4eb7-483b-b1db-7586c089bc64/{}To has been modified externally                                                                                                \n        at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:653)                                                                                                                \n        at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:1110)                                                                                                                \n        at org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:163)                                                                                                                             \n        at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:154)                                                                                                                                   \n        at org.apache.jackrabbit.core.XASessionImpl.commit(XASessionImpl.java:346)                                                                                                                                              \n        at org.apache.jackrabbit.jca.TransactionBoundXAResource.commit(TransactionBoundXAResource.java:39)                                                                                                                      \n        at weblogic.connector.security.layer.AdapterLayer.commit(AdapterLayer.java:252)                                                                                                                                         \n        at weblogic.connector.transaction.outbound.XAWrapper.commit(XAWrapper.java:113)                                                                                                                                         \n        at weblogic.transaction.internal.XAServerResourceInfo.commit(XAServerResourceInfo.java:1334)                                                                                                                            \n        at weblogic.transaction.internal.XAServerResourceInfo.commit(XAServerResourceInfo.java:578)                                                                                                                             \n        at weblogic.transaction.internal.ServerSCInfo.startCommit(ServerSCInfo.java:547)                                                                                                                                        \n        at weblogic.transaction.internal.ServerTransactionImpl.localCommit(ServerTransactionImpl.java:2006)                                                                                                                     \n        at weblogic.transaction.internal.ServerTransactionImpl.globalRetryCommit(ServerTransactionImpl.java:2723)                                                                                                               \n        at weblogic.transaction.internal.ServerTransactionImpl.globalCommit(ServerTransactionImpl.java:2645)                                                                                                                    \n        at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:282)                                                                                                                   \n        at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:230)                                                                                                                           \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvoke1(BaseLocalObject.java:591)                                                                                                                                \n        at weblogic.ejb.container.internal.BaseLocalObject.postInvokeTxRetry(BaseLocalObject.java:424)                                                                                                                          \n        at ch.ejpd.sireneit.facade.ejb.ablage.DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.updateStructuredDokument(DokumentFacadeBean_7xdnsq_DokumentFacadeImpl.java:340)                                                      \n        at ch.ejpd.sireneit.access.rest.ablage.DokumentResource.update(DokumentResource.java:453)                                                                                                                               \n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                                                                                                                                          \n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)                                                                                                                                        \n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)                                                                                                                                \n        at java.lang.reflect.Method.invoke(Method.java:597)                                                                                                                                                                     \n        at com.sun.jersey.server.impl.model.method.dispatch.AbstractResourceMethodDispatchProvider$ResponseOutInvoker._dispatch(AbstractResourceMethodDispatchProvider.java:175)                                                \n        at com.sun.jersey.server.impl.model.method.dispatch.ResourceJavaMethodDispatcher.dispatch(ResourceJavaMethodDispatcher.java:67)                                                                                         \n        at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:208)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:109)                                                                                                                                  \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:75)                                                                                                                             \n        at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:115)                                                                                                                            \n        at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:67)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:724)                                                                                                                \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:689)                                                                                                                 \n        at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:680)                                                                                                                 \n        at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:324)                                                                                                                                     \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:425)                                                                                                                             \n        at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:604)                                                                                                                             \n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)                                                                                                                                                         \n        at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:227)                                                                                                                   \n        at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:125)                                                                                                                              \n        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:292)                                                                                                                                          \n        at weblogic.servlet.internal.TailFilter.doFilter(TailFilter.java:26)                                                                                                                                                    \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at ch.ejpd.lib.webclient.jfa.JfaTokenServletFilter.doFilter(JfaTokenServletFilter.java:108)                                                                                                                             \n        at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:42)                                                                                                                                          \n        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3496)                                                                                                           \n        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)                                                                                                                              \n        at weblogic.security.service.SecurityManager.runAs(Unknown Source)                                                                                                                                                      \n        at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2180)                                                                                                                        \n        at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2086)                                                                                                                               \n        at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1406)                                                                                                                                       \n        at weblogic.work.ExecuteThread.execute(ExecuteThread.java:201)                                                                                                                                                          \n        at weblogic.work.ExecuteThread.run(ExecuteThread.java:173)                                                                                                                                                              \n>                                                                                                                                                                                                                               ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1691",
        "summary": "Includes new (old) mimetypes that OpenOfficeTextExtractor can handle",
        "description": "The following patch adds the old openoffice (1.0 version) mimetypes to have their contents extracted. \nI've tested with simple files and it worked here. \n\n\n$ cat OpenOfficeTextExtractor-mimetype.patch\n--- jackrabbit-1.4/jackrabbit-text-extractors/src/main/java/org/apache/jackrabbit/extractor/OpenOfficeTextExtractor.java    2007-12-19 12:57:58.000000000 -0200\n+++ jackrabbit-1.4-modified/jackrabbit-text-extractors/src/main/java/org/apache/jackrabbit/extractor/OpenOfficeTextExtractor.java  2008-07-24 15:01:08.000000000 -0300\n@@ -54,7 +54,11 @@\n                            \"application/vnd.oasis.opendocument.graphics\",\n                            \"application/vnd.oasis.opendocument.presentation\",\n                            \"application/vnd.oasis.opendocument.spreadsheet\",\n-                           \"application/vnd.oasis.opendocument.text\"});\n+                           \"application/vnd.oasis.opendocument.text\",\n+                           \"application/vnd.sun.xml.calc\",\n+                           \"application/vnd.sun.xml.draw\",\n+                           \"application/vnd.sun.xml.impress\",\n+                           \"application/vnd.sun.xml.writer\"});\n     }\n\n     //-------------------------------------------------------< TextExtractor >\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2517",
        "summary": "UserImporter should use User.changePassword",
        "description": "the UserImporter lists a limitation that the password value is expected to be hashed already as it writes the\nvalue as it was retrieved from the xml-import.\n\nInstead it could make use of User#changePassword that (in the implementation present with JR) creates a \npw-hash if the password is found to be plain text.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-424",
        "summary": "PropertyState binary type desirialsation only returns half of content",
        "description": "Create a PropertyState for a binary Property (e.g jcr:data) set a value larger than the BLOBFileValues#MAX_BUFFER_SIZE  (e.g. 300Kbyte) serialse it.\nOn deserialisation the resulting PropertyState's InternalValue's size is only half as the origianl (e.g. 150Kbyte)\n\nMost probably this is due to the States InputStream implementation marking bytes twice to be read.\nFollowing fix solves the issue for call to #read(byte[], in, int),\nbut other Stream methods may fail as well.\n\nIndex: jackrabbit/java/org/apache/jackrabbit/core/state/PropertyState.java\n===================================================================\n--- jackrabbit/java/org/apache/jackrabbit/core/state/PropertyState.java (revision 399293)\n+++ jackrabbit/java/org/apache/jackrabbit/core/state/PropertyState.java (working  copy)\n@@ -305,7 +305,6 @@\n                                 len = (int) (length - consumed);\n                             }\n                             int read = super.read(b, off, len);\n-                            consumed += read;\n                             return read;\n                         }\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2552",
        "summary": "Creating a node of type nt:hierarchyNode (or derived) on a JCR 1.0 compliant repository fails",
        "description": "When creating a node of type nt:hierarchyNode (or derived) on a JCR 1.0 compliant repository, the auto-created property named jcr:created does not get a default value and an exception:\n\njavax.jcr.RepositoryException: createFromDefinition not implemented for: {http://www.jcp.org/jcr/1.0}created\n\nThe code in SessionItemStateManager#computeSystemGeneratedPropertyValues handles jcr:created only when found in node type mix:created. In JCR 1.0, however, this property was declared in nt:hierarchyNode. Adding this extra case would allow interoperation with such a repository.\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2887",
        "summary": "Split PrivilegeRegistry in a per-session manager instance and a repository level registry",
        "description": "in order to resolve the privilegeregistry related TODOs within jackrabbit-core, i would like to split off those \nmethods from PrivilegeRegistry  that are used on a per-session level (including jcr-names) and add them\nto a manager class that was present with each session context. consequently the responsibility of the\nregistry was then limited to read/build the privilege definitions and would be present on the repositorycontext\ndeprecating those methods that would be covered by the manager).\nin addition the naming was then consistent with what we use to have for nodetypes and namespaces.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-544",
        "summary": "JCR-Server: Workspace.restore not mapped correctly",
        "description": "(issue reported by David Kennedy)\n\nWorkspace.restore(Version[], boolean) won't work, since versions are not retrieved correctly. The version history that can be access from the request  resource, cannot be used to retrieve the versions needed for a workspace.restore call.\n\npossible short term fix:\nFrom the version-hrefs present in the request body of the UPDATE request, version resources must be built and\nthe corresponding version item retrieved.\n\nalternative:\nfind a proper mapping for Workspace.restore(Version[], boolean). having UPDATE on a resource representing a javax.jcr.Node being mapped to a workspace.restore is odd.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-250",
        "summary": "Access to VirtualNodeTypeStateManager.virtualProvider should be guarded",
        "description": "The virtualProvider field of the VirtualNodeTypeStateManager class is dynamically created by the getter method. Two methods of the class access that field directly though risking NullPointerException.\n\nAccess should be guarded against the field being not assigned yet.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-672",
        "summary": "Deadlock on concurrent save/checkin operations possible",
        "description": "Save and checkin operations are trying to acquire 2 locks in different order, what leads to deadlock.\n\n->save\n1.SharedItemStateManager.acquireWriteLock\n2.AbstractVersionManager.acquireWriteLock\t->\tlocked\n\n->checkin\n1.AbstractVersionManager.acquireWriteLock\n2.SharedItemStateManager.acquireReadLock\t->\tlocked\n\n\"Thread-4\" prio=6 tid=0x0312d840 nid=0x824 in Object.wait() [0x03cef000..0x03cefa68]\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x23210968> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)\n\tat java.lang.Object.wait(Unknown Source)\n\tat EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source)\n\t- locked <0x23210968> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)\n\tat org.apache.jackrabbit.core.version.AbstractVersionManager.acquireWriteLock(AbstractVersionManager.java:124)\n\tat org.apache.jackrabbit.core.version.VersionManagerImpl.setNodeReferences(VersionManagerImpl.java:413)\n\tat org.apache.jackrabbit.core.version.VersionItemStateProvider.setNodeReferences(VersionItemStateProvider.java:125)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:699)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:810)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:326)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:313)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:302)\n\tat org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:295)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1204)\n\t- locked <0x2332eaa0> (a org.apache.jackrabbit.core.XASessionImpl)\n\tat JrTestDeadlock.run(JrTestDeadlock.java:87)\n\n\"Thread-3\" prio=6 tid=0x0312db18 nid=0xa04 in Object.wait() [0x03caf000..0x03cafae8]\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x232d1360> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)\n\tat java.lang.Object.wait(Unknown Source)\n\tat EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock.acquire(Unknown Source)\n\t- locked <0x232d1360> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.acquireReadLock(SharedItemStateManager.java:1361)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.hasItemState(SharedItemStateManager.java:270)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.hasItemState(LocalItemStateManager.java:180)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.hasItemState(XAItemStateManager.java:252)\n\tat org.apache.jackrabbit.core.state.SessionItemStateManager.hasItemState(SessionItemStateManager.java:188)\n\tat org.apache.jackrabbit.core.ItemManager.itemExists(ItemManager.java:256)\n\tat org.apache.jackrabbit.core.NodeImpl.hasProperty(NodeImpl.java:1509)\n\tat org.apache.jackrabbit.core.version.InternalFrozenNodeImpl.checkin(InternalFrozenNodeImpl.java:276)\n\tat org.apache.jackrabbit.core.version.InternalFrozenNodeImpl.checkin(InternalFrozenNodeImpl.java:248)\n\tat org.apache.jackrabbit.core.version.InternalVersionHistoryImpl.checkin(InternalVersionHistoryImpl.java:440)\n\tat org.apache.jackrabbit.core.version.AbstractVersionManager.checkin(AbstractVersionManager.java:397)\n\tat org.apache.jackrabbit.core.version.VersionManagerImpl$2.run(VersionManagerImpl.java:289)\n\tat org.apache.jackrabbit.core.version.VersionManagerImpl$DynamicESCFactory.doSourced(VersionManagerImpl.java:611)\n\t- locked <0x2320c5d8> (a org.apache.jackrabbit.core.version.VersionManagerImpl$DynamicESCFactory)\n\tat org.apache.jackrabbit.core.version.VersionManagerImpl.checkin(VersionManagerImpl.java:285)\n\tat org.apache.jackrabbit.core.version.XAVersionManager.checkin(XAVersionManager.java:161)\n\tat org.apache.jackrabbit.core.NodeImpl.checkin(NodeImpl.java:2944)\n\tat JrTestDeadlock.run(JrTestDeadlock.java:103)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2976",
        "summary": "Allow parent path to be set explicitly in NodeInfoBuilder",
        "description": "Currently there is no way to explicitly set the parent of an NodeInfo build by NodeInfoBuilder. I suggest to add a setParentPath() method to NodeInfoBuilder to fix this.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3141",
        "summary": "Upgrade to Tika 1.0",
        "description": "Tika 1.0 was released today and has many improvements over the earlier 0.10 release. We should upgrade.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-967",
        "summary": "Only search the index for the \"jcr:system\" tree if needed",
        "description": "Right now every time a query is executed the index of the current workspace as well as the index of the \"jcr:system\" tree is searched. A lot of queries are not searching in the \"jcr:system\" tree at all therefore it should be checked if the query contains paths that include \"jcr:system\". There are two relevant nodes in the query tree to find that out:\n\n- what's the first location step and does it include the jcr:system tree? I think that's an easy one.\n- does the query contain a jcr:deref node? If there is an intermediate result of a query may dereference into the jcr:system tree. \n\nThis should notably speed up query execution if you are working extensively with versioning.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2521",
        "summary": "WorkspaceImporter throws exception",
        "description": "sessio.getWorkspace().getImportContentHandler() throws \njava.lang.UnsupportedOperationException: Workspace-Import of protected nodes: Not yet implement.\n\nsuggest to issue warning instead of throwing.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-192",
        "summary": "Update monitor is not released",
        "description": "When the timer thread in MultiIndex commits the volatile index after some idle time it does not release / reset the updateInProgress flag. This results in queries that hang until another thread writes to the workspace.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1798",
        "summary": "JCR2SPI: Avoid individual Item reloading upon Session/Item.refresh(true)",
        "description": "with CacheBehaviour.INVALIDATE Item.refresh(true) and Session.refresh(true) results in individual reloading of the existing entries in the hierarchy circumventing all batch read optimization.\n\nApart from general optimization of the refresh itself, refresh(true) should rather mark existing items and force a reload upon next access (similar to the behaviour implemented with refresh(false)).\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1418",
        "summary": "Redesign NodeInfo.getReferences()",
        "description": "The method returns an array of PropertyIds. When there are lots of references this may become an problem. As with any other return value that potentially is large we should return an iterator.\n\nI suggest to redesign the handling of references in line with recent discussions how child infos are handled.\n\n- A NodeInfo implementation must either return the complete list of PropertyIds or null if it does not want to return the PropertyIds at that time.\n- Introduce a new method: Iterator<PropertyId> RepositoryService.getReferences(SessionInfo, NodeId)\n\nThis has the following advantages:\n\n- loading of references can be delayed until it is really needed\n- large collections of references can be streamed through the SPI",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2085",
        "summary": "test case (TCK) maintenance for JCR 2.0",
        "description": "Umbrella issue for changes/additions to JUnit test cases, setup and config.",
        "label": "NUG",
        "classified": "TEST",
        "type": ""
    },
    {
        "key": "JCR-2707",
        "summary": "improve performance when saving a node with a large number of child nodes (e.g. > 10k child node entries)",
        "description": "JCR-307 brought a significant improvement WRT saving nodes with a large number of child nodes\n\nunfortunately JCR-2579 broke part of the optimization (see NodeState.setChildNodeEntries(List)).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1609",
        "summary": "JSR 283: new Property Types",
        "description": "the new property types are\n\n- WEAKREFERENCE\n- URI\n- DECIMAL",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1323",
        "summary": "When using QueryImpl.setLimit() and QueryImpl.setOffset(), then NodeIterator.getSize() reports wrong size",
        "description": "When using QueryImpl.setLimit() and QueryImpl.setOffset(), then NodeIterator.getSize() reports wrong size. Returned size seems to be allways the same as the limit.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1378",
        "summary": "Remove SessionImpl dependency from QueryObjectModelFactoryImpl",
        "description": "The QueryObjectModelFactoryImpl should be independent of the jackrabbit-core.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-351",
        "summary": "Default to anonymous access when no Credentials are given",
        "description": "Even though JCR-348 made easier to start a Jackrabbit repository with default configuration, the user still needs to take care of the JAAS configuration. It would be more user-friendly to log a warning and default to superuser access rather than throwing a LoginException when JAAS has not been configured. This behaviour should be limited to only default credential logins (Session.login() with null Credentials) and it should be possible to disable it with a configuration option. We could even have this behaviour disabled by default, but enabled in the configuration file used with the JCR-348 automatic configuration.\n\nThis is a case against the \"secure by default\" design principle, but I think that in this case the benefits in easier setup outweight the security drawbacks, especially if coupled with the above restrictions and a clear documentation note about the insecure default.\n\n[Update: As mentioned by Stefan, this is  not a JAAS configuration issue but a problem in handling null Credentials. A more proper alternative for superuser access would be to default to anonymous access when credentials are not given.]",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-603",
        "summary": "OracleFileSystem can't handle empty files",
        "description": "the following exception is thrown when trying to access a 0-length file\nin an OracleFileSystem:\njava.sql.SQLException: ORA-22275: invalid LOB locator specified\n\nissue reported on the users list, \nsee http://www.nabble.com/problems-with-Oracle-tf2483987.html#a6926522\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-973",
        "summary": "XML import using MacOS X WebDAV client does not work",
        "description": "when trying to import a xml file via a webdav mount this does not work.\n\nthis is mainly because the client first tries to create a 0-sized file, which fails with the xml importer. after the file is created, it will lock it and put the xml body. a second problem might be the \"dot-underscore\" files mac tries to create. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2250",
        "summary": "Base64 bug - last buffer not flushed",
        "description": "I found an issue when using the org.apache.jackrabbit.util.Base64.encode(InputStream in, OutputStream out) method. It appears that the issue is that the last buffer is not flushed on the Writer that it creates before returning from the method. I was able to work around this issue by creating a Writer my own program, and call another encode method, and then call the flush() method before using the data. The source in trunk appears the same.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1085",
        "summary": "Remove unused LuceneQueryBuilder.createQuery() method",
        "description": "The following method is not used anymore in Jackrabbit and can be removed:\n\n    public static Query createQuery(QueryRootNode root,\n                                    SessionImpl session,\n                                    ItemStateManager sharedItemMgr,\n                                    NamespaceMappings nsMappings,\n                                    Analyzer analyzer,\n                                    PropertyTypeRegistry propReg)\n            throws RepositoryException;",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-442",
        "summary": "Implement a backup tool",
        "description": "Issue for tracking the progress of the Google Summer of Code project assigned to Nicolas Toper.  The original project requirements are:\n\n\"Implement a tool for backing up and restoring content in an Apache Jackrabbit content repository. In addition to the basic content hierarchies, the tool should be able to efficiently manage binary content, node version histories, custom node types, and namespace mappings. Incremental or selective backups would be a nice addition, but not strictly necessary.\"",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1474",
        "summary": "consistency check fails with derbypm if bundle size exceeds 32k",
        "description": "due to a 'problem' in derby DERBY-1486 interleaved reads on a bundle that is larger than about 32k results in an error:\n  ERROR XJ073: The data in this BLOB or CLOB is no longer available.  \n               The BLOB or CLOBs transaction may be committed, or its \n               connection is closed.\n\nthis issue was already addressed in JCR-1039 but not fixed for the consistency check.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2283",
        "summary": "Incorrect CND for mix:etag",
        "description": "Jackrabbit currently defined mix:etag as follows:\n\n[mix:etag]\n  mixin\n  // currently has a default value because auto-creation not handled see JCR-2116\n  - jcr:etag (STRING) = '' protected autocreated\n\nI think this violates the spec, which says:\n\n[mix:etag] mixin\n  - jcr:etag (STRING) protected autocreated\n\nThis also affects the predefined node type test in jackrabbit-jcr-tests where mix-etag.txt is:\n\nNodeTypeName\n  mix:etag\nSupertypes\n  []\nIsMixin\n  true\nHasOrderableChildNodes\n  false\nPrimaryItemName\n  null\nPropertyDefinition\n  Name jcr:etag\n  RequiredType STRING\n  DefaultValues []\n  AutoCreated true\n  Mandatory false\n  OnParentVersion COPY\n  Protected true\n  Multiple false\n\nbut should rather be:\n\nNodeTypeName\n  mix:etag\nSupertypes\n  []\nIsMixin\n  true\nHasOrderableChildNodes\n  false\nPrimaryItemName\n  null\nPropertyDefinition\n  Name jcr:etag\n  RequiredType STRING\n  DefaultValues null               <===\n  AutoCreated true\n  Mandatory false\n  OnParentVersion COPY\n  Protected true\n  Multiple false\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1264",
        "summary": "IfHeader: Incorrect test for parsing keyword \"not\" in parseIfList",
        "description": "The test for the \"not\" keyword tests the last character as\n\n     (not !='t' || not != 'T')\n\nwhich always yields true (not cannot be t and T at the same time). The correct test would be\n\n     (not !='t' && not != 'T')",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1669",
        "summary": "Text.isDescendant returns false if parent is '/'",
        "description": "the method isDescendant(String, String) of the Text utility class returns false if the \npassed potential parent-path represents the root node (\"/\").\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2005",
        "summary": "JCR2SPI: Remove validation check for same-named Node and Property",
        "description": "JSR 170 disallowed a parent node to have a property and a child node with the same name.\n\nThis limitation has been removed with JSR 283 and the RI (jackrabbit-core) already removed the check.\nI would suggest to change Jcr2Spi accordingly and leave this validation to the underlying SPI impl.\n\nIf I'm not mistaken this JSR 170 requirement is asserted in a single place (ItemStateValidator).",
        "label": "NUG",
        "classified": "SPEC",
        "type": ""
    },
    {
        "key": "JCR-3007",
        "summary": "setProperty access control evaluation does not properly cope with XA transactions",
        "description": "This is another instance of the problems with ACL evaluation within transactions described in https://issues.apache.org/jira/browse/JCR-2999.\nIn this case PropertyImpl#getParent() called from PropertyImpl#checkSetValue() is trying to check read permissions of the yet uncommited parent and thus fails with an ItemNotFound exception.\n\nThe problem is reproducible with the following test:\n\npublic void testTransaction() throws Exception {\n\n        // make sure testUser has all privileges\n        Privilege[] privileges = privilegesFromName(Privilege.JCR_ALL);\n        givePrivileges(path, privileges, getRestrictions(superuser, path));\n\n        // create new node and lock it\n        Session s = getTestSession();\n        UserTransaction utx = new UserTransactionImpl(s);\n        utx.begin();\n\n        // add node and save it\n        Node n = s.getNode(childNPath);\n        if (n.hasNode(nodeName1)) {\n            Node c = n.getNode(nodeName1);\n            c.remove();\n            s.save();\n        }\n\n        // create node and save\n        Node n2 = n.addNode(nodeName1);\n        s.save(); // -> node is NEW -> no failure\n\n        // set a property on a child node of an uncommited parent\n        n2.setProperty(propertyName1, \"testSetProperty\");\n        s.save();  // -> fail because PropertyImpl#getParent called from PropertyImpl#checkSetValue\n                       //    was checking read permission on the not yet commited parent\n\n        // commit\n        utx.commit();\n    }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-160",
        "summary": "Query index not in sync with workspace",
        "description": "After some time the search index is not in sync anymore with the data in the workspace and returns uuids which have no corresponding Node in the workspace. This results in a NodeIterator which throws an ItemNotFoundException on nextNode().\n\nInstructions how to reproduce this error are not yet available.\n\nPossible areas for further investigation are:\n- NodeType registry which maps the node types into the workspace with the use of virtual item states\n- versioning?\n- atomicity of indexing?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1023",
        "summary": "Only load item definition when required",
        "description": "Some item definitions are loaded when an item state is constructed. Whenever possible this should be delayed to a time when the definition is actually used.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-548",
        "summary": "Node type documentation tool (NTDoc)",
        "description": "This is the first time I post a contrib here on Jira. Hope I do this the right way :-) \n\nSome weeks ago I postet a message on the forum about a node type documentation tool I had made. Now, finally I have cleaned up the code and fixed some bugs. It is now useful for the majority out there. I do not guarantee it to be bug-free, but will do my best to fix any bugs that is reported. \n\nA readme file is included in the distribution. Must build using maven 2. Have not done it maven 1 compliant.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-665",
        "summary": "RMI: Property.getValue() fails with EOFException after many reads",
        "description": "When reading binary properties via RMI it can happen that it fails throwing an EOFException. This is caused by a server sided \"Too many open files\" bacause BinaryValue.writeObject() does not close the underlying value InputStream.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3083",
        "summary": "Degrade gracefully when reading invalid date values",
        "description": "As noted in JCR-1996, it is possible for an old version of Jackrabbit to store date invalid date values in the repository. Currently such values cause exceptions when the repository attempts to read them. A better approach would be to automatically detect such dates and map them instead to string values to avoid losing any information. A client could then access the information as a string through the normal JCR API, and would only get a ValueFormatException when trying to read the value as a date, i.e. using the getDate() method.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2371",
        "summary": "Core: WEAKREFERENCE properties object have type REFERENCE when being read from the persistent layer",
        "description": "it seems to me that WEAKREFERENCE properties are properly created and stored as such but are read as REFERENCE \nproperties when built again from the persistent layer.\n\nhow to reproduce:\n\n- create a new WEAKREFERENCE property and save the changes\n- force reading from the persistent layer  (in my case I used Day's CRX and restartet the server)\n- the former WEAKREFERENCE will now be displayed as REFERENCE.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1089",
        "summary": "Xpath query parser accepts \"/a | /b\" and treats it as \"/a/b\"",
        "description": "The XPath query parser accepts the query\n\n  /a | /b\n\nand parses it into a query tree corresponging the Xpath query\n\n  /a/b\n\nIt should be rejected instead.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-586",
        "summary": "Removing a mixin that adds a same-name-sibling child node throws an ItemNotFoundException",
        "description": "Apologies in advance if this has previously been noted in JIRA or on the lists but I couldn't find anything. When removing a mixin that defines a same-name-sibling child an ItemNotFoundException is thrown due to child node indicies not being maintained. A similar method of NodeImpl (onRemove) recongnized this and amended to remove from the tail but the removeMixin also has this issue.\n\nSimple test reproduction:\n\nTypes:\n\n[mix:foo] mixin\n\t+ bar (nt:bar) multiple\n\t\n[nt:bar] > nt:unstructured, mix:referenceable\n\nCode:\n\npublic class RemoveMixinTest extends AbstractServerTest {\n    private static final String MIXIN = \"mix:foo\";\n    private static final String CHILD = \"bar\";\n    private static final String PTYPE = \"nt:bar\";\n    \n    public void testRemoveMixin() throws RepositoryException {\n        Session session = getSession();\n        Node root = session.getRootNode().addNode(\"root\");\n        root.addMixin(MIXIN);\n        \n        root.addNode(CHILD, PTYPE);\n        root.addNode(CHILD, PTYPE);\n        root.addNode(CHILD, PTYPE);\n        \n        session.save();\n        \n        for (NodeIterator it = root.getNodes(); it.hasNext(); ) {\n            Node node = it.nextNode();\n            System.out.println(node.getPath() + \" : \" + node.getUUID());\n        }\n        \n        try {\n            root.removeMixin(MIXIN);\n            root.save();\n        } catch (RepositoryException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n\nOutput:\n\n/root/bar : 0b09e0b4-0727-4194-978a-4eadfbf93fa8\n/root/bar[2] : 84d5e556-6f12-43fb-98e3-614bcf1f7bb7\n/root/bar[3] : 8db95029-df3b-4e26-affb-438de0206cf5\n\njavax.jcr.ItemNotFoundException: 8db95029-df3b-4e26-affb-438de0206cf5\nat org.apache.jackrabbit.core.ItemManager.createItemInstance(ItemManager.java:463)\n\tat org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:319)\n\tat org.apache.jackrabbit.core.NodeImpl.removeMixin(NodeImpl.java:1212)\n\tat org.apache.jackrabbit.core.NodeImpl.removeMixin(NodeImpl.java:2624)\n\tat com.ms.appmw.rcf.server.RemoveMixinTest.testRemoveMixin(RemoveMixinTest.java:48)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat msjava.base.testutils.junit3.MSTestCase.runTest(MSTestCase.java:203)\n\tat msjava.base.testutils.junit3.TestCaseTearDownEvenIfSetUpFails.runBare(TestCaseTearDownEvenIfSetUpFails.java:92)\n\tat msjava.base.testutils.junit3.MSTestCase.runBare(MSTestCase.java:170)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\nThe missing UUID for the last node is the one not found because upon removal of the second the index [2] is still valid. Thanks!",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-627",
        "summary": "Deprecated Serializer does not properly delegate method calls.",
        "description": "The deprecated org.apache.jackrabbit.core.state.util.Serializer class does not actually forward method calls to its replacement. Instead it calls itself repeatedly, leading to infinite recursion. The attached test demonstrates this and yields the following trace:\n\n<<\njava.lang.StackOverflowError\n\tat org.apache.jackrabbit.core.state.util.Serializer.serialize(Serializer.java:39)\n>>",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-19",
        "summary": "package org.apache.xml.utils does not exist (JDK 1.5.0)",
        "description": "Executing \"maven jar\" on a freshly checked out source tree fails with the following error messages when using JDK 1.5.0:\n\n/home/jukkaz/src/jackrabbit/src/java/org/apache/jackrabbit/core/xml/DocViewSAXEventGenerator.java:24: package org.apache.xml.utils does not exist\nimport org.apache.xml.utils.XMLChar;\n                            ^\n/home/jukkaz/src/jackrabbit/src/java/org/apache/jackrabbit/core/xml/DocViewSAXEventGenerator.java:142: cannot find symbol\nsymbol  : variable XMLChar\nlocation: class org.apache.jackrabbit.core.xml.DocViewSAXEventGenerator\n            if (!XMLChar.isValidName(elemName)) {\n                 ^\n/home/jukkaz/src/jackrabbit/src/java/org/apache/jackrabbit/core/xml/DocViewSAXEventGenerator.java:162: cannot find symbol\nsymbol  : variable XMLChar\nlocation: class org.apache.jackrabbit.core.xml.DocViewSAXEventGenerator\n                if (!XMLChar.isValidName(attrName)) {\n\nThe same build succeeds without problems on JDK 1.4.2_06.\n\nI found some reports about similar problems after upgrading from JDK 1.4 to 1.5. It seems that the org.apache.xml.utils.XMLChar was a part (undocumented?) of the standard JDK classpath, but that it has been dropped from JDK 1.5.\n\nA similar (the same?) XMLChar utility class can be found in the org.apache.xerces.utils package, which is automatically included by the Xerces dependency. The following change fixes the problem on JDK 1.5.0 and seems to work fine also on JDK 1.4.2_06.\n\nIndex: src/java/org/apache/jackrabbit/core/xml/DocViewSAXEventGenerator.java\n===================================================================\n--- src/java/org/apache/jackrabbit/core/xml/DocViewSAXEventGenerator.java      (revision 57540)\n+++ src/java/org/apache/jackrabbit/core/xml/DocViewSAXEventGenerator.java      (working copy)\n@@ -21,7 +21,7 @@\n import org.apache.jackrabbit.core.state.PropertyState;\n import org.apache.jackrabbit.core.util.Base64;\n import org.apache.log4j.Logger;\n-import org.apache.xml.utils.XMLChar;\n+import org.apache.xerces.util.XMLChar;\n import org.xml.sax.ContentHandler;\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.AttributesImpl;\n\n",
        "label": "NUG",
        "classified": "OTHER",
        "type": "BUG"
    },
    {
        "key": "JCR-1741",
        "summary": "Flush volatile index when size limit is reached",
        "description": "Currently the volatile index is committed when minMergeDocs is reached. This is inconvenient because it does not take the size of nodes into account account. When lots of small nodes are added the volatile index should be committed less frequently. Similarly when nodes with lots of properties are indexed the volatile index should be committed more frequently.\n\nInstead the size of the volatile index in bytes should trigger a disk write.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1931",
        "summary": "SharedFieldCache$StringIndex memory leak causing OOM's ",
        "description": "SharedFieldCache$StringIndex is not working properly. It is meant to cache the docnumbers in lucene along with the term to sort on. The issue is twofold. I have a solution for the second one, the first one is not really solvable from jr pov, because lucene index readers are already heavily caching Terms. \n\nExplanation of the problem:\n\nFor *each* unique property where is sorted on, a new lucene ScoreDocComparator is created (see SharedFieldComparator newComparator). This new comparator creates *per* lucene indexreader  SharedFieldCache.StringIndex which is stored in a WeakHashMap with as key, the indexreader . As this indexreader  almost *never* can be garbage collected (only if it is merged and thus unused after), the SharedFieldCache.StringIndex are there to be the rest of the jvm life (which is sometime short, as can be seen from the simple unittest attached).  Obviously, this results pretty fast in OOM.\n\n1) issue one:  The cached terms[] in SharedFieldCache.StringIndex can become huge when you sort on a common property (date) which is present in a lot of nodes. It you sort on large properties, like 'title' this SharedFieldCache.StringIndex  will quickly use hundreds of Mb for a couple of hundred of thousand of nodes with a title. This issue is already a lucene issue, as lucene already caches the terms. OTOH, I really doubt whether we should index long string values as UNTOKENIZED in lucene at all. A half working solution might be a two-step solution, where the first sort is on the first 10 chars, and only if the comparator returns 0, take the entire string to sort on\n\n2) issue two:  The cached terms[] in SharedFieldCache.StringIndex is frequently sparse, consuming an incredible amount of memory for string arrays containing mainly null values. For example (see attached unit test):\n\n- add 1.000.000 nodes\n- do a query and sort on a non existing property\n- you'll loose 1.000.000 * 4 bytes ~ 4 Mb of memory\n- sort on another non existing prop : another 4 Mb is lost\n- do it 100 times --> 400 Mb is lost, and can't be reclaimed\n\nI'll attach a solution which works really fine for me, still having the almost unavoidable memory absorption, but makes it much smaller. The solution is, that if < 10% of the String array is filled, i consider the array already sparse, and move to a HashMap solution. Performance does not decrease much (and in case of large sparsity increases because less memory consumption --> less gc, etc). \n\nPerhaps it does not seem to be a common issue (certainly the unit test) but our production environments memory snapshots indicate most memory being held by the SharedFieldCache$StringIndex (and the lucene Terms, which is harder to avoid)\n\nI'd like to see this in the 1.5.1 if others are ok with it\n\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1268",
        "summary": "Move JCRWebdavServerServlet to jcr-server and make it abstract",
        "description": "In line with isse JCR-417, I suggest to partially move the JCRWebdavServerServlet from the jcr-webapp project to the jcr-server project. By partially I mean, that the new (moved) servlet will be abstract and the getRepository() method will be abstract. The jcr-webapp project will still contain a JCRWebdavServerServlet (for backwards compatibility maintaing the same name) which just extends the new servlet and implements the getRepository() method using the RepositoryAccess servlet.\n\nThis allows for the reuse of the jcr-server project including the abstract JCRWebdavServerServlet in other environments.\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-132",
        "summary": "BindableRepositoryFactory requires exact resource type",
        "description": "The org.apache.jackrabbit.jndi.BindableRepositoryFactory class requires the exact class name org.apache.jackrabbit.jndi.BindableRepository to be specified for the JNDI resource that the factory is responsible for. However the current deployment model 2 howto document suggest that the more generic interface name javax.jcr.Repository be used instead. Currently this suggested configuration results in a null JNDI resource .\n\nThis issue should be fixed by either fixing the documentation (I can do this) or by relaxing the code in BindableRepositoryFactory. I'll attach a patch that does the latter, please comment on what you think is the best solution.\n\nThis issue was detected during the mailing list thread\nhttp://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/2303",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2318",
        "summary": "Keep WebDAV exception causes",
        "description": "The DavMethodBase and ExceptionConverter classes in jackrabbit-webdav and jackrabbit-spi2dav don't include the cause when throwing an exception based on some caught cause. This makes it harder to identify what is causing a  particular problem. The attached patch fixes that.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2582",
        "summary": "spi2dav: temp files are not clean up after batch submit",
        "description": "when a batch includes larger binary properties, their backing temp files are not clean up after submit.\nsuggest to dispose those in any case.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-3067",
        "summary": "Remove timeout handling from TransactionContext",
        "description": "As discussed in JCR-2861, the transaction timeout handling in the TransactionContext class should not be needed since that's the task of the transaction manager, not the context. We should simply remove the timeout handling.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-105",
        "summary": "QueryHandler.init() should take a context argument",
        "description": "Currently the QueryHandler.init() method takes a bunch of arguments which are needed by the single jackrabbit implementation for the query handler. To make further extensions easier the arguments should be packaged into a context class which can be extended without effect on the QueryHandler interface.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2105",
        "summary": "JSR 283 NodeType Management",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2441",
        "summary": "Jcr2spiRepositoryFactory: make class loading more robust",
        "description": "Currently Jcr2spiRepositoryFactory loads a RepositoryServiceFactory from the context class loader. In an OSGi environment this fails with a ClassNotFoundException. I suggest to fall back to the class loader of a the class (Jcr2spiRepositoryFactory) in this case. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2327",
        "summary": "java.util.UUID.fromString() too slow",
        "description": "Benchmarking shows that the java.util.UUID.fromString() method is 10 times slower than the previous version we used from jackrabbit-jcr-commons. This method is quite heavily used in the query section or more generally whenever a NodeId is created from a String.\n\nI'd like to introduce the custom String UUID parsing code again that we had in the jackrabbit-jcr-commons UUID class and use it in the NodeId(String) constructor.\n\nWDYT?",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2186",
        "summary": "Unnecessary hasItemState() call in SessionItemStateManager",
        "description": "At the end of  SessionItemStateManager.getItemState(ItemId) the underlying item state manager is first asked whether it contains the item and then it is retrieved. In case the item state manager does not know the item a NoSuchItemStateException is thrown.\n\nThe initial check is unnecessary because getItemState() on the underlying manager will also throw the exception if the item does not exist.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1855",
        "summary": "Update to Lucene 2.4.1",
        "description": "Lucene 2.4 contains a couple of performance improvements.\n\nSee: http://lucene.apache.org/java/2_4_0/changes/Changes.html",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1284",
        "summary": "Use bundle persistence in default configuration",
        "description": "The default repository configuration files in jackrabbit-core and -webapp still use the old simple database persistence. They should be updated to use bundle persistence in the 1.4 release.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1251",
        "summary": "DescendantSelfAxisQuery creates too many object instances",
        "description": "In DescendantSelfAxisQuery.DescendantSelfAxisScorer.isValid() there is an ArrayList and an Integer instance created on every call. Since this method gets called really often during queries the object creation/gc affects performance.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-613",
        "summary": "Implementation of a memory file system",
        "description": "I needed a memory file system for my test cases. A patch for a simple implementation the works well in my environment is attached",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1121",
        "summary": "full text search tests use incorrect character for escaping phrases",
        "description": "The query test cases use single quotes to escape phrases. The grammar in 6.6.5.2 however requires double quotes.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-447",
        "summary": "deadlock on concurrent commit/locking",
        "description": "there can happen an iterlock between the dispatching part of the shared item state manager and the lockmanager.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2459",
        "summary": "Improved error reporting from JcrUtils.getRepository",
        "description": "The service provider mechanism and the null return value used by the RepositoryFactory API makes it a bit difficult to troubleshoot cases where a repository can not be accessed. It would be helpful if the JcrUtils.getRepository methods reported as accurate failure information as possible in case the requested repository is not found.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2266",
        "summary": "Skip deployment of jackrabbit-standalone",
        "description": "The jackrabbit-standalone jar currently can't be deployed to the repository.apache.org server probably because of its size. I'm not sure if there are any good use cases where you'd want to use the standalone jar as a Maven dependency, so having it on Maven central doesn't seem that important. I'd like to make this explicit by configuring the deploy plugin to skip deploying the standalone jar.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-201",
        "summary": "[contrib-bdb] initialization fails if directory doesn't exist",
        "description": "BerkeleyDBPersistenceManager initialization fails if the directory configured doesn't exist (this doesn't happen with other PMs).\nThis can easily be fixed in the persistence manager, by making it create all the directories in the path (actually it only creates the last -db- directory).\n\nThe trivial patch is to replace envDir.mkdir() to envDir.mkdirs() (note the final \"s\") at BerkeleyDBPersistenceManager  line 73:\n        if (!envDir.exists())\n            envDir.mkdir();\nshould be:\n        if (!envDir.exists())\n            envDir.mkdirs();\n\n(I am not submitting any svn diff since the manual fix sounds so trivial, it's easier to change it manually)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-626",
        "summary": "Move document type definition out of repository.xml",
        "description": "Hello!\n\nHere at Cognifide, Przemo and I we got a bit confused while trying to solve JCR-202. There was a need to modify repository.xml configuration file and it's DTD, and we have found that there are different repository.xml files within trunk that differs this definition. I think that it is a good idea to extract this definition to a one separate file (and maybe .xsd instead of .dtd) and then link it in other files. It would be also nice to put this file somewhere on the Web and reference it via URL.\n\nI am waiting for your comments.\n\nRegards, Jan",
        "label": "NUG",
        "classified": "OTHER",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-792",
        "summary": "after enabling access manager, I can't createNode and setProperty without a node.save in the middle",
        "description": "I added my own access manager. after that I can't get the following code working \n\nNode n = createNewNode(parentNode);\nn.setProperty();\nparentNode.save();\n\nIt seems that setProperty will invoke access control check, but since the new node is not in the repository yet, my access manager implementation won't be able to grant permission. I also tried to use hierachyManager to get the path of the new node, it also returned null. \n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2139",
        "summary": "Registering NodeType with defaultvalues fails with IndexOutOfBounds",
        "description": "When trying to register more than one nodetpye with default values I get the following exception:\n\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 4\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl.toNodeTypeDef(NodeTypeManagerImpl.java:790)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl.registerNodeTypes(NodeTypeManagerImpl.java:560)\n\nI assume there is an index missmatch in the implementation\n\n                Value[] values = pdefs[i].getDefaultValues();\n                if (values != null) {\n                    InternalValue[] qvalues = new InternalValue[values.length];\n                    for (int j = 0; j < values.length; j++) {\n                        try {\n-->                            qvalues[j] = InternalValue.create(values[i], session);\n                        } catch (ValueFormatException e) {\n                            throw new InvalidNodeTypeDefinitionException(\n                                    \"Invalid default value format\", e);\n                        }\n                    }\n                    qpdef.setDefaultValues(qvalues);\n                }\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-770",
        "summary": "Path should implement Serializable",
        "description": "QName already implements Serializable, for ease of use Path should also support Serializable.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1440",
        "summary": "NPE Thrown when two Cluster Nodes are hitting the same underlying database.",
        "description": "I've created a test that creates two repositories with clustering enabled that are backed by the same database.  Using the following workflow causes a NullPointerException to be thrown.\n\nThe workflow I'm using is:\nThe root node is versioned.\nClusterNode1 creates a versioned child node named \"foo\".\nThe test waits to make sure the syncDelay has passed so ClusterNode2 will notice the newly created node.\nClusterNode2 retrieves the \"foo\" child node and removes it.\nThe test waits for the change ClusterNode1 to sync with that change.\nClusterNode1 tries to create another new node however a NullPointerException is thrown when the it tries to checkout the rootNode.\n\njava.lang.NullPointerException: null values not allowed\n\tat org.apache.commons.collections.map.AbstractReferenceMap.put(AbstractReferenceMap.java:251)\n\tat org.apache.jackrabbit.core.version.VersionManagerImpl.getItem(VersionManagerImpl.java:280)\n\tat org.apache.jackrabbit.core.version.XAVersionManager.getItem(XAVersionManager.java:334)\n\tat org.apache.jackrabbit.core.version.AbstractVersionManager.getVersion(AbstractVersionManager.java:87)\n\tat org.apache.jackrabbit.core.NodeImpl.getBaseVersion(NodeImpl.java:3198)\n\tat org.apache.jackrabbit.core.NodeImpl.checkout(NodeImpl.java:2991)\n\tat com.cerner.system.configuration.repository.jcr.SimpleJackrabbitConflictTest.testNullPointerExceptionThrown(SimpleJackrabbitConflictTest.java:96)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-648",
        "summary": "NullpointerException in SessionItemStateManager",
        "description": "I got the following exception which is not reproducible and occured during a large batch of write operations. Unfortunately I got no idea how this happened. May be someone has an idea?\n\n[2006-11-27 21:43:53,065, WARN ] {} support.RemoteInvocationTraceInterceptor:80: Processing of RmiServiceExporter remote call resulted in fatal exception: com.subshell.sophora.content.server.IContentManager.importDocument\norg.springframework.transaction.TransactionSystemException: Could not commit JCR transaction; nested exception is java.lang.NullPointerException Caused by: \njava.lang.NullPointerException\n        at org.apache.jackrabbit.core.state.SessionItemStateManager.nodeModified(SessionItemStateManager.java:878)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyNodeModified(StateChangeDispatcher.java:143)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.stateModified(LocalItemStateManager.java:426)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyStateModified(StateChangeDispatcher.java:85)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.stateModified(SharedItemStateManager.java:388)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyStateModified(StateChangeDispatcher.java:85)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.stateModified(SharedItemStateManager.java:388)\n        at org.apache.jackrabbit.core.state.ItemState.notifyStateUpdated(ItemState.java:241)\n        at org.apache.jackrabbit.core.state.ChangeLog.persisted(ChangeLog.java:271)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:691)\n        at org.apache.jackrabbit.core.state.XAItemStateManager.commit(XAItemStateManager.java:169)\n        at org.apache.jackrabbit.core.version.XAVersionManager.commit(XAVersionManager.java:478)\n        at org.apache.jackrabbit.core.TransactionContext.commit(TransactionContext.java:172)\n        at org.apache.jackrabbit.core.XASessionImpl.commit(XASessionImpl.java:315)\n        at org.springmodules.jcr.jackrabbit.support.JackRabbitUserTransaction.commit(JackRabbitUserTransaction.java:104)\n        at org.springmodules.jcr.jackrabbit.LocalTransactionManager.doCommit(LocalTransactionManager.java:192)\n        at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:540)\n        at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:510)\n        at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:310)\n        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:117)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185)\n        at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185)\n        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:209)\n        at $Proxy14.importDocument(Unknown Source)\n        at sun.reflect.GeneratedMethodAccessor18.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:585)\n        at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:318)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:203)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:162)\n        at org.springframework.remoting.support.RemoteInvocationTraceInterceptor.invoke(RemoteInvocationTraceInterceptor.java:70)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185)\n        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:209)\n        at $Proxy15.importDocument(Unknown Source)\n        at sun.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:585)\n        at org.springframework.remoting.support.RemoteInvocation.invoke(RemoteInvocation.java:181)\n        at org.springframework.remoting.support.DefaultRemoteInvocationExecutor.invoke(DefaultRemoteInvocationExecutor.java:38)\n        at org.springframework.remoting.support.RemoteInvocationBasedExporter.invoke(RemoteInvocationBasedExporter.java:76)\n        at org.springframework.remoting.rmi.RmiBasedExporter.invoke(RmiBasedExporter.java:72)\n        at org.springframework.remoting.rmi.RmiInvocationWrapper.invoke(RmiInvocationWrapper.java:62)\n        at sun.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:585)\n        at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:294)\n        at sun.rmi.transport.Transport$1.run(Transport.java:153)\n        at java.security.AccessController.doPrivileged(Native Method)\n        at sun.rmi.transport.Transport.serviceCall(Transport.java:149)\n        at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:460)\n        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:701)\n        at java.lang.Thread.run(Thread.java:595)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1483",
        "summary": "Move common node type functionality to jackrabbit-spi-commons",
        "description": "now, that jackrabbit-core has a dependency to jackrabbit-spi-commons it would be possible to have the common functionality shared by core and jcr2spi in the spi-commons project.\n\nthe node type package offers quite some potential for that.\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1226",
        "summary": "ServerQuery does not use RemoteAdapterFactory for creating ServerQueryResult",
        "description": "The ServerQuery sould use the Factory for creating ServerQueryResult.\n\nSiehe the method ServerQuery.execute():\n\n{code}\npublic RemoteQueryResult execute() throws RepositoryException, RemoteException {\n        return new ServerQueryResult(query.execute(), getFactory());\n    }\n{code}\n\nit should be:\n{code}\n    public RemoteQueryResult execute() throws RepositoryException, RemoteException {\n        return getFactory().getRemoteQueryResult(this.query.execute());\n    }\n{code}",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-554",
        "summary": "Index creates many folders when re-indexing",
        "description": "When the repository is re-indexed the search index creates a lot of directories, which are finally cleaned up. If the repository contains a lot of content the number of directories that are created can be quite high (thousands of directories).\n\nThe re-indexing process should clean up unused index folders right away and not wait until the changes are committed.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1681",
        "summary": "DbDataStore: improve error message when init fails",
        "description": "When initialization of the database data store fails, the error message does not\ncontain enough data to analyze the problem:\n\nDriver: Oracle JDBC driver / 10.2.0.1.0\ncould not execute statement, reason: ORA-00902: invalid datatype, state/code: 42000/902\nCan not init data store, driver=oracle.jdbc.OracleDriver url=jdbc:oracle:thin:@localhost:1521:orcl user=JACKRABBIT\n\nAdditionally the create table statement should be logged, and the table name.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1629",
        "summary": "SPI: Testsuite for the SPI Interfaces",
        "description": "now that people start writing SPI implementations we should provide a test-suite that runs on the SPI directly in order to provide the developers a way to assert basic compliance of their implementation without having the JCR api in between.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "RFE"
    },
    {
        "key": "JCR-1849",
        "summary": "JSR 283: EventJournal",
        "description": "Implement the event journal as specified in JSR 283.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2019",
        "summary": "spi2davex: some value factory tests from the SPI test suite are failing",
        "description": "",
        "label": "NUG",
        "classified": "UNKNOWN",
        "type": "BUG"
    },
    {
        "key": "JCR-39",
        "summary": "document view: importXML() fails on protected property jcr:primaryType",
        "description": "when trying to import an xml document where elements contain the attribute jcr:primaryType the import fails with:\n\njavax.jcr.nodetype.ConstraintViolationException: cannot set the value of a protected property /testroot/docviewimport/doc/jcr:primaryType\n\tat org.apache.jackrabbit.core.PropertyImpl.setValue(PropertyImpl.java:907)\n\tat org.apache.jackrabbit.core.NodeImpl.setProperty(NodeImpl.java:1044)\n\tat org.apache.jackrabbit.core.xml.DocViewImportHandler.startElement(DocViewImportHandler.java:124)\n\tat org.apache.jackrabbit.core.xml.ImportHandler.startElement(ImportHandler.java:164)\n\tat org.apache.xerces.parsers.AbstractSAXParser.startElement(Unknown Source)\n\tat org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown Source)\n\tat org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher.scanRootElementHook(Unknown Source)\n\tat org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)\n\tat org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)\n\tat org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\tat org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\tat org.apache.xerces.parsers.XMLParser.parse(Unknown Source)\n\tat org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)\n\tat org.apache.jackrabbit.core.SessionImpl.importXML(SessionImpl.java:836)\n\tat org.apache.jackrabbit.test.api.DocViewImportTest.setUp(DocViewImportTest.java:92)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:31)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:78)\n\nif i understand the spec correctly, the import process should take care of this attribute and determine the node type of the new nodes based on it.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2313",
        "summary": "Improvements to user management (2)",
        "description": "follow up issue as JCR-2199 is already closed.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-521",
        "summary": "Add a method public boolean hasNodeType(String name) in NodeTypeManagerImpl",
        "description": "As seen in the ML, we plan to add this method and update this class and the interface JackrabbitNodeTypeManager",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2554",
        "summary": "Deadlock inside XASession on Weblogic",
        "description": "In one of our client deployments on WebLogic 9.2 we observed JackRabbit sessions going stale in a load test. This was observed against release 1.6.1 (to which we migrated due to concurrency related issues JCR-2081 and JCR-2237). Same effect with 2.0.0.\n \nI could finally reproduce this issue locally. And it seems to boil down to WLS invoking the sequence of <prepare> ... <release> ... <commit> on one XA session from multiple threads, as it seems breaking assumptions of the thread-bound java.util.concurrent-RWLock based DefaultISMLocking class.\nEffectively the setActiveXid(..) method on DefaultISMLocking$RWLock fails as the old active XID was not yet cleared. With the result of more and more sessions deadlocking in below's invocation stack.\n\n{code}\n\"[ACTIVE] ExecuteThread: '27' for queue: 'weblogic.kernel.Default (self-tuning)'\" daemon prio=1 tid=0x33fc3ec0 nid=0x2324 in Object.wait() [0x2156a000..0x2156beb0] at java.lang.Object.wait(Native Method) - waiting on <0x68a54698> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock) at java.lang.Object.wait(Object.java:474) at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source) - locked <0x68a54698> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock) at org.apache.jackrabbit.core.state.DefaultISMLocking$1.<init>(DefaultISMLocking.java:64) at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireWriteLock(DefaultISMLocking.java:61) at org.apache.jackrabbit.core.version.AbstractVersionManager.acquireWriteLock(AbstractVersionManager.java:146) at org.apache.jackrabbit.core.version.XAVersionManager$1.prepare(XAVersionManager.java:562) at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:154) - locked <0x6dc2ad88> (a org.apache.jackrabbit.core.TransactionContext) at org.apache.jackrabbit.core.XASessionImpl.prepare(XASessionImpl.java:331) at org.apache.jackrabbit.jca.TransactionBoundXAResource.prepare(TransactionBoundXAResource.java:68) at weblogic.connector.security.layer.AdapterLayer.prepare(AdapterLayer.java:397) at weblogic.connector.transaction.outbound.XAWrapper.prepare(XAWrapper.java:297) at weblogic.transaction.internal.XAServerResourceInfo.prepare(XAServerResourceInfo.java:1276) at weblogic.transaction.internal.XAServerResourceInfo.prepare(XAServerResourceInfo.java:499) at weblogic.transaction.internal.ServerSCInfo$1.execute(ServerSCInfo.java:335) at weblogic.kernel.Kernel.executeIfIdle(Kernel.java:243) at weblogic.transaction.internal.ServerSCInfo.startPrepare(ServerSCInfo.java:326) at weblogic.transaction.internal.ServerTransactionImpl.localPrepare(ServerTransactionImpl.java:2516) at weblogic.transaction.internal.ServerTransactionImpl.globalPrepare(ServerTransactionImpl.java:2211) at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:266) at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:227) at weblogic.transaction.internal.TransactionManagerImpl.commit(TransactionManagerImpl.java:283) at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1028) at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:709) at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:678)\n{code}",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-816",
        "summary": "MSSql and MySQL bunlde PM schemas missing definition for name index",
        "description": "the mssql and mysql ddl files of the respective bundle persistence managers are missing the definitions for the name index.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2556",
        "summary": "Data store garbage collection: log deleted files and total size",
        "description": "The data store garbage collection should list the names and the total size of all deleted files.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2289",
        "summary": "Allow importing of ACL with unknown principals",
        "description": "It should be possible to import ACLs with principals that are not known to the principal provider, yet.",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-3105",
        "summary": "NPE when versioning operations are concurrent",
        "description": "InternalVersionManagerBase.getParentNode occasionally throws an NPE:\n\n    protected static NodeStateEx getParentNode(NodeStateEx parent, String uuid, Name interNT)\n            throws RepositoryException {\n        NodeStateEx n = parent;\n        for (int i = 0; i < 3; i++) {\n            Name name = getName(uuid.substring(i * 2, i * 2 + 2));\n            if (n.hasNode(name)) {\n                n = n.getNode(name, 1);\n                assert n != null;\n            } else if (interNT != null) {\n                n.addNode(name, interNT, null, false);\n                n.store();\n                n = n.getNode(name, 1);\n                assert n != null;\n            } else {\n                return null;\n            }\n        }\n        return n;\n    }\n\nApparently getNode occasionally returns null due to race conditions.\n\nChanging the code to what's below appears to fix it:\n\n\n\n    protected static NodeStateEx getParentNode(NodeStateEx parent, String uuid, Name interNT)\n            throws RepositoryException {\n        NodeStateEx n = parent;\n        for (int i = 0; i < 3; i++) {\n            Name name = getName(uuid.substring(i * 2, i * 2 + 2));\n            NodeStateEx n2 = n.getNode(name, 1);\n            if (n2 != null) {\n                n = n2;\n            } else if (interNT != null) {\n                n2 = n.addNode(name, interNT, null, false);\n                n.store();\n                n = n2;\n            } else {\n                return null;\n            }\n        }\n        return n;\n    }\n\n(but likely moves the race condition somewhere else)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2319",
        "summary": "jackrabbit-jcr-client should put all test data under ./target",
        "description": "Currently the jackrabbit-jcr-client component drops a \"repository\" directory and the \"repository.xml\" and \"derby.log\" files into the project root when running the test suite. These files should go inside \"target\".",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2991",
        "summary": "jcr-server: DefaultItemCollection#unlock does not call DavSession#removeReference",
        "description": "DefaultItemCollection#unlock does not remove the token-reference from the DavSession that has been added\nbefore upon creating the lock. This causes pending lock-references thus the cache entries in JCRWebdavServer\nwill not be cleared filling up the cache although the locks have been properly released. \n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2563",
        "summary": "Add UserManager.createGroup(String groupID) method",
        "description": "As discussed on the dev list [1] I think it would be useful (and consistent inside the API) to have a UserManager.createGroup(String groupID) method.\n\nThe specification of the method would be:\n\n    /**\n     * Creates a Group for the given groupID must not be <code>null</code>.\n     * <br>\n     * Same as {@link #createGroup(Principal,String)} where the specified groupID\n     * is the name of a simple <code>Principal</code> implementation and the\n     * intermediate path is <code>null</code>.\n     *\n     * @param groupID The id of the new group, must not be <code>null</code>.\n     * @return The new <code>Group</code>.\n     * @throws AuthorizableExistsException in case the given groupID is already\n     * in use or another {@link Authorizable} with the same\n     * {@link Authorizable#getID() ID} exists.\n     * @throws RepositoryException If another error occurs.\n     */\n    Group createGroup(String groupID) throws AuthorizableExistsException, RepositoryException;\n\n[1] http://markmail.org/message/rjofzg4t3kiht7xv",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2431",
        "summary": "CooperativeFileLock improvements",
        "description": "The CooperativeFileLock doesn't have any test cases. Also, there are a few ways to improve it:\n\n- Avoid the exception \"lock file modified in the future\"\n- Stop the thread immediately after releasing the lock\n- Detect locked repositories a bit earlier\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1155",
        "summary": "Wrong link in javadoc of QNodeTypeDefinition",
        "description": "The javadoc of QNodeTypeDefinition links to javax.jcr.nodetype.NodeDefinition instead of javax.jcr.nodetype.NodeType",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2965",
        "summary": "Show referencing nodes in debug log when trying to delete a node with references",
        "description": "This can be very useful when trying to analyze errors from non-interactive applications in a production environment.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1750",
        "summary": "Creating QValue from stream: stream not closed",
        "description": "QValueFactoryImpl.create(InputStream) does not close the input stream as mandated by the contract. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1966",
        "summary": "[PATCH] Remove Stutter in NodeState",
        "description": "Code duplicates code for no reason\n\nIndex: src/main/java/org/apache/jackrabbit/jcr2spi/state/NodeState.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/jcr2spi/state/NodeState.java\t(revision 740824)\n+++ src/main/java/org/apache/jackrabbit/jcr2spi/state/NodeState.java\t(working copy)\n@@ -449,7 +449,7 @@\n              */\n             NodeState parent = getParent();\n             NodeId wspId = (NodeId) getWorkspaceId();\n-            def = definitionProvider.getQNodeDefinition(getParent().getNodeTypeNames(), getName(), getNodeTypeName(), wspId);\n+            def = definitionProvider.getQNodeDefinition(parent.getNodeTypeNames(), getName(), getNodeTypeName(), wspId);\n         }\n         return def;\n     }\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-778",
        "summary": "Error on query initialization - intermittent",
        "description": "About 1 in ten times, I get the error as shown in the stack trace below. This happens when I run test, or when I start the app. The only way to resolve (when testing) seems to be to blow away the repository. \n\nIt always happens at the point the query manager is accessed (triggering the query subsystem to start up). It DOES NOT cause an exception to be thrown back to the caller, I just noticed it in the logs. Basically the queries return NO data at all (and show up as test failures of course). \n\nIn each case when I startup the system/test, if the repository exists I use it, and (for tests) clean it by deleting the root node of the user content, and then starting again, otherwise there is nothing that exciting.\n\nPlease let me know if more info is needed.\n\n\nERROR 05-03 15:54:39,386 (LazyQueryResultImpl.java:getResults:266)  -Exception while executing query:\njava.io.IOException : No such file or directory\n    at java.io.UnixFileSystem.createFileExclusively(Native Method)\n    at java.io.File.createNewFile(File.java:850)\n    at org.apache.jackrabbit.core.query.lucene.FSDirectory$1.obtain( FSDirectory.java:119)\n    at org.apache.lucene.store.Lock.obtain(Lock.java:51)\n    at org.apache.lucene.store.Lock$With.run(Lock.java:98)\n    at org.apache.lucene.index.IndexReader.open(IndexReader.java:141)\n    at org.apache.lucene.index.IndexReader.open(IndexReader.java:136)\n    at org.apache.jackrabbit.core.query.lucene.AbstractIndex.getReadOnlyIndexReader(AbstractIndex.java:191)\n    at org.apache.jackrabbit.core.query.lucene.MultiIndex.getIndexReader (MultiIndex.java:616)\n    at org.apache.jackrabbit.core.query.lucene.SearchIndex.executeQuery(SearchIndex.java:384)\n    at org.apache.jackrabbit.core.query.lucene.LazyQueryResultImpl.executeQuery(LazyQueryResultImpl.java :204)\n    at org.apache.jackrabbit.core.query.lucene.LazyQueryResultImpl.getResults(LazyQueryResultImpl.java:244)\n    at org.apache.jackrabbit.core.query.lucene.LazyQueryResultImpl.<init>(LazyQueryResultImpl.java :161)\n    at org.apache.jackrabbit.core.query.lucene.QueryImpl.execute(QueryImpl.java:164)\n    at org.apache.jackrabbit.core.query.QueryImpl.execute(QueryImpl.java:142)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1454",
        "summary": "NullPointerException may be thrown when trying to enumerate observation event listeners",
        "description": "When calling the ObservationManager.getRegisteredEventListeners() a NullPointerException may be thrown if no event listener has been registered (yet). The reason for this is, that in the ClientObservationManager.getRegisteredEventListener method an internal field is access directly, which is created on demand and thus may be null.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2507",
        "summary": "JcrValueType#typeFromContentType throws IllegalArgumentException for type weak-ref and uri",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-736",
        "summary": "Wrong exeption returned from Repository.login(Credentials, String)",
        "description": "According to specification, calling Repository.login(Credentials, String) with a non-existent wokspaceName should return NoSuchWorkspaceException.\n\nIn fact it returns RepositoryException.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2127",
        "summary": "DataStore.close() is never called",
        "description": "I've searched through the jackrabbit-core code and never found a call to DataStore.close(), although the method exists on the DataStore interface",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2580",
        "summary": "NullPointerException when using ancestor axis in indexing configuration",
        "description": "Happens when there is an index-rule that matches the root node type and has a condition that uses the ancestor axis.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1336",
        "summary": "Bug in duplicate mapping check",
        "description": "There is a bug in the MappingDescriptor for checking if a mapping for a node type is already available. The following patch solves this problem:\n\nIndex: /Users/cziegeler/Developer/workspaces/default/jackrabbit/jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/mapper/model/MappingDescriptor.java\n===================================================================\n--- /Users/cziegeler/Developer/workspaces/default/jackrabbit/jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/mapper/model/MappingDescriptor.java\t(revision 614136)\n+++ /Users/cziegeler/Developer/workspaces/default/jackrabbit/jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/mapper/model/MappingDescriptor.java\t(working copy)\n@@ -75,7 +75,7 @@\n         if (null != classDescriptor.getJcrType() && !  \"\".equals(classDescriptor.getJcrType()) && \n         \t\t ! ManagerConstant.NT_UNSTRUCTURED.equals(classDescriptor.getJcrType()))\n         {\n-        \tif ((classDescriptorsByNodeType.get(classDescriptor.getClassName()) != null) &&\n+        \tif ((classDescriptorsByNodeType.get(classDescriptor.getJcrType()) != null) &&\n         \t\tclassDescriptor.usesNodeTypePerConcreteClassStrategy()\t)\n         \t{\n         \t    log.warn(\"Duplicate classdescriptor for node type : \" + classDescriptor.getJcrType());\t\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1524",
        "summary": "[PATCH] tests use 12 for month which is invalid",
        "description": "tests create calendar with 12 as a month, which is invalid. December is 11, so use Calendar.DECEMBER instead. - patch fixes this.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-785",
        "summary": "Updates to multiple workspaces (e.g. in a transaction) locked in cluster journal",
        "description": "Running a transaction that updates multiple workspaces (e.g. a versioning operation) will be locked, as they all try to acquire a non-reentrant lock in the cluster's journal. Short-term fix is to make the lock re-entrant. In the long run, a transaction context sensitive lock may be more appropriate.\n\nHow to reproduce: enable clustering in the test environment and let the test o.a.j.core.XATest.testSetVersionLabel() run. This will result in a deadlock when committing the operation.\n\nThis was initially reported by Rafa\u0142 Kwiecie\u0144 as a problem when using springmodules and clustering but turned out to be general problem with transactions and clustering. Thanks for reporting it!",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2817",
        "summary": "Upgrade to Tika 0.8",
        "description": "Apache Tika version 0.8 is now available, and we should upgrade to benefit from the various fixes and improvements included in that version.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2980",
        "summary": "Nodes that have properties marked for async extraction should be available for querying",
        "description": "The problems only appears when dealing with nodes that have async extractors. In this case we return a lightweight copy of the node (without the property that will be processed in the background).\n\nThe copy algorithm ignores certain field types (that have been probably introduced during the Lucene 3 upgrade, not sure) such as SingletonTokenStream(s).\nSo the lightweight copy does not include all the existing properties, therefore the node will not appear in queries during the extraction time.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1729",
        "summary": "Node#addNode fails with AccessDeniedException if session lacks read-permission to an ancestor",
        "description": "Consider a Session that has following permissions:\n/home  -> no permission\n/home/myself -> read|remove|set_property|add_node\n\nif this session tries to add a Node to /home/myself.\nAn AccessDeniedException is thrown indicateing that it can not read /home.\n\nThe Exception is caused by the Node's check, if it is checked-out.\nThis check asumes that the session has read-access to all its ancestors.\nWhich breaks in this case:\n\nsee NodeImpl internalIsCheckedOut()   (ln 3875)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2",
        "summary": "Mavenize Project",
        "description": "Mavenize project pending mailing list feedback.\n\nI'm attaching an out-dated zip that has some useful \"stuff\" to review or build upon.\n\nProposed flow:\n\n1) Review the maven specific elements in the zip:\n- project.xml, header.txt, license.txt, notice.txt, checkstyle.xml, project.properties, xdocs directory. NOTE: I know the license.txt and maybe header.txt are not correct per earlier discussions.\n2) Once new package layout/code is in svn - we can refactor this and move the maven related files into place.\n\nThoughts,\n  a) One of the artifacts generated is the bat file and supporting directory with the jar to run the sample app - could use some ideas on how maven should generate this.\n  b) How the local maven repo gets the jcr-api.jar? My current thinking is 'same as any non-redistributable artifact'. The user is responsible for downloading it to a local repository.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "TASK"
    },
    {
        "key": "JCR-315",
        "summary": "Support for OpenOffice text extraction",
        "description": "Hi, here is the patch.\n\n>hi nicolas,\n>\n>thanks for your offer to contribute your openoffice textfilter, that's greatly appreciated!\n>\n>i suggest you post a jira 'Improvement' or \"New Feature' issue and attach your code as an svn patch. somebody will take care \n>of it (i assume marcel), i.e. review your contribution and provide feedback/further instructions.\n\n>cheers\n>stefan\n\n>On 2/2/06, Nicolas Jouanin <nicolas.jouanin@gmail.com> wrote:\n>>\n>>\n>>\n>> Hi Stefan,\n>>\n>>\n>>\n>> I work with Martin Perez, main developper of jLibrary.\n>>\n>> Therefore, I developed a class which extracts metadata and text \n>> content from any openoffice file (that was not the hardest job). This \n>> class is already used into jLibrary.\n>>\n>> As Martin suggested me, I used this class to create a new TextFilter \n>> subclass into textfilters contrib project. I downloaded textfilters \n>> project from svn, created my class into the project tree and tested it \n>> with a test class , just like it was done with the other extractors.\n>>\n>> I can send you the code if you want to review it, or just tell me how \n>> I can commit it.\n>>\n>>\n>>\n>> Regards,\n>>\n>>\n>>\n>> Nicolas.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-866",
        "summary": "ResidualProperties Converter uses wrong AtomicType Converter on update",
        "description": "When writing back data, the ResidualPropertiesCollectionConverterImpl.internalSetProperties method looks at the type of the Java object\nto find the atomic type converter instead of getting the converter according to the collection descriptor.\n\nThis may lead to NullPointerExceptions in case the concrete type is an extension (or implementation) of the declared type.\n\nI am currently working on a patch to attache to this bug.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-356",
        "summary": "Replace license headers with new policy text",
        "description": "We need to replace all of the license headers with a new template\nthat replaces the Copyright and license lines with\n\n---BEGIN PROPOSED SOURCE FILE HEADER---\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  The ASF licenses this file to You\n  under the Apache License, Version 2.0 (the \"License\"); you may not\n  use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n---END PROPOSED SOURCE FILE HEADER---\n\nThe copyright line is being removed from files due to legal advice from ASF attorneys.\nIt is replaced with a statement that the copyright owners have licensed it to the ASF.\n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "TASK"
    },
    {
        "key": "JCR-1815",
        "summary": "Benchmark: Improve transparency of test results",
        "description": "as discussed in JCR-1501.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-512",
        "summary": "TCK: AbstractImportXmlTest incorrectly assumes mix:referenceable can be added to created node",
        "description": "isMixRefRespected() assumes that if the NodeTypeManager contains mix:referenceable, addMixin can be called to add mix:referenceable to a created node.  This assumption is incorrect for at least two reasons.  First, the created node might already be mix:referenceable, either because its primary node type is a subtype of mix:referenceable or because the implementation added mix:referenceable as a mixin type in creating the node.  Second, a repository may restrict the nodes to which mix:referenceable can be added.  In the extreme case, the repository may not allow mix:referenceable to be added to any node using addMixin, in which case the only referenceable nodes would be those which are mix:referenceable by virtue of primary type or the implementation's adding mix:referenceable as a mixin type at node creation.\n\nProposal: test canAddMixin before calling addMixin.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-86",
        "summary": "ItemStates in the ChangeLog can not be retrieved in the sequence they were created/modified/deleted",
        "description": "The itemstates are ordered by the hash code.\nIt's an issue with PersistenceManagers that check referencial integrity (e.g. rdbms).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1337",
        "summary": "Optimize first execution queries for DescendantSelfAxisWeight/ChildAxisQuery",
        "description": "The first execution of a query involving DescendantSelfAxisWeight/ChildAxisQuery is slow. Consecutive queries are faster because the hierarchy is cached",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2102",
        "summary": "getAllLinearVersions does not return the base version",
        "description": "It appears that for a given linear version history, getAllLinearVersions returns less versions than getAllVersions -- the root version seems to be missing.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-38",
        "summary": "Cannot version the root node",
        "description": "After making the root node versionable, the checkin method fails with the following exception. \n\njava.lang.ArrayIndexOutOfBoundsException: 0\n    at org.apache.jackrabbit.core.version.persistence.PersistentNode.copyFrom(PersistentNode.java:589)\n    at org.apache.jackrabbit.core.version.persistence.InternalFrozenNodeImpl.checkin(InternalFrozenNodeImpl.java:277)\n    at org.apache.jackrabbit.core.version.persistence.InternalFrozenNodeImpl.checkin(InternalFrozenNodeImpl.java:307)\n    at org.apache.jackrabbit.core.version.persistence.InternalFrozenNodeImpl.checkin(InternalFrozenNodeImpl.java:307)\n    at org.apache.jackrabbit.core.version.persistence.InternalVersionHistoryImpl.checkin(InternalVersionHistoryImpl.java:354)\n    at org.apache.jackrabbit.core.version.persistence.NativePVM.checkin(NativePVM.java:506)\n    at org.apache.jackrabbit.core.version.VersionManagerImpl.checkin(VersionManagerImpl.java:212)\n    at org.apache.jackrabbit.core.NodeImpl.checkin(NodeImpl.java:2184)\n    at com.gtnet.jcr.VersionedNodeTest.testVersionRootNode(VersionedNodeTest.java:218)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:31)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:78)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-905",
        "summary": "Clustering: race condition may cause duplicate entries in search index",
        "description": "There seems to be a race condition that may cause duplicate search index entries. It is reproducible as follows (Jackrabbit 1.3):\n1) Start clusternode 1 that just adds a single node of node type clustering:test.\n2) Shutdown clusternode 1.\n3) Start clusternode 2 with an empty search index.\n4) Execute the query  //element(*, clustering:test).\n4) Print the result of the query (UUIDs of nodes in the result set).\n\nWhen I just run clusternode 2, then there is one node in the resultset, as expected. However, when I debug clusternode 2 and have a breakpoint (i.e., a pause of a few seconds at line 306 of RepositoryImpl.java - just before the clusternode is started), then the resultset contains two results, both with the same UUID.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-670",
        "summary": "LocalNamespaceMappings does not make use of NameCache in NamespaceRegistryImpl",
        "description": "This basically means that the NameCache in NamespaceRegistryImpl is never used.\n\nThe LocalNamespaceMappings should also implement NameCache and forward calls to the NamespaceRegistryImpl for names\nwith namespace URIs that are not locally remapped. See proposed patch.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2868",
        "summary": "A failure to connect to a MySQL database when JackRabbit starts a session leaves a .lock file in the repository. Subsequent sessions cannot be created by the same thread.",
        "description": "I investigating the robustness of JackRabbit in the face of unexpected database errors, such as the database being unavailable. In my particular case, I am attempting to start a JackRabbit session using a TransientRepository while the database is not yet running. This correctly fails. However, if I attempt to create another session within the same thread after a short while, an exception occurs saying that the repository has already been locked. I would expect the repository folder not to be locked. Maybe the code meant to remove the .lock file was not triggered because of an uncaught exception.\n\nPlease see the attached files:\n-a test class to reproduce the problem\n-my repository.xml config\n-the log file quantel.txt with details about the stack trace.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2712",
        "summary": "Dirty Internal State on Transaction-Rollback during Global Transaction (container managed transaction)",
        "description": "Running the following code inside an Global Transaction (JTA, container managed transaction) causes problems.\n\nSession session = getRepsoitorySession(); \n      Node rootNode = session.getRootNode(); \n\n      Node test = rootNode.addNode(\"test\"); \n      test.addMixin(CTVRepositoryKonstanten.NODE_MIX_TYP_VERSION); \n      session.save(); \n      throw new RuntimeException(\"testException\");\n\nEverythink is fine, but if we execute it a second time we get an org.apache.jackrabbit.core.state.NoSuchItemStateException\n\norg.apache.jackrabbit.core.state.NoSuchItemStateException: b36d91bc-8687-428c-a767-2e087b13191a \nat org.apache.jackrabbit.core.state.SharedItemStateManager.getItemState(SharedItemStateManager.java:270) \nat org.apache.jackrabbit.core.state.LocalItemStateManager.getNodeState(LocalItemStateManager.java:107) \nat org.apache.jackrabbit.core.state.LocalItemStateManager.getItemState(LocalItemStateManager.java:172) \nat org.apache.jackrabbit.core.state.XAItemStateManager.getItemState(XAItemStateManager.java:260) \nat org.apache.jackrabbit.core.version.NodeStateEx.store(NodeStateEx.java:519) \nat org.apache.jackrabbit.core.version.NodeStateEx.store(NodeStateEx.java:489) \nat org.apache.jackrabbit.core.version.AbstractVersionManager.getParentNode(AbstractVersionManager.java:414) \nat org.apache.jackrabbit.core.version.AbstractVersionManager.createVersionHistory(AbstractVersionManager.java:357) \nat org.apache.jackrabbit.core.version.XAVersionManager.createVersionHistory(XAVersionManager.java:148) \nat org.apache.jackrabbit.core.version.AbstractVersionManager.getVersionHistory(AbstractVersionManager.java:273) \nat org.apache.jackrabbit.core.ItemImpl.initVersionHistories(ItemImpl.java:738) \nat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1097) \nat org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:915) \nat org.apache.jackrabbit.jca.JCASessionHandle.save(JCASessionHandle.java:180) \nat de.continentale.repo.CTVRepository.erstelleDokument(CTVRepository.java:2267)\n\nWe think that there is some internal state that is not cleaned up on rollback.\nRestarting the runtime (Application Server) \"solved\" this.\n\nMay be there are some same causes like in: JCR-2503, JCR-2613\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1403",
        "summary": "SPI: Describe equality requirements of ItemIds",
        "description": "Michael Duerig asked for clarification regarding the equality of  ItemIds.\n\nWhile discussing this we came to the following conclusion:\n\nTwo ItemIds should be considered equal if both the unique part and the path part are equal AND if they denote the same type of id (see #denotesNode).\n\nIf nobody objects i would adjust the javadoc of ItemId accordingly.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1504",
        "summary": "MS Excel Mime Type missing in MsExcelTextExtractor ",
        "description": "The MsExcelTextExtractor listens to mime type \"application/vnd.ms-excel\", but storing excels will result in mime type \"application/msexcel\", too. Such tagged files will not be indexed by the MsExcelTextExtractor. The class should register itself to both mime types like the MsWordTextExtractor does. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-216",
        "summary": "hrefs in dav responses should be url-escaped",
        "description": "the url in an href element of a dav response should be url-escaped. currently at least one webdav client (os x's webdavfs) chokes on unescaped urls (such as /home/bcm/file with spaces in its name.txt).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2880",
        "summary": "Save fails after setting a binary property twice",
        "description": "Setting a binary property twice discards the blob value of the first property state but does not remove the change from the changelog, resulting in an error on save:\n\njavax.jcr.RepositoryException: this BLOBFileValue has been disposed\n\tat org.apache.jackrabbit.core.value.RefCountingBLOBFileValue.copy(RefCountingBLOBFileValue.java:105)\n\nwill attach patch that adds the respective test to the jcr2spi tests.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2444",
        "summary": "Exception executing SQL2/JQOM with non-admin session",
        "description": "Constraints are correctly handled when session does not have access to a node:\n\nCaused by: javax.jcr.ItemNotFoundException: 21232f29-7a57-35a7-8389-4a0e4a801fc3\n        at org.apache.jackrabbit.core.SessionImpl.getNodeById(SessionImpl.java:545)\n        at org.apache.jackrabbit.core.query.lucene.constraint.NodeLocalNameOperand.getValues(NodeLocalNameOperand.java:44)\n        at org.apache.jackrabbit.core.query.lucene.constraint.ComparisonConstraint.evaluate(ComparisonConstraint.java:80)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2600",
        "summary": "AbstractLoginModule logs a warning on anonymous logins",
        "description": "Currently a \"No credentials available -> try default (anonymous) authentication\" warning is logged by AbstractLoginModule whenever an anonymous login is made. Since this is a normal situation, the log message should be at debug or at most info level.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-852",
        "summary": "Change Log-Level in DefaultIOListener",
        "description": "Please change loglevel for method onEnd(IOHandler handler, IOContext ioContext, boolean success) to debug",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1031",
        "summary": "RowIteratorImpl should make use of QueryResultRow.getValues()",
        "description": "Values are currently retrieved from regular nodes. Using QueryResultRow.getValues() uses less calls to the server.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1765",
        "summary": "Config: make all elements in the security configuration optional",
        "description": "in order not to introduce new mandatory elements in the security configuration.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-907",
        "summary": "Create HTML excerpt provider",
        "description": "Jackrabbit should have a built in HTML excerpt because web applications usually prefer HTML rather than XML.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2778",
        "summary": "Node.removeMixin fails if the mixin defines a protected child node",
        "description": "Node.removeMixin fails if the mixin to removed defines a protected child node.... the problem is caused by line 253 of RemoveMixinOperation.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2711",
        "summary": "BTreeManager needs more flexible mechanism for ignoring (internal) properties",
        "description": "The current BTreeManager implementation has some hard coded logic to ignore jcr:primaryType properties. There should be a mechanism to parametrize BTreeManager with a set of properties to ignore.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2915",
        "summary": "Creating AccessControlEntryImpl from a base entry results in wrong restrictions",
        "description": "during creation of a new AccessControlEntryImpl using a base entry the restrictions of the base entry are\nnot copied to the new instance.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2038",
        "summary": "Lower log level in o.a.j.jcr2spi.query.NodeIteratorImpl",
        "description": "NodeIteratorImpl.fetchNext() logs an error when it cannot load a node and skips that node. Since this is not an error condition (the node could have been deleted by another session), logging should occur at the warn level.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1983",
        "summary": "Provide change log consolidator",
        "description": "spi-commons should provide base implementations for consolidating change logs (Batch). ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-229",
        "summary": "Decouple packages in core.query",
        "description": "The packages o.a.j.c.query has cyclic dependencies to sub packages lucene, sql, xpath.\n\nDecoupling the packages will allow to better extend the query implementation with additional query languages.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1363",
        "summary": "Migrate to Lucene 2.3",
        "description": "",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2167",
        "summary": "CompactNodeTypeDefReader could auto-provide default namespace mappings if omitted",
        "description": "the default namespaces for 'jcr', 'nt', 'mix', '' should  be automatically registered during parsing if needed.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2891",
        "summary": "VersionManagerImplRestore internalRestoreFrozen method has identity versus equals bug",
        "description": "In method protected void internalRestoreFrozen(NodeStateEx state,\n                                         InternalFrozenNode freeze,\n                                         VersionSelector vsel,\n                                         Set<InternalVersion> restored,\n                                         boolean removeExisting,\n                                         boolean copy)\nin the VersionManagerImplRestore class line 557 the code performs an == instead of calling the NodeId.equals() method.  We ran into problems with the code that executes below this (trying to restore a folder node throws an ItemExistsException since same sibling not allowed on folder nodes)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2335",
        "summary": "Problems with jackrabbit-standalone",
        "description": "I'm having problems with the jackrabbit-standalone component not starting up properly because of two issues:\n\n* The bundle packaging doesn't include the WEB-INF/config.xml file. I assume this is because of the more recent bundle plugin version treating whitespace differently in the inlining settings.\n\n* The RMI binding fails if a local RMI registry is already running with another repository reference. I'm thinking of simply disabling the RMI registry bindings and using the http://localhost:8080/rmi address as the recommended RMI endpoint.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3084",
        "summary": "Script for checking releases",
        "description": "Script to automate checking of releases, similar to [0] \n(heavily inspired by the sling script)\n\nThe command line call will look like:\n    ./check-release.sh jukka 1.6.5 4fa1e032f9b641fbc5c9ff8d6ba76fdb58b539ba\n\nThis command will also be embedded in the emails announcements that come with each release, so anybody can easily run it.\n\n[0] http://svn.apache.org/repos/asf/sling/trunk/check_staged_release.sh\n",
        "label": "NUG",
        "classified": "OTHER",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1969",
        "summary": "Invalid node type definitions with test_nodetypes.xml",
        "description": "an attempt to register the node types defined with \ncore/src/test/resources/org/apache/jackrabbit/core/nodetype/xml/test_nodetypes.xml\nwill fail:\n\n- invalid reference constraint\n- autocreated prop-def without default values\n- invalid required type with autocreated prop-def (undefined is not allowed)\n- invalid required primary type (non existing)\n- invalid default primary type (non existing)\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2241",
        "summary": "Data Store: garbage collection should ignore removed items",
        "description": "The GCConcurrentTest fails sometimes. The problem is that\nthe garbage collector stops if a node or property was removed\nwhile scanning. Instead, the garbage collector should ignore the\nremoved item and continue.\n\n-------------------------------------------------------------------------------\nTest set: org.apache.jackrabbit.core.data.TestAll\n-------------------------------------------------------------------------------\nTests run: 19, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 21.282 sec <<< FAILURE!\ntestGC(org.apache.jackrabbit.core.data.GCConcurrentTest)  Time elapsed: 0.578 sec  <<< ERROR!\njavax.jcr.InvalidItemStateException: 5fc4130b-aee4-4bef-b51d-21420d78f315/{}data: the item does not exist anymore\n\tat org.apache.jackrabbit.core.ItemImpl.sanityCheck(ItemImpl.java:144)\n\tat org.apache.jackrabbit.core.PropertyImpl.getPropertyState(PropertyImpl.java:89)\n\tat org.apache.jackrabbit.core.PropertyImpl.getType(PropertyImpl.java:773)\n\tat org.apache.jackrabbit.core.data.GarbageCollector.recurse(GarbageCollector.java:310)\n\tat org.apache.jackrabbit.core.data.GarbageCollector.recurse(GarbageCollector.java:327)\n\tat org.apache.jackrabbit.core.data.GarbageCollector.recurse(GarbageCollector.java:327)\n\tat org.apache.jackrabbit.core.data.GarbageCollector.scanNodes(GarbageCollector.java:193)\n\tat org.apache.jackrabbit.core.data.GarbageCollector.scan(GarbageCollector.java:177)\n\tat org.apache.jackrabbit.core.data.GCThread.run(GCThread.java:52)\n\tat java.lang.Thread.run(Thread.java:619)\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2937",
        "summary": "ACL with glob restrictions does not work on '/'",
        "description": "i tried to define a ACL on '/' that would allow 'read' on '/' itself, but not for the nodes underneath. i tried \"*\", \"/*\", \"./*\" but none of them seem to do the desired effect.\n\neg:\neveryone,allow,jcr:read, '/'\neveryone,deny,jcr:read, '/', glob=\"/*\"\n\nthe same works for a non-root node.\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-789",
        "summary": "PathElement.equals doesn't handle INDEX_UNDEFINED",
        "description": "PathElement (and therefore Path) comparisons fail when INDEX_UNDEFINED is used (it's treated differently from INDEX_DEFAULT).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2200",
        "summary": "Implement Query.getBindVariableNames()",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-3225",
        "summary": "ConcurrentModificationException in QueryStatImpl",
        "description": "Running with qurystats enabled the Query#execute can throw ConcurrentModificationException\n\ncaused by the iterator which backing collection is changed from another thread\n\nsee logQuery method\n        Iterator<QueryStatDtoImpl> iterator = popularQueries.iterator();\n        while (iterator.hasNext()) {\n-->            QueryStatDtoImpl qsdi = iterator.next();\n            if (qsdi.equals(qs)) {\n                qs.setOccurrenceCount(qsdi.getOccurrenceCount() + 1);\n                iterator.remove();\n                break;\n            }\n        }\n        popularQueries.offer(qs);\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1834",
        "summary": "JSR 283: Create RepositoryFactory implementation",
        "description": "JSR 283 specifies a RepositoryFactory to retrieve a repository instance based on a map of parameters. We should have the following implementations:\n\n- local repository with repository home and repository configuration parameters\n- repository obtained via JNDI\n- repository obtained via RMI\n",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2861",
        "summary": "Internal Timeout Handling in the TransactionContext is not XA Spec. conform",
        "description": "The problem here is that in a 2 phase transaction the xa spec does not  \npermit a RB* return code in response to xa_commit().  The xa spec says  \nthe following about RB* return codes in the xa_commit() section:        \n                                                                        \n\"The resource manager did not commit the work done on behalf of the     \ntransaction branch.  Upon return, the resource manager has rolled back  \nthe branch?s work and has released all held resources.  These values may\nbe returned only if TMONEPHASE is set in flags\"                         \n                                                                        \nEssentially, the only two return codes from xa_commit that J2EE Containers can     \nhandle sensibly are XA_OK (normal case) and XA_RMFAIL.  RMFAIL will     \ncause the containers to retry to commit the  transaction.  Any other return code will result in a heuristic          \ntransaction outcome (non-atomic).  \n\nIn a xa environment the TMONEPHASE is not set on the flags and so XA_RBTIMEOUT is \nnot a permitted return code. A Container  transaction service cannot do anything to ensure an atomic     \noutcome if an XAResource fails to honour its promise to be able to commit it made when it answer XA_OK in response to xa_prepare(). \n\nThe internal timeout handling will rollback the Jackrabbit XAResource if the time exceeds between prepare and commit.\nand in the commit Method will always throw a XA_RBTIMEOUT.\n\nWe should not handle the timeout internal because this should make the container in a 2 Phase transaction.",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-572",
        "summary": "Referenced derby library behaves buggy on FreeBSD",
        "description": "The derby library referenced on dependencies page (http://jackrabbit.apache.org/dependencies.html) behaves buggy on FreeBSD. This is the same issue like the one with Magnolia CMS: http://jira.magnolia.info/browse/MAGNOLIA-818. Version derby-10.1.3.1 works fine.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2683",
        "summary": "Provide rename method for nodes",
        "description": "Currently renaming a node is a nuisance if the node's parent has orderable child nodes: The parents child nodes must be searched for the successor of the node to be moved, the node must be moved to its new name and then ordered before the successor. Furthermore the case where the to be moved node is the last node must be special cased. \n\nI thus propose to provide functionality for directly renaming nodes.  ",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1602",
        "summary": "DbDatastore: Problems indexing pdf file",
        "description": "As reported by Claus K\u00f6ll:\n\nWhen importing a pdf file into a repository configured with a DbDataStore the following exception occurs. This happens only when using the DbDataStore with copyWhenReading=true\n\njava.io.IOException: Stream closed\n       at java.io.BufferedInputStream.getBufIfOpen(BufferedInputStream.java:156)\n       at java.io.BufferedInputStream.read(BufferedInputStream.java:315)\n       at org.apache.jackrabbit.core.data.db.TempFileInputStream.read(TempFileInputStream.java:107)\n       at java.io.BufferedInputStream.read1(BufferedInputStream.java:265)\n       at java.io.BufferedInputStream.read(BufferedInputStream.java:324)\n       at java.io.BufferedInputStream.fill(BufferedInputStream.java:229)\n       at java.io.BufferedInputStream.read(BufferedInputStream.java:246)\n       at java.io.FilterInputStream.read(FilterInputStream.java:89)\n       at java.io.PushbackInputStream.read(PushbackInputStream.java:141)\n       at org.pdfbox.io.PushBackInputStream.peek(PushBackInputStream.java:71)\n       at org.pdfbox.io.PushBackInputStream.isEOF(PushBackInputStream.java:88)\n       at org.pdfbox.pdfparser.PDFParser.parseObject(PDFParser.java:370)\n       at org.pdfbox.pdfparser.PDFParser.parse(PDFParser.java:176)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-231",
        "summary": "[jcr-rmi] xpath queries don't work when the underlying QueryResult doesn't return the rows/nodes size",
        "description": "o.a.j.rmi.server.ServerQueryResult assumes the underlying NodeIterator always return the number of elements, but it migth return -1 in some cases [1], AFAIK depending on the jcr impl. When -1 is returned jcr-rmi fails to return the QueryResult. \n\ne.g. it fails with the following xpath query //*\n\n[1] http://www.day.com/maven/jsr170/javadocs/jcr-1.0/javax/jcr/RangeIterator.html#getSize()",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2477",
        "summary": "Log / trace wrapper: upgrade to JCR API 2.0",
        "description": "The JCR Log wrapper (jcrlog) currently only supports the JCR 1.0 API. It should be upgraded to 2.0. Also, the dependency to jackrabbit-core should be removed, and generics should be used.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1017",
        "summary": "Favour QValue.getPath() over getString() where appropriate",
        "description": "To avoid extra conversion round trips QValue.getPath() should be used instead of  QValue.getString() where appropriate.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1578",
        "summary": "Jcr2Spi: UpdateTest#testUpdateRemovesExtraProperty and #testUpdateAddsMissingSubtree fail occasionally",
        "description": "issue reported by jukka:\n\nEvery now and then I see the following jcr2spi test failures on a\nclean checkout:\n\n    Tests in error:\n      testUpdateRemovesExtraProperty(org.apache.jackrabbit.jcr2spi.UpdateTest)\n      testUpdateAddsMissingSubtree(org.apache.jackrabbit.jcr2spi.UpdateTest)\n\nThe problem seems to be caused by the test cases automatically\nchoosing the \"security\" workspace for the update test. The reason why\nthe tests only fail occasionally is that currently the ordering of the\nstring array returned by getAccessibleWorkspaceNames() is not\ndeterministic.\n\nI can work around the issue by making\nRepositoryImpl.getWorkspaceNames() explicitly sort the returned array\nof names, but a more proper fix would probably be to ensure that the\nworkspace selected by UpdateTest is useful for the test.\n\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1679",
        "summary": "Simple Webdav: dir with same name as repository has incorrect behavior",
        "description": "Using a default repository named \"default\" for example, creating a directory named \"default\" in that repository will have issues.  The directory will not behave correctly. \n\nViewing the dir in Jetty http://localhost:8080/jackrabbit/repository/default/default/ will show the contents of the \"default\" directory.  However, clicking on any of the contents will go to an incorrect URL.  E.g. if a directory named \"test\" was created, then the URL for test will be \"http://localhost:8080/jackrabbit/repository/default/test/\"  instead of \"http://localhost:8080/jackrabbit/repository/default/default/test/\".\n\nNotice that there is only one \"default\" in the path provided by jackrabbit.  \n\nThis causes the contents of such directories to be inaccessible",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-92",
        "summary": "Change defaultValues format in NodeTypes XML to jcr value",
        "description": "currently, the defaultValues serialization in the nodetypes.xml is the only one that uses internal value serialization, rather than the jcr string serialization.\neg:\n\n<propertyDef name=\"jcr:requiredPrimaryTypes\" ..... >\n  <defaultValues>\n    <defaultValue>{http://www.jcp.org/jcr/nt/1.0}base</defaultValue>\n  </defaultValues>\n</propertyDef>\n\nthis in not very handy, when the custom_nodetypes.xml should be written automatically.\ni suggest to change the serialization to use the jcr value one:\n\n<propertyDef name=\"jcr:requiredPrimaryTypes\" ..... >\n  <defaultValues>\n    <defaultValue>nt:base</defaultValue>\n  </defaultValues>\n</propertyDef>\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1538",
        "summary": "[patch] add toString for NodeImpl and PropertyImpl",
        "description": "add toString for NodeImpl and PropertyImpl with new format. see how it is liked, before adding more.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2611",
        "summary": "DefaultHighlighter.java does not encode illegal XML characters",
        "description": "When merging excerpts (method protected String mergeFragments(...) in DefaultHighlighter.java), illegal XML characters are not encoded in all places.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-940",
        "summary": "add db connection autoConnect for BundleDbPersistenceManager.",
        "description": "Since bundled db pm doesn't inherited from database pm, it can't reconnect once database is bounced. it would be nice to add this feature. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2377",
        "summary": "Avoid docFreq calls for non-fulltext queries",
        "description": "Looking up the document frequency for a query terms costs I/O and is only useful for fulltext queries (-> the document frequency has an influence on the relevance of a result node). Simple constraints like: @foo = 'bar' may return a constant value for docFreq.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-149",
        "summary": "TextFilter implementations in a new project under contrib",
        "description": " AFAIK the TextFilters sent by J\u00e1n Hala?a were not added yet. If that's the case, I think we can create a project under contrib with all the implementations in order to avoid adding new dependencies to the core distribution.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3223",
        "summary": "Disallow unregistering of node types still (possibly) in use",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-289",
        "summary": "jcr-server: make auth-header configurable for JCR-Server",
        "description": "In WEB-INF/web.xml, there is a section (commented-out by default) that reads:\n        <init-param>\n            <param-name>authenticate-header</param-name>\n            <param-value>Basic realm=\"Jackrabbit Webdav Server\"</param-value>\n            <description>\n                Defines the value of the 'WWW-Authenticate' header.\n            </description>\n        </init-param>\n\nThis parameter is ignored (not loaded) by the code - the default string is always used instead\nNote: this was more of a problem before JCR-286 had been fixed\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-653",
        "summary": "Some Workspace tests require a second workspace",
        "description": "Some workspace test require a second workspace even though it is not used in the test cases.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-196",
        "summary": "jcr:like() does not scale well on large value ranges",
        "description": "There are two major issues with the current WildcardQuery implementation:\n\n1) A wildcard expression is restricted to match at most 1024 terms, otherwise a TooManyClauses exception is thrown. Similar to the RangeQuery issue: JCR-111\n2) The enumeration over the terms that match the wildcard pattern is slow",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-413",
        "summary": "JCA will not compile with J2EE1.3 classes",
        "description": "In JCAManagedConnectionFactory, the constructor invoked to throw ResourceException does not exist under J2EE1.3 / JCA1.1 classes.\n throw new ResourceException(e)  -  line 136 and line 277.\n\nInstead the code needs to do something like:\n\n            ResourceException exception = new ResourceException(\"Failed to create session\");\n            exception.setLinkedException(e);\n            throw exception;\n\nThis will allow it to compile/run under J2EE1.3\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-828",
        "summary": "CheckPermissionTest-testCheckPermission() doesn't allow config of node type to be created",
        "description": "CheckPermissionTest-testCheckPermission() doesn't allow configuration of node type to be created. Proposal to re-use the testNodeType config property.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-159",
        "summary": "JCR-RMI UnmarshalException when calling getProperty()",
        "description": "I've been trying to get the JCR-RMI adaptors going to talk to my noddy test repository. It seems I can successfully login and traverse the nodes (getNode etc..) but whenever I try to get something from a nt:resource (actually I've subclassed nt:resource to add our own properties) I get the following exception:\n\norg.apache.jackrabbit.rmi.client.RemoteRepositoryException: error unmarshalling return; nested exception is: \n\tjava.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: org.apache.jackrabbit.value.BinaryValue: error unmarshalling return; nested exception is: \n\tjava.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: org.apache.jackrabbit.value.BinaryValue\n\tat org.apache.jackrabbit.rmi.client.ClientProperty.getValue(ClientProperty.java:139)\n\tat org.apache.jackrabbit.rmi.client.ClientProperty.getString(ClientProperty.java:131)\n\tat ClientTest.main(ClientTest.java:20)\nCaused by: java.rmi.UnmarshalException: error unmarshalling return; nested exception is: \n\tjava.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: org.apache.jackrabbit.value.BinaryValue\n\tat sun.rmi.server.UnicastRef.invoke(UnicastRef.java:164)\n\tat org.apache.jackrabbit.rmi.server.ServerProperty_Stub.getValue(Unknown Source)\n\tat org.apache.jackrabbit.rmi.client.ClientProperty.getValue(ClientProperty.java:137)\n\t... 2 more\n\nMy svn is up-to-date as of this morning 2005/7/5 although the maven builds don't inspire much confidence as it falls over with Jelly exceptions at various points and there's a couple of dozen unit tests that fail. Don't know if this is the norm, the maven reports on the jackrabbit main site reports suggest not? But calling the same code with an in-process repository works fine.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2647",
        "summary": "Reduce temporary memory usage of hierarchy cache initialization",
        "description": "Initializing the hierarchy cache temporarily uses memory, which is linear to the size of the index segment. This process should be split into multiple phases to limit the memory usage to a fixed amount.\n\nThe temporary memory usage for an index segment current is about 170 bytes per node.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2844",
        "summary": "MaxCount not working correctly in user/group query when restricting to group members",
        "description": "For user/group queries having a scope *and* a limit clause maxCount does not work correctly.\n\n    builder.setScope(\"contributors\", false);\n    builder.setLimit(0, 50);\n\nIn the above case, the result might contain to few results. \n\nThis is related to JCR-2829",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2799",
        "summary": "QPropertyDefinitionImpl.equals() is implemented incorrectly ",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-926",
        "summary": "Global data store for binaries",
        "description": "There are three main problems with the way Jackrabbit currently handles large binary values:\n\n1) Persisting a large binary value blocks access to the persistence layer for extended amounts of time (see JCR-314)\n2) At least two copies of binary streams are made when saving them through the JCR API: one in the transient space, and one when persisting the value\n3) Versioining and copy operations on nodes or subtrees that contain large binary values can quickly end up consuming excessive amounts of storage space.\n\nTo solve these issues (and to get other nice benefits), I propose that we implement a global \"data store\" concept in the repository. A data store is an append-only set of binary values that uses short identifiers to identify and access the stored binary values. The data store would trivially fit the requirements of transient space and transaction handling due to the append-only nature. An explicit mark-and-sweep garbage collection process could be added to avoid concerns about storing garbage values.\n\nSee the recent NGP value record discussion, especially [1], for more background on this idea.\n\n[1] http://mail-archives.apache.org/mod_mbox/jackrabbit-dev/200705.mbox/%3c510143ac0705120919k37d48dc1jc7474b23c9f02cbd@mail.gmail.com%3e\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-52",
        "summary": "First Steps document is outdated",
        "description": "As reported by Manoj Prasad on the development mailing list, the code and configuration shown on the First Steps document [1] is no longer up to date with the latest Jackrabbit sources. The differences are:\n\n   * the Versioning element needs to be added to the repository configuration file\n   * the output values printed by the examples have changes (log messages, new node types, etc.)\n   * multiple values (especially jcr:mixinTypes properties) are not handled correctly\n\nThe document should be updated.\n\n[1] http://incubator.apache.org/jackrabbit/firststeps.html",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-450",
        "summary": "Memory leak in UUIDDocId",
        "description": "The hierarchy cache of the search index uses DocId's to reference the parent of a Node. One implementation of a DocId is the UUIDDocId which may hold a reference to the IndexReader that was used to calculate the id. UUIDDocId's are invalidated on a lazy basis. That is the referenced IndexReader may still be present even though the IndexReader instance has long been closed.\n\n-> UUIDDocId should only hold a weak reference to the IndexReader.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1579",
        "summary": "Improved XML export handling",
        "description": "As mentioned in JCR-1574, the current XML export functionality is generating workarounds like the new PropertyWrapper class. I'd like to refactor and clean up the XML export stuff so that such workarounds wouldn't be needed.\n\nAn additional bonus would be to make both core and jcr2spi use the same XML export mechanism. For example the one in core already supports JSR 283 shareable nodes, but the one in jcr2spi does not.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1168",
        "summary": "broken test in AddEventListener",
        "description": "Here's the test code, comments inline prefixed with \"reschke\"\n\n    /**\n     * Tests if {@link javax.jcr.observation.Event#NODE_ADDED} is created only\n     * for the specified path if <code>isDeep</code> is <code>false</code>.\n     */\n    public void testIsDeepFalseNodeAdded() throws RepositoryException {\n        EventResult listener = new EventResult(log);\n\n        // reschke: we are listening for changes at testRoot/nodeName1, with isDeep==false \n        obsMgr.addEventListener(listener, Event.NODE_ADDED, testRoot + \"/\" + nodeName1, false, null, null, false);\n\n        // reschke; node at \"testRoot/nodeName1\" being created, the associated parent node for this event is \"testRoot\"\n        Node n = testRootNode.addNode(nodeName1, testNodeType);\n\n        // reschke: node at \"testRoot/nodeName1/nodeName2\" being created, the associated parent node for this event is \"testRoot/nodeName1\"\n        n.addNode(nodeName2);\n        testRootNode.save();\n\n        Event[] events = listener.getEvents(DEFAULT_WAIT_TIMEOUT);\n        obsMgr.removeEventListener(listener);\n\n        // reschke: test case expects event with path \"testRoot/nodeName1\"\n        checkNodeAdded(events, new String[]{nodeName1});\n    }\n\nSo, in plain english:\n\n- test case listens for events where the associated parent node equals \"testRoot/nodeName1\", but\n- it expects a single event where the Event.getPath() returns \"testRoot/nodeName1\".\n\nThis is incorrect (IMHO), because the associated parent node for *that* event is \"testRoot\". \n\nSo the correct test would be to check for:\n\n        checkNodeAdded(events, new String[]{nodeName1 + \"/\" + nodeName2});\n\nMaking this change of course leads to a test failure reported against the RI.\n\nFeedback appreciated.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2109",
        "summary": "Remove deprecated classes in jcr-commons",
        "description": "There are many classes in jackrabbit-jcr-commons that we've replaced with better alternatives in spi-commons.\n\nI'd like to clean things up by removing the deprecated versions from jcr-commons now that we're upgrading to Jackrabbit 2.0",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2919",
        "summary": "Security of token base authentication",
        "description": "Token based authentication as implemented with JCR-2851 seems to exhibit a security issue: the token returned by the server consists of the identifier of a (newly created) node in the repository. An attacker who is able to guess (or acquire by other means i.e. via log files) that identifier will be granted access to the repository. Worse yet, JCR-2857 introduces sequential node ids. Guessing is a piece of cake in such a setup.\n\nI think we should decouple authentication secrets from node ids. A simple solution would be to store the secret in a token attribute and delegate generation of the secret to a dedicated handler. Such a handler can then use a secure random generator, private/public key encryption or whatever other method that is deemed appropriate to generate the authentication secret. \n\nInitial discussion see: http://markmail.org/thread/aspetgvmj2qud25a",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3275",
        "summary": "Audit log",
        "description": "JCR-2031 added the user name and path in debug logs for audit purposes. There are some problems with the fix that I had outlined in the comments for JCR-2031 and provided a patch. Additionally, it would use useful to add an update counter and size information to the debug log as well. Something like this:\n\n17.03.2009 14:43:37 [1] 18216140 admin@/apps/acme/templates/contentpage/thumbnail.png (12343) \n17.03.2009 14:43:37 [2] 18216141 admin@/apps/acme/templates/contentpage/my.png (123) \n17.03.2009 14:43:37 [3] 18216142 admin@/apps/acme/templates/contentpage/blah.png (1423) \n17.03.2009 14:43:37 [4] 18216143 admin@/apps/acme/templates/contentpage/test.png (123423) \n17.03.2009 14:43:37 [5] 18216144 admin@/apps/acme/templates/contentpage/test2.png (123423) \n\n<date> <time> [<counter>] <txid> <userid>@<path> (<size>)\n\nWe should also think about whether we want this log as part of regular jackrabbit log or in a separate audit log. \n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1577",
        "summary": "Remove RepositoryService.getRootId()",
        "description": "For consistency reasons jcr2spi should use idFactory.createNodeId((String) null, pathFactory.getRootPath()) everywhere to build the NodeId of the root node. having two separate methods is confusing.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1836",
        "summary": "Persistence: support property databaseType",
        "description": "In persistence managers and cluster journal the term 'schema' is used to mean 'database type'. \n\nUsing the term 'schema' for that is actually quite confusing (in my view):\n\nThe definition of schema http://en.wikipedia.org/wiki/Database_schema is \"the schema defines the tables, the fields in each table, and the relationships between fields and tables.\"\n\nAdditionally in most databases a schema is is a name space within a database: http://java.sun.com/j2se/1.4.2/docs/api/java/sql/DatabaseMetaData.html#getSchemas() .\n\nI suggest to support the property 'databaseType' in addition to 'schema' for the persistence managers and the cluster journal.\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2805",
        "summary": "Jackrabbit Utilites upgrade to Jackrabbit 2.1.0",
        "description": "I'm including a patch for the jcrutil project in the sandbox, for the S3 DataStore to work with 2.1.0, as well as the VFS.  Also using Tika for MIME type resolution.  Please look this over and feel free to improve, this is something I played with but didn't stress test.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2467",
        "summary": "Collection parameter of CompactNodeTypeDefWriter#write should be covariant",
        "description": "The Collection<QNodeTypeDefinition> parameter of the CompactNodeTypeDefWriter#write methods should have type Collection<? extends QNodeTypeDefinition>. ",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2898",
        "summary": "[patch] remove bogus test",
        "description": "code checks an int to see if it's bigger than MAX_VALUE which is impossible -- removed.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2090",
        "summary": "JSR 283: new methods on NodeType",
        "description": "JSR 283 adds the methods\n\n  NodeType.getSubtypes\n\nand\n\n  NodeType.getDeclaredSubtypes",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-258",
        "summary": "Jcr-Server Contrib: Remove JDOM dependencies",
        "description": "JDOM has been replace throught the jackrabbit project except the jcr-server contrib.\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-610",
        "summary": "Upgrade to Derby 10.2",
        "description": "Apache Derby 10.2 was released recently. The release contains a number of improvements (including performance) and requires no special upgrade procedures. I suggest we upgrade to Derby 10.2 along with Lucene 2.0 (JCR-352) and Maven 2 (JCR-332).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-796",
        "summary": "AbstractQueryTest does not handle unknown result size properly",
        "description": "If Node/RowIterator.getSize() returns -1 the method AbstractQueryTest.checkResult() should count the nodes in the iterator manually.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-532",
        "summary": "Incorrect iterator position in JCR-RMI when skipping large number of entries",
        "description": "The positionOfBuffer variable in ClientIterator gets out of sync more than ServerAdapter.bufferLength items.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-51",
        "summary": "Node.restore fails with multiple mixin types",
        "description": "Restoring a node that has more than one mixin type causes the exception below. \n\njava.lang.NullPointerException\n\tat org.apache.jackrabbit.core.NodeImpl.restoreFrozenState(NodeImpl.java:3286)\n\tat org.apache.jackrabbit.core.NodeImpl.internalRestore(NodeImpl.java:3243)\n\tat org.apache.jackrabbit.core.NodeImpl.internalRestore(NodeImpl.java:3210)\n\tat org.apache.jackrabbit.core.NodeImpl.restore(NodeImpl.java:2821)\n\tat com.gtnet.jcr.VersionedNodeTest.testNodeVersionAndRestore(VersionedNodeTest.java:311)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:31)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:78)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2892",
        "summary": "Large fetch sizes have potentially deleterious effects on VM memory requirements when using Oracle",
        "description": "Since Release 10g, Oracle JDBC drivers use the fetch size to allocate buffers for caching row data.\ncf. http://www.oracle.com/technetwork/database/enterprise-edition/memory.pdf\n\nr1060431 hard-codes the fetch size for all ResultSet-returning statements to 10,000. This value has significant, potentially deleterious, effects on the heap space required for even moderately-sized repositories. For example, the BUNDLE table (from 'oracle.ddl') has two columns -- NODE_ID raw(16) and BUNDLE_DATA blob -- which require 16 b and 4 kb of buffer space, respectively. This requires a buffer of more than 40 mb [(16+4096) * 10000 = 41120000].\n\nIf the issue described in JCR-2832 is truly specific to PostgreSQL, I think its resolution should be moved to a PostgreSQL-specific ConnectionHelper subclass. Failing that, there should be a way to override this hard-coded value in OracleConnectionHelper.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-496",
        "summary": "TCK: PropertyDefTest and NodeDefTest do not respect the value of the testroot configuration property",
        "description": "In PropertyDefTest and NodeDefTest, the test setup doesn't respect the value of the testroot configuration property.\n\nProposal: use the testroot configuration property.\n\nPatch for PropertyDefTest:\n--- nodetype/PropertyDefTest.java       (revision 422074)\n+++ nodetype/PropertyDefTest.java       (working copy)\n@@ -94,7 +94,7 @@\n  \n         session = helper.getReadOnlySession();\n         manager = session.getWorkspace().getNodeTypeManager();\n-        rootNode = session.getRootNode();\n+        rootNode = testRootNode;\n     }\n\nPatch for NodeDefTest:\n--- nodetype/NodeDefTest.java   (revision 422074)\n+++ nodetype/NodeDefTest.java   (working copy)\n@@ -68,7 +68,7 @@\n  \n         session = helper.getReadOnlySession();\n         manager = session.getWorkspace().getNodeTypeManager();\n-        rootNode = session.getRootNode();\n+        rootNode = testRootNode;\n     }\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2448",
        "summary": "Introduce SessionInfo parameter for AbstractRepositoryService.createRootNodeDefinition()  ",
        "description": "SPI implementations might require access to the state of the current session in order to fulfill the contract of AbstractRepositoryService.createRootNodeDefinition(). I therefore suggest to add a SessionInfo parameter to this method. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1118",
        "summary": "Upgrade contrib/bdb-persistence to work w/Jackrabbit 1.3",
        "description": "The bdb-persistence PM in contrib should be upgraded to work w/Jackrabbit 1.3.1",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "TASK"
    },
    {
        "key": "JCR-1160",
        "summary": "JCR2SPI: test regression for WorkspaceMoveReferenceableTest.testMoveNodesReferenceableNodesNewUUID",
        "description": "The latest changes (up to 581637) seems to have broken TCK tests:\n\n\n-------------------------------------------------------------------------------\nTest set: org.apache.jackrabbit.test.TestAll\n-------------------------------------------------------------------------------\nTests run: 1037, Failures: 6, Errors: 2, Skipped: 0, Time elapsed: 102.644 sec <<< FAILURE!\ntestMoveNodesReferenceableNodesNewUUID(org.apache.jackrabbit.test.api.WorkspaceMoveReferenceableTest)  Time elapsed: 0.03 sec  <<< ERROR!\njavax.jcr.InvalidItemStateException: Item 'org.apache.jackrabbit.jcr2spi.NodeImpl@13ef9df' doesn't exist anymore\n    at org.apache.jackrabbit.jcr2spi.ItemImpl.checkStatus(ItemImpl.java:428)\n    at org.apache.jackrabbit.jcr2spi.NodeImpl.getName(NodeImpl.java:120)\n    at org.apache.jackrabbit.test.api.WorkspaceMoveReferenceableTest.testMoveNodesReferenceableNodesNewUUID(WorkspaceMoveReferenceableTest.java:57) ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1344",
        "summary": "Unsynchronized NameFactoryImpl initialization",
        "description": "org.apache.jackrabbit.spi.commons.name.NameFactoryImpl uses an unsafe pattern when initializing:\n\n    private static NameFactory FACTORY;\n    private NameFactoryImpl() {};\n    public static NameFactory getInstance() {\n        if (FACTORY == null) {\n            FACTORY = new NameFactoryImpl();\n        }\n        return FACTORY;\n    }\n\nThis is bad in a multi-threaded environment (see http://www.ibm.com/developerworks/library/j-dcl.html for details).",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2537",
        "summary": "spi2davex: clear uri-lookup after removing node identified with uniqueID",
        "description": "some test cases of DocumentViewImportTest fail in the setup (line 325 of AbstractImportXmlTest) since the uri resolved from the specified\nnodeID still refers to the node removed during the initial import before. this would equally cause problems whenever a referenceable node was\nreplaced by another node and can easily be fixed by clearing the uri-cache after the removal as it was already done for move.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1269",
        "summary": "Stop using BaseException",
        "description": "The o.a.j.BaseException class is deprecated (since JCR-1169) and not caught anywhere, so there's no need to keep using it.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1039",
        "summary": "Bundle Persistence Manager error - failing to read bundle the first time",
        "description": "Code:\nNodeIterator entiter = null;\nNode root = null, contNode = null, entsNode = null;\n\ntry\n{\n    root = session.getRootNode();\n    contNode = root.getNode(\"sr:cont\");\n    entsNode = contNode.getNode(\"sr:ents\");\n    entiter = entsNode.getNodes();\n}\ncatch (Exception e)\n{\n    logger.error(\"Getting ents nodes\", e);\n}\n\nOutput:\n12359 [http-8080-Processor24] ERROR org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager - failed to read bundle: c3a09c19-cc6b-45bd-a42e-c4c925b67d02: java.io.IOException: ERROR 40XD0: Container has been closed\n12375 [http-8080-Processor24] ERROR com.taxila.editor.sm.RepoOperations - Getting ents nodes\njavax.jcr.PathNotFoundException: sr:ents\n    at org.apache.jackrabbit.core.NodeImpl.getNode(NodeImpl.java:2435)\n    at com.taxila.editor.sm.RepoOperations.getEntityNodes (RepoOperations.java:4583)\n    at com.taxila.editor.sm.RepoOperations.displayEntities(RepoOperations.java:4159)\n    at com.taxila.editor.sm.RepoOperations.displayEntities(RepoOperations.java:4114)\n    at com.taxila.editor.em.um.MainEntityForm.reset (MainEntityForm.java:215)\n    at org.apache.struts.taglib.html.FormTag.doStartTag(FormTag.java:640)\n    at org.apache.jsp.pages.jsp.entity.MainEntity_jsp._jspService(MainEntity_jsp.java:414)\n    at org.apache.jasper.runtime.HttpJspBase.service (HttpJspBase.java:97)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:802)\n    at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:332)\n    at org.apache.jasper.servlet.JspServlet.serviceJspFile (JspServlet.java:314)\n    at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:264)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:802)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter (ApplicationFilterChain.java:252)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)\n    at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java :672)\n    at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:463)\n    at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:398)\n    at org.apache.catalina.core.ApplicationDispatcher.forward (ApplicationDispatcher.java:301)\n    at org.apache.struts.action.RequestProcessor.doForward(RequestProcessor.java:1014)\n    at org.apache.struts.action.RequestProcessor.processForwardConfig(RequestProcessor.java:417)\n    at org.apache.struts.action.RequestProcessor.processActionForward(RequestProcessor.java:390)\n    at org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:271)\n    at org.apache.struts.action.ActionServlet.process (ActionServlet.java:1292)\n    at org.apache.struts.action.ActionServlet.doPost(ActionServlet.java:510)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:709)\n    at javax.servlet.http.HttpServlet.service (HttpServlet.java:802)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java :173)\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213)\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178)\n    at org.apache.catalina.core.StandardHostValve.invoke (StandardHostValve.java:126)\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105)\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107)\n    at org.apache.catalina.connector.CoyoteAdapter.service (CoyoteAdapter.java:148)\n    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869)\n    at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java :664)\n    at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527)\n    at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80)\n    at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run (ThreadPool.java:684)\n    at java.lang.Thread.run(Unknown Source)\n\nOn the other hand if I do this:\nCode:\ntry\n{\n    root = session.getRootNode ();\n    contNode = root.getNode(\"sr:cont\");\n    entsNode = contNode.getNode(\"sr:ents\");\n    entiter = entsNode.getNodes();\n}\ncatch (Exception e)\n{\n    logger.error(\"Getting ents nodes\", e);\n    try\n    {\n        entsNode = contNode.getNode(\"sr:ents\");\n        entiter = entsNode.getNodes();\n    }\n    catch (Exception e1)\n    {\n        e1.printStackTrace();\n    }\n}\n\nOutput:\nThe first error as in the previous case comes, but the second execution of the entsNode = contNode.getNode(\"sr:ents\"); statement returns the right node, and hence the iterator.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2995",
        "summary": "jcr2spi: create ChangePolling thread on demand",
        "description": "currently a new ChangePolling thread is created for every single session even if there is neither observation eventlistener nor cachebehaviour#observation.\ni think we could create that on demand.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-724",
        "summary": "PropertyReadMethodsTest.testIsSame leaks session",
        "description": "The test case obtains a second session but doesn't logout().\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2389",
        "summary": "Update dependency versions for commons-collections, slf4j and derby",
        "description": "Some of the dependencies used by the 2.0-beta1 could be upgraded:\ncommons-collections from 3.1 to 3.2.1\nslf4j from 1.5.3 to 1.5.8\nderby from 10.2.1.6 to 10.5.3.0\n\nNot sure about derby but the other two seems to be just drop in replacements for their older verisons.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "TASK"
    },
    {
        "key": "JCR-2420",
        "summary": "Node removal fails with AccessDeniedException",
        "description": "I have a hierarchy of nodes which are all access controllable. The following hierarchy illustrates the setup for my problem.\nroot  -  read permissions to everyone\n  | - subFolder  -  all permissions to user A\n        | - subsubFolder  -  all permissions to user A\n\nThe user A has all rights from the node \"subFolder\" downwards.\n\nI tried to remove the node \"subsubFolder\" with the user A. Clearly A has enough permissions to remove the node. But as soon as I call Session.save() an AccessDeniedException is thrown.\n\nI did a lot of debugging and found a possible cause for this fault. It led me to the function ACLProvider.AclPermissions.buildResult(). All line references are based on the source code in the subversion repository found here: http://svn.apache.org/viewvc/jackrabbit/tags/1.6.0/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/security/authorization/acl/ACLProvider.java?view=markup.\nOn line 458 Jackrabbit collects all access control entries of the node, that I want to remove, and all its parents and puts it in the variable \"entries\". In my example this variable contains three entries:\n1. all permissions to user A\n2. all permissions to user A\n3. read permissions to everyone\nOn lines 460 - 466 it collects all access control entries of the node, that I want to remove, and puts it in \"localACEs\". This variable contains one entry: all permissions to user A.\nIf I want to be able to remove \"subsubFolder\", user A needs the permission from the parent node. The permissions of the parent nodes of \"subsubFolder\" are: all permissions to user A and read permissions to everyone. But that's where the access check fails. In line 488 Jackrabbit checks if a permission from \"entries\" is local or not by looking it up in \"localACEs\". If it is in there, the permission is local, else not. Unfortunately it recognizes the permission of the node \"subFolder\" as local. Thus the permissions of the parent nodes of \"subsubFolder\" are: read permissions to everyone. So I cannot remove the node.\nThe source of the error is the equals check of the access control entries. The permissions of node \"subFolder\" are considered equal to the one of \"subsubFolder\". If I explicitly assign the permission \"remove node permission to user A\" to the node \"subFolder\", it works fine, because it is recognized as parent permission.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2916",
        "summary": "Avoid String.intern() when indexing",
        "description": "Lucene 3.0 now allows to create Fields with a String name that is already interned. We should use the new constructor in NodeIndexer to avoid unnecessary String.intern() calls. The field names Jackrabbit uses are available in FieldNames and already interned.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-244",
        "summary": "Support contains queries with wildcard prefix",
        "description": "The current implementation only allows wildcards in the middle or at the end of a search term. \n\nThe following queries work right now:\n//*[jcr:contains(., 'foo*')\n//*[jcr:contains(., 'fo?o')\n\nBut the following does not:\n//*[jcr:contains(., '*bar')\n\nThere was already a thread in the mailing list on this topic:\nhttp://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/3304",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2242",
        "summary": "Unsynchronized access to MultiIndex#indexes",
        "description": "This may result in a concurrent modification exception:\n\njava.util.ConcurrentModificationException\n\tat java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)\n\tat java.util.AbstractList$Itr.next(AbstractList.java:343)\n\tat org.apache.jackrabbit.core.query.lucene.MultiIndex.getIndexReader(MultiIndex.java:744)\n\tat org.apache.jackrabbit.core.query.lucene.MultiIndex.getIndexReader(MultiIndex.java:712)\n\tat org.apache.jackrabbit.core.query.lucene.SearchIndex.getIndexReader(SearchIndex.java:1024)\n\tat org.apache.jackrabbit.core.query.lucene.SearchIndex.executeQuery(SearchIndex.java:820)\n\tat org.apache.jackrabbit.core.query.lucene.SingleColumnQueryResult.executeQuery(SingleColumnQueryResult.java:78)\n\tat org.apache.jackrabbit.core.query.lucene.QueryResultImpl.getResults(QueryResultImpl.java:293)\n\tat org.apache.jackrabbit.core.query.lucene.SingleColumnQueryResult.<init>(SingleColumnQueryResult.java:70)\n\tat org.apache.jackrabbit.core.query.lucene.QueryImpl.execute(QueryImpl.java:132)\n\tat org.apache.jackrabbit.core.query.QueryImpl.execute(QueryImpl.java:127)\n\nThis is usually very unlikely but with the recent changes to our tests, index flushes are very frequent and may cause the above exception.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3055",
        "summary": "NPE in event polling thread",
        "description": "This exception occurs when running the jcr2dav integration tests. This surfaces as a  side effect of JCR-3046. The root cause is refresh(Event) not guarding against null values returned from Event.getItemId().",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-135",
        "summary": "extensibility patch for DavResourceImpl",
        "description": "attached is a very simple patch that allows subclasses of DavResourceImpl to access the Node represented by the dav resource.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1513",
        "summary": "RepositoryService.checkin should return information about newly created version",
        "description": "We have a mismatch between Node.checkin(), which returns a new Version object, and RepositoryService.checkin(), which returns void.\n\nClient of SPI, such as JCR2SPI, thus will have to make an additional request for the base version property, with the obvious drawbacks (another call, and a potential cause for a race condition).\n\nProposal: change the return code to NodeId.\n ",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-240",
        "summary": "redefinition of xml-namespace mapping should not be allowed",
        "description": "the following throws an exception, but should work:\n\n// remap xml namespace -> works\nSession.setNamespacePrefix(\"foobar\", \"http://www.w3.org/XML/1998/namespace\");\n\n// revert mapping -> throws exception\nSession.setNamespacePrefix(\"xml\", \"http://www.w3.org/XML/1998/namespace\");",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1495",
        "summary": "NamespaceAdder.addNamespace throws ClassCastException",
        "description": "Here's the method\n\npublic void addNamespaces(NamespaceMapping nsm)\n            throws NamespaceException, \nUnsupportedRepositoryOperationException, RepositoryException {\n        Map m = nsm.getPrefixToURIMapping();\n        for (Iterator i = m.values().iterator(); i.hasNext();) {\n            Map.Entry e = (Map.Entry) i.next();\n            String prefix = (String) e.getKey();\n            String uri = (String) e.getKey();\n            registry.registerNamespace(prefix, uri);\n        }\n    }\n\n\nshould be the entrySet iterator, and uri should come from the value, patch fixes this.\nOccurs in both spi-commons and jcr-commons (duplicate code)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-570",
        "summary": "Fix pom.xml in jackrabbit core (small fix, big return)",
        "description": "Change the following dependency in pom.xml to match what is really available at the maven repos:\nFROM:\n    <dependency>\n      <groupId>jsr170</groupId>\n      <artifactId>jcr</artifactId>\n      <version>1.0</version>\n    </dependency>\n\n\nTO:\n    <dependency>\n      <groupId>javax.jcr</groupId>\n      <artifactId>jcr</artifactId>\n      <version>1.0</version>\n    </dependency>\n",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-249",
        "summary": "Webdav: Review usage of command chains",
        "description": "i'd like to review the usage of command chains for import/export within the simple webdav server.\n\nwhile the concept of command chains offers a lot of flexibility, it showed that the implementation generates some drawbacks. a new mechanism should take advantage of the experiences made with the command chains.\n\nfrom my point of view the following issues should be taken into consideration:\n\n- provide means to extend and modify the import/export logic with minimal effort\n\n- consistent import/export functionality for both collections and non-collections\n  > export/import should not be completely separated.\n  > interfaces should encourage consistency\n  > increase maintainability, reduce no of errors\n\n- distinction of collections and non-collections for import/export behaviour\n  > PUT must result in non-coll, MKCOL in collection\n\n- allow to defined a set of import/export-handlers with a given order.\n\n- the different handlers must not rely on each other.\n\n- an import/export should be completed after the first handler indicates success. there \n  should not be other classes involved in order to complete the import/export.\n\n- avoid huge configuration files and if possible, avoid program flow being defined outside of java code.\n\n- avoid duplicate configuration (e.g. resource-filtering), duplicate code, duplicate logic, that is \n  hard to maintain.\n\n- additonal logic should be defined within a given import/export handler.\n  however, in case of webdav i see limited value of using extra logic such as addMixin or checkin, \n  that are covered by  webdav methods (such as LOCK, VERSION-CONTROL or CHECKIN).\n\nregards\nangela\n\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-358",
        "summary": "Add new top-level projects to the building documentation",
        "description": "The current building.xml file only mentions jackrabbit and contrib as being top level Jackrabbit projects. With the push towards 1.0, there are now several additional projects at the same level as jackrabbit and contrib. The building.xml page should be updated to mention and link to them. It should also provide a link into the subversion repository that is labeled as something like \"Current Jackrabbit project list\"; even though the link location is the same as the link to the repository, the label will help readers know that's where to look for the most up-to-date list of Jackrabbit projects.",
        "label": "NUG",
        "classified": "TASK",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-357",
        "summary": "Move to jackrabbit.apache.org",
        "description": "Jackrabbit will be moving to\n\n   http://jackrabbit.apache.org/\n\nThere are a number of infrastructure tasks that will need to be done by Roy.\n\nThere will also be a need to change our documentation and site to point to the new URL\nand mailing list addresses, which can be done by anyone.\n\nThe existing mailing lists will be moved\n\n    jackrabbit-dev at incubator  -->  dev at jackrabbit.apache.org\n    jackrabbit-commits at incubator  -->  commits at jackrabbit.apache.org\n\nand I will add\n\n   users at jackrabbit.apache.org\n",
        "label": "NUG",
        "classified": "TASK",
        "type": "TASK"
    },
    {
        "key": "JCR-1030",
        "summary": "Introduce QNodeTypeDefinition cache per userId",
        "description": "Once read from the server a QNodeTypeDefinition can be cached and shared across SessionImpl with the same userId.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-479",
        "summary": "incorrect definition of built-in node type nt:hierarchyNode",
        "description": "the property jcr:created of nt:hierarchyNode should be non-mandatory according to the specification (jcr 1.0 and jcr 1.0.1).\nboth the definition of the built-in node type and the related test case should be fixed accordingly.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1559",
        "summary": "Null Pointer Exception while looking for a DavProperty that hasn't been set",
        "description": "Null pointer exception.\nException occurs because the DavPropertySet.map does not contain an expected entry: ItemResourceConstants.JCR_NAME\n\nSuggested fix: add the constant to the nameSet in RepositoryServiceImpl.java:760\n nameSet.add(ItemResourceConstants.JCR_NAME);\n\nI tried that and it works. See stack trace at below.\n\nException in thread \"main\" java.lang.NullPointerException\n  at org.apache.jackrabbit.spi2dav.URIResolverImpl.buildPropertyId(URIResolverImpl.java:201)\n  at org.apache.jackrabbit.spi2dav.RepositoryServiceImpl.getNodeInfo(RepositoryServiceImpl.java:808)\n  at org.apache.jackrabbit.spi2dav.RepositoryServiceImpl.getItemInfos(RepositoryServiceImpl.java:834)\n  at org.apache.jackrabbit.jcr2spi.state.WorkspaceItemStateFactory.createNodeState(WorkspaceItemStateFactory.java:88)\n  at org.apache.jackrabbit.jcr2spi.state.TransientISFactory.createNodeState(TransientISFactory.java:99)\n  at org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntryImpl.doResolve(NodeEntryImpl.java:959)\n  at org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntryImpl.resolve(HierarchyEntryImpl.java:95)\n  at org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntryImpl.getItemState(HierarchyEntryImpl.java:212)\n  at org.apache.jackrabbit.jcr2spi.ItemManagerImpl.getItem(ItemManagerImpl.java:157)\n  at org.apache.jackrabbit.jcr2spi.SessionImpl.getRootNode(SessionImpl.java:225)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1460",
        "summary": "Typo in repository.xml",
        "description": "The extractorPoolSize parameter name has a trailing white space, which makes jackrabbit ignore it.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "BUG"
    },
    {
        "key": "JCR-2802",
        "summary": "Deprecate all non-bundle persistence managers",
        "description": "Bundle persistence has been the recommended default since Jackrabbit 1.3, and there is little reason for anyone to be using non-bundle persistence anymore. Thus I'd like to deprecate all non-bundle PMs in Jackrabbit 2.2 and target for their removal in Jackrabbit 3.0.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1190",
        "summary": "QValueFactory improvements",
        "description": "1) Allow all create methods to throw RepositoryException.\n\n2) Further document that create(value,type) can throw ValueFormatException.\n\n3) Remove special case create(File)\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2364",
        "summary": "NullPointerException when accessing the about.jsp page because of missing /META-INF/NOTICE.TXT",
        "description": "Accessing http://localhost:8080/about.jsp produces:\n\njava.lang.NullPointerException\n\tat org.apache.jsp.about_jsp.output(org.apache.jsp.about_jsp:39)\n\tat org.apache.jsp.about_jsp._jspService(org.apache.jsp.about_jsp:103)\n\tat org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:109)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:820)\n\tat org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:389)\n\tat org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:486)\n\tat org.apache.jasper.servlet.JspServlet.service(JspServlet.java:380)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:820)\n\tat org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:502)\n\tat org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:363)\n\tat org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)\n\tat org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)\n\tat org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:766)\n\tat org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:417)\n\tat org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)\n\tat org.mortbay.jetty.handler.RequestLogHandler.handle(RequestLogHandler.java:49)\n\tat org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)\n\tat org.mortbay.jetty.Server.handle(Server.java:324)\n\tat org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:534)\n\tat org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:864)\n\tat org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:533)\n\tat org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:207)\n\tat org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:403)\n\tat org.mortbay.jetty.bio.SocketConnector$Connection.run(SocketConnector.java:228)\n\tat org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:522)\n\nThis is because the jar misses the following file:\n/META-INF/NOTICE.TXT\nbut there is /NOTICE.TXT and /META-INF/NOTICE\n\nThis problem is not reproducible with jackrabbit-webapp-2.0-beta1.war.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1091",
        "summary": "more lenient behavior of Node#addMixin if mixin is already present ",
        "description": "Change implementation of addMixin() so that it doesn't fail when the mixin is already present.\n\nSee also:\n\njackrabbit core change: <http://svn.apache.org/viewvc?view=rev&revision=570149>\n\nJSR-283 issue: <https://jsr-283.dev.java.net/issues/show_bug.cgi?id=353>\n\n(this affects both the TCK and JCR2SPI, so I didn't specify a component)",
        "label": "NUG",
        "classified": "SPEC",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1389",
        "summary": "setProperty(\"name\", new Value[0], PropertyType.LONG) loses property type",
        "description": "Adding an empty multivalued property with a specific non-STRING type to an unstructured node (i.e. one with an UNDEFINED multivalued property definition) creates an empty multivalued property of type STRING.\n\nIn some cases keeping the explicit type information is important, so we should avoid losing it.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2419",
        "summary": "WorkspaceAccessManager defined with SecurityManager that keeps users per workspace must test if user exists",
        "description": "the WorkspaceAccessManager defined with the security manager keeping users per workspace currently returns true upon calls to grant(Set, String) if\na workspace with the given name exists.\n\nwhile this is fine for the initial check upon session creation, it obviously isn't for all method calls that test for accessible workspace names, such as\nWorkspace#getAccessibleWorkspaceName, Workspace#clone and copy across workspaces.\n\ninstead it should test if any of the specified principals corresponds to a valid user within the workspace identified by the given workspaceName.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1407",
        "summary": "[PATCH] Trivial Javadoc fix for RepositoryConfig",
        "description": "Yes, this is really trivial, but i keep coming to this class, trying to figure out it works, and the javadoc parms are scrambled.\n\npatch 'fixes' this.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-150",
        "summary": "Node.getLock() on a lock non-lockable node throws javax.jcr.UnsupportedRepositoryOperationException",
        "description": "Consider Node \"/test\" with mixin type mix:lockable and Node \"/test/child\" without mixin type mix:lockable.\n\n       Node root = Session.getRootNode();\n       Node test = root.getNode(\"test\");\n       Node child = test.getNode(\"child\");\n\n       // create lock on /test\n       test.lock();\n\n       // succeeds\n       Lock lock = test.getLock();\n\n       // sets flag true\n       boolean locked = child.isLocked();\n\n       // throws UnsupportedRepositoryOperationException\n       lock = child.getLock();\n\nAccording to the spec, the getLock() method must return the applicable lock if the node is locked regardless of whether the node has mixin type \"mix:lockable\" or not.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-58",
        "summary": "warning: unmappable character for encoding UTF8",
        "description": "There are a few non-ASCII characters in the Jackrabbit source files that cause warnings at least in my environment. It seems that all the warnings are caused by \"smart quote\" characters.\n\nThe exact warnings are: \n\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3068: warning: unmappable character for encoding UTF8\n            // &#65533;newer&#65533; than N and therefore N should be updated to reflect N'.\n               ^\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3068: warning: unmappable character for encoding UTF8\n            // &#65533;newer&#65533; than N and therefore N should be updated to reflect N'.\n                     ^\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3074: warning: unmappable character for encoding UTF8\n            // N' is &#65533;older&#65533; or the &#65533;same age&#65533; as N and therefore N should be left alone.\n                     ^\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3074: warning: unmappable character for encoding UTF8\n            // N' is &#65533;older&#65533; or the &#65533;same age&#65533; as N and therefore N should be left alone.\n                           ^\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3074: warning: unmappable character for encoding UTF8\n            // N' is &#65533;older&#65533; or the &#65533;same age&#65533; as N and therefore N should be left alone.\n                                    ^\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3074: warning: unmappable character for encoding UTF8\n            // N' is &#65533;older&#65533; or the &#65533;same age&#65533; as N and therefore N should be left alone.\n                                             ^\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3376: warning: unmappable character for encoding UTF8\n        // 2. N&#65533;s jcr:baseVersion property will be changed to point to V.\n               ^\n/home/hukka/workspace/Jackrabbit/src/java/org/apache/jackrabbit/core/NodeImpl.java:3382: warning: unmappable character for encoding UTF8\n        // 3. N&#65533;s jcr:isCheckedOut property is set to false.\n\n/home/hukka/workspace/Jackrabbit/src/test/org/apache/jackrabbit/test/api/version/CheckinTest.java:80: warning: unmappable character for encoding UTF8\n        assertEquals(\"The versionable checked-out node&#65533;s jcr:predecessors property is copied to the new version on checkin.\", Arrays.asList(nPredecessorsValue), Arrays.asList(vPredecessorsValue));\n                                                      ^\n/home/hukka/workspace/Jackrabbit/src/test/org/apache/jackrabbit/init/NodeTestData.java:95: warning: unmappable character for encoding UTF8\n        writer.write(\"Hello w&#65533;rld.\");\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1275",
        "summary": "NullPointerException in AbstractVersionManager.createVersionHistory()",
        "description": "Running ConcurrentCheckinMixedTransactionTest with 200 threads results in NullPointerExceptions in AbstractVersionManager.\n\nException in thread \"Thread-16\" java.lang.NullPointerException\n\tat org.apache.jackrabbit.core.version.AbstractVersionManager.createVersionHistory(AbstractVersionManager.java:309)\n\tat org.apache.jackrabbit.core.version.XAVersionManager.createVersionHistory(XAVersionManager.java:145)\n\tat org.apache.jackrabbit.core.ItemImpl.initVersionHistories(ItemImpl.java:785)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1221)\n\tat org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:897)\n\tat org.apache.jackrabbit.core.ConcurrentCheckinMixedTransactionTest$1$1.execute(ConcurrentCheckinMixedTransactionTest.java:66)\n\tat org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:110)\n\tat java.lang.Thread.run(Thread.java:619)\n\nI'm not sure why the node that is created by the current thread is not available. I assume that some other thread using XA transactions is committing changes while the current thread creates the node. The changes from the committing thread then overwrite the node that has been modified by the current thread. The write lock is somewhat bypassed in that case.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-806",
        "summary": "Scorer.skipTo() does not initialize hits",
        "description": "Some of the custom Scorer implementations in Jackrabbit do not initialize the internal hits BitSet if skipTo() is called before next().",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3149",
        "summary": "AccessControlProvider#getEffectivePolicies for a set of principals does not include repo-level ac",
        "description": "as of JCR-2774 the resource based ac implementation allows to edit permissions for repository level operations.\nhowever, ACLProvider#getEffectivePolicies(Set<Principal>, CompiledPermissions) does not include the repo level AC\nin the result set due to a missing test for regular acl OR repo-level acl.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-127",
        "summary": "Speedup Startup",
        "description": "jackrabbit startup gets slower the more items are in the repository.\n\npossible reasons:\n- versioning\n- search index",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "RFE"
    },
    {
        "key": "JCR-2159",
        "summary": "Several test cases fail when declaring nt:base / nt:hierarchy node types as 'abstract' ",
        "description": "JSR283 introduces a new node type attribute 'abstract' and defines nt:base and nt:hierarchyNode as such.\nwhen changing those nodetypes, the following test cases fail:\n\nFailed tests: \n  testDefinedAndLegalType(org.apache.jackrabbit.test.api.nodetype.CanAddChildNodeCallWithNodeTypeTest)\n  testResidualAndLegalType(org.apache.jackrabbit.test.api.nodetype.CanAddChildNodeCallWithNodeTypeTest)\n\nTests in error: \n  testAddNodeConstraintViolationExceptionUndefinedNodeType(org.apache.jackrabbit.test.api.NodeTest)\n  testRemoveMandatoryNode(org.apache.jackrabbit.test.api.NodeTest)\n  testCloneNodesConstraintViolationException(org.apache.jackrabbit.test.api.WorkspaceCloneTest)\n  testCopyNodesConstraintViolationException(org.apache.jackrabbit.test.api.WorkspaceCopyBetweenWorkspacesTest)\n  testCopyNodesConstraintViolationException(org.apache.jackrabbit.test.api.WorkspaceCopyTest)\n  testMoveNodesConstraintViolationException(org.apache.jackrabbit.test.api.WorkspaceMoveTest)\n  testNodeTypeConstraintViolationWorkspaceWithHandler(org.apache.jackrabbit.test.api.SerializationTest)\n  testNodeTypeConstraintViolationSessionWithHandler(org.apache.jackrabbit.test.api.SerializationTest)\n  testNodeTypeConstraintViolationWorkspace(org.apache.jackrabbit.test.api.SerializationTest)\n  testNodeTypeConstraintViolationSession(org.apache.jackrabbit.test.api.SerializationTest)\n  testJoinFilterPrimaryType(org.apache.jackrabbit.test.api.query.SQLJoinTest)\n  testElementTest(org.apache.jackrabbit.test.api.query.ElementTest)\n  testElementTestAnyNode(org.apache.jackrabbit.test.api.query.ElementTest)\n  testElementTestAnyNodeNtBase(org.apache.jackrabbit.test.api.query.ElementTest)\n  testElementTestAnyNodeSomeNT(org.apache.jackrabbit.test.api.query.ElementTest)\n  testElementTestNameTest(org.apache.jackrabbit.test.api.query.ElementTest)\n  testElementTestNameTestNtBase(org.apache.jackrabbit.test.api.query.ElementTest)\n  testElementTestNameTestSomeNT(org.apache.jackrabbit.test.api.query.ElementTest)\n  testElementTestNameTestSomeNTWithSNS(org.apache.jackrabbit.test.api.query.ElementTest)\n  testNodeType(org.apache.jackrabbit.test.api.observation.AddEventListenerTest)\n\n\nhere's a stacktrace of a failing test:\n\njavax.jcr.nodetype.ConstraintViolationException: nt:hierarchyNode: is an abstract node type.\n        at org.apache.jackrabbit.core.NodeImpl.internalAddChildNode(NodeImpl.java:768)\n        at org.apache.jackrabbit.core.NodeImpl.internalAddNode(NodeImpl.java:737)\n        at org.apache.jackrabbit.core.NodeImpl.internalAddNode(NodeImpl.java:691)\n        at org.apache.jackrabbit.core.NodeImpl.addNode(NodeImpl.java:2147)\n        at org.apache.jackrabbit.test.api.SessionTest.testMoveItemExistsException(SessionTest.java:69)\n\n\nthe failing tests are actually a backwards compatibility issue. nt:base and nt:hierarchyNode were\nnon-abstract in JCR 1.0, i.e. \n\n     node.addNode(\"foo\", \"nt:base\");\n\nwas perfectly legal.\n\nhowever, as of JCR 2.0, above statement fails. all above mentioned tests fail because they \ncreate nodes of type nt:base or nt:hierarchyNode.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1859",
        "summary": "BeanLazyLoader is not Serializable",
        "description": "Class org.apache.jackrabbit.ocm.manager.objectconverter.impl.BeanLazyLoader is not serializable.\nIn ocm module we can mark some property to be lazy loaded. For example @Bean(..., proxy=true)\nIn such scenario instead of object we will have here proxy BeanLazyLoader which is not serializable.\n\nIt is problematic while using another technologies. \nFor example Spring WebFlow requires objects (model) stored in scope to be Serializable.\nSo when we use proxied model with Spring WebFlow we received exception \"org.springframework.webflow.execution.repository.snapshot.SnapshotCreationException: Could not serialize flow execution; make sure all objects stored in flow or flash scope are serializable.... Caused by: java.io.NotSerializableException: org.apache.jackrabbit.ocm.manager.objectconverter.impl.BeanLazyLoader\n...\"\n\nPlease make BeanLazyLoader Serializable.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1817",
        "summary": "Core: Misleading method naming with Workspace and Session (move283, copy283, clone283)",
        "description": "there seems to be leftovers from previous drafts of the jsr 283 within jackrabbit core, namely:\n\n- WorkspaceImpl#clone283\n- WorkspaceImpl#copy283\n- WorkspaceImpl#move283\n- SessionImpl#move283\n\ngiving the impression that with jsr 283 those method would return 'String'. this however is not the case.\ntherefore i suggest to remove those methods again.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "BUG"
    },
    {
        "key": "JCR-3191",
        "summary": "Update commons-io dependency from versiom 1.4 to 2.0.1 ",
        "description": "Jackrabbit may be used as JackRabbit-JCA. In many application servers we need to change the classloading policy to \"global\" or \"flat\". These classloading policies result in many conflicts between versions of own server implementation or version of applications. It would be diminished if Jackrabbit dependences are keep \"up-to-date\".\n\n<dependency>\n\t<groupId>commons-io</groupId>\n\t<artifactId>commons-io</artifactId>\n\t<version>2.0.1</version>\n</dependency>",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": ""
    },
    {
        "key": "JCR-2138",
        "summary": "Prevent persistence of faulty back-references",
        "description": "The SharedItemStateManager updates reference data. Sometimes the back-references to reference properties are not updated correctly with the result that nodes cannot removed anymore. The attached patch contains JUnit test cases and a possible solution.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-190",
        "summary": "Caching in QueryHandler does not scale well",
        "description": "Caching in class CachingIndexReader uses too much memory. It uses around 500 bytes per node and does not use any strategy to limit the cache.\n\nThis improvement covers two goals:\n- lower per-node memory cost for caching\n- implement a caching strategy using e.g LRU algorithm",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-848",
        "summary": "javacc-maven-plugin version in jackrabbit-core pom file",
        "description": "Hi, I noticed that the pom.xml file of the jackrabbit-core project needs to specify version \"2.1\" for the javacc-maven-plugin because if it takes the 2.2-SNAPSHOT it won't compile. I put the 2.1 version and it worked fine.\n\n<plugin>\n        <groupId>org.codehaus.mojo</groupId>\n        <artifactId>javacc-maven-plugin</artifactId>\n        <version>2.1</version>\n        <executions>\n\n\nIm working with revision 529712 [April 17, 2007, 15:05 EST]",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-1001",
        "summary": "SPI: prefer 'Iterator' instead of specialized subclasses",
        "description": "in the F2F we agreed that the SPI should rather use 'Iterator' instead of specialized subclassed (or RangeIterator).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2693",
        "summary": "Logging per test case",
        "description": "Thanks to the switch to Logback a while ago (JCR-2584) we can start taking advantage of some nice new features like the one described in [1]. With this trick we'll be able to split the currently pretty large jcr.log test log file we have to separate log files per each test case. This will make it much easier to review the logs written during any particular test.\n\n[1] http://www.nalinmakar.com/2010/07/28/logging-tests-to-separate-files/",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-800",
        "summary": "Child Axis support in order by clause",
        "description": "Hi, \n\nsince child axis is supported in XPath predicates, it would be nice to support it in order by clause as well\n\nQueries of type\n\n//element(*, type) [ foo/@bar ]  order by foo/@bar asc\n\ncan become very useful\n\nBR, \n\nSavvas",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1846",
        "summary": "Jackrabbit thread contention issue due to fat lock",
        "description": "Hello,\n\nWe are running jackrabbit 1.4.5 using a persistent file data store within a weblogic container and encountering a variety of thread locking issues. To get around the problem, we are forced synchronize thread access to the JCR repository or reduce thread worker count to 1 which has a heavy performance impact on our application. I'm not exactly sure what the problem is and was wondering someone is looking into this issue and if there is a workaround/fix planned?\n\n<Oct 30, 2008 10:45:32 AM PDT> <Error> <WebLogicServer> <BEA-000337> <[STUCK] ExecuteThread: '5' for queue: 'weblogic.kernel.Default (self-tuning)' has been busy for \"1,863\" seconds working on the request \"weblogic.work.j2ee.J2EEWorkManager$WorkWithListener@2117cc9\", which is more than the configured time (StuckThreadMaxTime) of \"1,800\" seconds. Stack trace:\nThread-94 \"[STUCK] ExecuteThread: '5' for queue: 'weblogic.kernel.Default (self-tuning)'\" <alive, in native, suspended, waiting, priority=1, DAEMON> {\n    -- Waiting for notification on: EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock@152c384[fat lock]\n    java.lang.Object.wait(Object.java:???)\n    java.lang.Object.wait(Object.java:474)\n    EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source)\n    org.apache.jackrabbit.core.journal.AbstractJournal.lockAndSync(AbstractJournal.java:235)\n    org.apache.jackrabbit.core.journal.DefaultRecordProducer.append(DefaultRecordProducer.java:49)\n\n}\n\n>\n<Oct 30, 2008 10:45:32 AM PDT> <Error> <WebLogicServer> <BEA-000337> <[STUCK] ExecuteThread: '2' for queue: 'weblogic.kernel.Default (self-tuning)' has been busy for \"1,916\" seconds working on the request \"weblogic.work.j2ee.J2EEWorkManager$WorkWithListener@227b6d4\", which is more than the configured time (StuckThreadMaxTime) of \"1,800\" seconds. Stack trace:\nThread-25 \"[STUCK] ExecuteThread: '2' for queue: 'weblogic.kernel.Default (self-tuning)'\" <alive, in native, suspended, waiting, priority=1, DAEMON> {\n    -- Waiting for notification on: EDU.oswego.cs.dl.util.concurrent.LinkedNode@42d58e0[fat lock]\n    java.lang.Object.wait(Object.java:???)\n    java.lang.Object.wait(Object.java:474)\n    EDU.oswego.cs.dl.util.concurrent.SynchronousChannel.put(Unknown Source)\n    EDU.oswego.cs.dl.util.concurrent.PooledExecutor$WaitWhenBlocked.blockedAction(Unknown Source)\n    EDU.oswego.cs.dl.util.concurrent.PooledExecutor.execute(Unknown Source)\n...\n    org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:334)\n    org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:307)\n    org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:317)\n    org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1072)\n    ^-- Holding lock: org.apache.jackrabbit.core.query.lucene.VolatileIndex@3eb0f41[thin lock]\n    org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:895)\n    org.apache.jackrabbit.jca.JCASessionHandle.save(JCASessionHandle.java:178)\n    com.qpass.inventory.ingestion.IngestionServiceImpl$1.doInJCR(IngestionServiceImpl.java:124)\n    com.qpass.inventory.model.JCRTemplate.execute(JCRTemplate.java:17)\n    com.qpass.inventory.ingestion.IngestionServiceImpl.ingestProduct(IngestionServiceImpl.java:93)\n    com.qpass.inventory.ingestion.bulk.AbstractBulkIngester.ingestProduct(AbstractBulkIngester.java:42)\n    com.qpass.inventory.ingestion.bulk.ZipFileBulkIngester.processFile(ZipFileBulkIngester.java:35)\n    com.qpass.inventory.ingestion.bulk.IngestionWorker.processFile(IngestionWorker.java:26)\n    com.qpass.inventory.ingestion.bulk.IngestionWorker$1.run(IngestionWorker.java:64)\n    org.springframework.scheduling.commonj.DelegatingWork.run(DelegatingWork.java:61)\n    weblogic.work.j2ee.J2EEWorkManager$WorkWithListener.run(J2EEWorkManager.java:245)\n    weblogic.work.ExecuteThread.execute(ExecuteThread.java:206)\n    weblogic.work.ExecuteThread.run(ExecuteThread.java:173)\n}\n\n>\n<Oct 30, 2008 10:45:32 AM PDT> <Error> <WebLogicServer> <BEA-000337> <[STUCK] ExecuteThread: '1' for queue: 'weblogic.kernel.Default (self-tuning)' has been busy for \"1,891\" seconds working on the request \"weblogic.work.j2ee.J2EEWorkManager$WorkWithListener@2117c83\", which is more than the configured time (StuckThreadMaxTime) of \"1,800\" seconds. Stack trace:\nThread-24 \"[STUCK] ExecuteThread: '1' for queue: 'weblogic.kernel.Default (self-tuning)'\" <alive, in native, suspended, waiting, priority=1, DAEMON> {\n    -- Waiting for notification on: EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock@152c384[fat lock]\n    java.lang.Object.wait(Object.java:???)\n    java.lang.Object.wait(Object.java:474)\n    EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source)\n    org.apache.jackrabbit.core.journal.AbstractJournal.lockAndSync(AbstractJournal.java:235)\n    org.apache.jackrabbit.core.journal.DefaultRecordProducer.append(DefaultRecordProducer.java:49)\n    org.apache.jackrabbit.core.cluster.ClusterNode$WorkspaceUpdateChannel.updateCreated(ClusterNode.java:556)\n...\n\n\n<Oct 30, 2008 11:21:30 AM PDT> <Warning> <netuix> <BEA-423420> <Redirect is executed in begin or refresh action. Redirect url is /console/console.portal?_nfpb=true&_pageLabel=HomePage1.>\n<Oct 30, 2008 11:44:32 AM PDT> <Error> <WebLogicServer> <BEA-000337> <[STUCK] ExecuteThread: '4' for queue: 'weblogic.kernel.Default (self-tuning)' has been busy for \"1,803\" seconds working on the request \"Http Request: /inventory/rpc/searchService\", which is more than the configured time (StuckThreadMaxTime) of \"1,800\" seconds. Stack trace:\nThread-51 \"[STUCK] ExecuteThread: '4' for queue: 'weblogic.kernel.Default (self-tuning)'\" <alive, in native, suspended, waiting, priority=1, DAEMON> {\n    -- Waiting for notification on: java.lang.Object@1569e04[fat lock]\n    java.lang.Object.wait(Object.java:???)\n    java.lang.Object.wait(Object.java:474)\n    org.apache.jackrabbit.core.query.lucene.MultiIndex.getIndexReader(MultiIndex.java:694)\n    org.apache.jackrabbit.core.query.lucene.SearchIndex.getIndexReader(SearchIndex.java:825)\n    org.apache.jackrabbit.core.query.lucene.SearchIndex.executeQuery(SearchIndex.java:682)\n    org.apache.jackrabbit.core.query.lucene.QueryResultImpl.executeQuery(QueryResultImpl.java:242)\n    org.apache.jackrabbit.core.query.lucene.QueryResultImpl.getResults(QueryResultImpl.java:271)\n    org.apache.jackrabbit.core.query.lucene.QueryResultImpl.<init>(QueryResultImpl.java:177)\n    org.apache.jackrabbit.core.query.lucene.QueryImpl.execute(QueryImpl.java:105)\n    org.apache.jackrabbit.core.query.QueryImpl.execute(QueryImpl.java:174)\n    com.qpass.inventory.service.QueryProfiler.execute(QueryProfiler.java:20)\n    com.qpass.inventory.service.SearchServiceImpl$1.doInJCR(SearchServiceImpl.java:59)\n    com.qpass.inventory.model.JCRTemplate.execute(JCRTemplate.java:17)\n    com.qpass.inventory.service.SearchServiceImpl.doSearch(SearchServiceImpl.java:54)\n    com.qpass.inventory.ui.impl.SearchUIServiceImpl.search(SearchUIServiceImpl.java:48)\n    sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:???)\n    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:27)\n    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    java.lang.reflect.Method.invoke(Method.java:570)\n    org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:309)\n    org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:148)\n    org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor.invoke(MethodSecurityInterceptor.java:62)\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:148)\n    org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:151)\n    $Proxy74.search(Unknown Source)\n    sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:???)\n    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:27)\n    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    java.lang.reflect.Method.invoke(Method.java:570)\n    org.gwtwidgets.server.spring.GWTRPCServiceExporter.invokeMethodOnService(GWTRPCServiceExporter.java:157)\n    org.gwtwidgets.server.spring.GWTRPCServiceExporter.processCall(GWTRPCServiceExporter.java:295)\n    com.google.gwt.user.server.rpc.RemoteServiceServlet.doPost(RemoteServiceServlet.java:173)\n    org.gwtwidgets.server.spring.GWTRPCServiceExporter.handleRequest(GWTRPCServiceExporter.java:361)\n    com.qpass.base.ui.security.GWTServiceExporter.handleRequest(GWTServiceExporter.java:45)\n    org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter.handle(HttpRequestHandlerAdapter.java:49)\n    org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:831)\n    org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:781)\n    org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:567)\n    org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:511)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:736)\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:851)\n    weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:224)\n    weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:108)\n    weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:198)\n    weblogic.servlet.internal.TailFilter.doFilter(TailFilter.java:26)\n    weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:41)\n    org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:259)\n    org.acegisecurity.intercept.web.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:93)\n    org.acegisecurity.intercept.web.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:71)\n    org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:259)\n    com.qpass.usersecurity.auth.UpdatePermissionsOnContextChangeFilter.doFilter(UpdatePermissionsOnContextChangeFilter.java:44)\n    org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:259)\n    org.acegisecurity.ui.AbstractProcessingFilter.doFilter(AbstractProcessingFilter.java:191)\n    org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:259)\n    org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:195)\n    org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:259)\n    org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:122)\n    org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:236)\n    org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:154)\n    weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:41)\n    com.qpass.base.applicationcontext.RequestContextFilter.doFilter(RequestContextFilter.java:103)\n    org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:236)\n    org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:154)\n    weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:41)\n    org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:90)\n    org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:61)\n    weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:41)\n    weblogic.servlet.internal.RequestEventsFilter.doFilter(RequestEventsFilter.java:24)\n    weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:41)\n    weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3214)\n    weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:308)\n    weblogic.security.service.SecurityManager.runAs(SecurityManager.java:117)\n    weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:1946)\n    weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:1868)\n    weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1331)\n    weblogic.work.ExecuteThread.execute(ExecuteThread.java:206)\n    weblogic.work.ExecuteThread.run(ExecuteThread.java:173)\n}\n\n\n\n\n<Oct 2, 2008 2:09:36 PM PDT> <Error> <WebLogicServer> <BEA-000337> <[STUCK] ExecuteThread: '1' for queue: 'weblogic.kernel.Default (self-tuning)' has been busy for \"696\" seconds working on the request \"weblogic.work.j2ee.J2EEWorkManager$WorkWithListener@863e564\", which is more than the configured time (StuckThreadMaxTime) of \"600\" seconds. Stack trace:\nThread-21 \"[STUCK] ExecuteThread: '1' for queue: 'weblogic.kernel.Default (self-tuning)'\" <alive, in native, suspended, priority=1, DAEMON> {\n    java.io.FileOutputStream.writeBytes(FileOutputStream.java:???)\n    java.io.FileOutputStream.write(FileOutputStream.java:260)\n    java.io.BufferedOutputStream.write(BufferedOutputStream.java:100)\n    ^-- Holding lock: java.io.BufferedOutputStream@39d70a5[thin lock]\n    org.apache.jackrabbit.core.persistence.util.FileSystemBLOBStore.put(FileSystemBLOBStore.java:88)\n    org.apache.jackrabbit.core.persistence.bundle.util.BundleBinding.writeState(BundleBinding.java:561)\n    org.apache.jackrabbit.core.persistence.bundle.util.BundleBinding.writeBundle(BundleBinding.java:245)\n    org.apache.jackrabbit.core.persistence.bundle.Oracle9PersistenceManager.storeBundle(Oracle9PersistenceManager.java:114)\n    ^-- Holding lock: org.apache.jackrabbit.core.persistence.bundle.Oracle9PersistenceManager@140f7b9[thin lock]\n    org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.putBundle(AbstractBundlePersistenceManager.java:703)\n    org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.store(AbstractBundlePersistenceManager.java:526)\n    ^-- Holding lock: org.apache.jackrabbit.core.persistence.bundle.Oracle9PersistenceManager@140f7b9[thin lock]\n    org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.store(BundleDbPersistenceManager.java:517)\n    ^-- Holding lock: org.apache.jackrabbit.core.persistence.bundle.Oracle9PersistenceManager@140f7b9[thin lock]\n    org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:699)\n    org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:873)\n    org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:334)\n    org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:334)\n    org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:307)\n    org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:317)\n    org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1072)\n    ^-- Holding lock: org.apache.jackrabbit.core.XASessionImpl@1f2653b[thin lock]\n    org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:895)\n    org.apache.jackrabbit.jca.JCASessionHandle.save(JCASessionHandle.java:178)\n    com.qpass.inventory.ingestion.IngestionServiceImpl$1.doInJCR(IngestionServiceImpl.java:140)\n    com.qpass.inventory.model.JCRTemplate.execute(JCRTemplate.java:17)\n    com.qpass.inventory.ingestion.IngestionServiceImpl.ingestProduct(IngestionServiceImpl.java:112)\n    ^-- Holding lock: java.lang.Object@849ca9e[fat lock]\n    com.qpass.inventory.ingestion.bulk.AbstractBulkIngester.ingestProduct(AbstractBulkIngester.java:42)\n    com.qpass.inventory.ingestion.bulk.ZipFileBulkIngester.processFile(ZipFileBulkIngester.java:35)\n    com.qpass.inventory.ingestion.bulk.IngestionWorker.processFile(IngestionWorker.java:26)\n    com.qpass.inventory.ingestion.bulk.IngestionWorker$1.run(IngestionWorker.java:64)\n    org.springframework.scheduling.commonj.DelegatingWork.run(DelegatingWork.java:61)\n    weblogic.work.j2ee.J2EEWorkManager$WorkWithListener.run(J2EEWorkManager.java:245)\n    weblogic.work.ExecuteThread.execute(ExecuteThread.java:206)\n    weblogic.work.ExecuteThread.run(ExecuteThread.java:173)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-605",
        "summary": "Error when registering node types on virgin repository",
        "description": "When a node type is registered on a repository that has never been started before an error is written to the log:\n\n26.10.2006 10:36:02 *ERROR* [main] VirtualNodeTypeStateManager: Unable to index new nodetype: javax.jcr.ItemNotFoundException (VirtualNodeTypeStateManager.java, line 159)\n\nSteps to reproduce:\n\n> maven test:clean\n> cp applications/test/repository/namespaces/ns_re.properties.install applications/test/repository/namespaces/ns_re.properties\n> cp applications/test/repository/nodetypes/custom_nodetypes.xml.install applications/test/repository/nodetypes/custom_nodetypes.xml\n\nRun test case o.a.j.init.NodeTypeData\n\nIt seems that the workspace initialization creates node states for jcr:system and a child node jcr:nodeTypes. The latter however is overlayed by a virtual node state provided by the VirtualNodeTypeStateProvider.\n\nIn case of an initial startup, the jcr:nodeTypes node is cached on creation and is not overlayed by the virtual twin from the VirtualNodeTypeStateProvider.\n\nIMO the jcr:nodeTypes node state shouldn't have been created in the first place because it is overlayed anyway. The workspace initialization routine should only create a child node entry in the jcr:system node state but no actual child node state for that entry.\n\nOpinions?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1881",
        "summary": "RTF text extractor fails on Java 1.4 in some environments",
        "description": "I've seen the RTF text extractor fail with the following errors with Java 1.4 on Unix platforms. Both are platform issues, but Jackrabbit should be prepared for such cases and for example just log a warning and return an empty text stream when encountering these errors.\n\njava.lang.UnsatisfiedLinkError: /home/jukka/bin/java/j2sdk1.4.2_18/jre/lib/i386/libawt.so: libXp.so.6: cannot open shared object file: No such file or directory\n        at java.lang.ClassLoader$NativeLibrary.load(Native Method)\n        at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1586)\n        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1503)\n        at java.lang.Runtime.loadLibrary0(Runtime.java:788)\n        at java.lang.System.loadLibrary(System.java:834)\n        at sun.security.action.LoadLibraryAction.run(LoadLibraryAction.java:50)\n        at java.security.AccessController.doPrivileged(Native Method)\n        at sun.awt.NativeLibLoader.loadLibraries(NativeLibLoader.java:38)\n        at sun.awt.DebugHelper.<clinit>(DebugHelper.java:29)\n        at java.awt.EventQueue.<clinit>(EventQueue.java:83)\n        at javax.swing.SwingUtilities.isEventDispatchThread(SwingUtilities.java:1238)\n        at javax.swing.text.StyleContext.reclaim(StyleContext.java:419)\n        at javax.swing.text.StyleContext.addAttribute(StyleContext.java:276)\n        at javax.swing.text.StyleContext$NamedStyle.addAttribute(StyleContext.java:1468)\n        at javax.swing.text.StyleContext$NamedStyle.setName(StyleContext.java:1278)\n        at javax.swing.text.StyleContext$NamedStyle.<init>(StyleContext.java:1226)\n        at javax.swing.text.StyleContext.addStyle(StyleContext.java:88)\n        at javax.swing.text.StyleContext.<init>(StyleContext.java:68)\n        at javax.swing.text.DefaultStyledDocument.<init>(DefaultStyledDocument.java:88)\n        at org.apache.jackrabbit.extractor.RTFTextExtractor.extractText(RTFTextExtractor.java:60)\n        at org.apache.jackrabbit.extractor.RTFTextExtractorTest.testExtractor(RTFTextExtractorTest.java:35)\n\njava.lang.InternalError: Can't connect to X11 window server using ':0.0' as the value of the DISPLAY variable.\n\tat sun.awt.X11GraphicsEnvironment.initDisplay(Native Method)\n\tat sun.awt.X11GraphicsEnvironment.<clinit>(X11GraphicsEnvironment.java:134)\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:141)\n\tat java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment(GraphicsEnvironment.java:62)\n\tat sun.awt.motif.MToolkit.<clinit>(MToolkit.java:81)\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:141)\n\tat java.awt.Toolkit$2.run(Toolkit.java:748)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.awt.Toolkit.getDefaultToolkit(Toolkit.java:739)\n\tat java.awt.Toolkit.getEventQueue(Toolkit.java:1519)\n\tat java.awt.EventQueue.isDispatchThread(EventQueue.java:676)\n\tat javax.swing.SwingUtilities.isEventDispatchThread(SwingUtilities.java:1238)\n\tat javax.swing.text.StyleContext.reclaim(StyleContext.java:419)\n\tat javax.swing.text.StyleContext.addAttribute(StyleContext.java:276)\n\tat javax.swing.text.StyleContext$NamedStyle.addAttribute(StyleContext.java:1468)\n\tat javax.swing.text.StyleContext$NamedStyle.setName(StyleContext.java:1278)\n\tat javax.swing.text.StyleContext$NamedStyle.<init>(StyleContext.java:1226)\n\tat javax.swing.text.StyleContext.addStyle(StyleContext.java:88)\n\tat javax.swing.text.StyleContext.<init>(StyleContext.java:68)\n\tat javax.swing.text.DefaultStyledDocument.<init>(DefaultStyledDocument.java:88)\n\tat org.apache.jackrabbit.extractor.RTFTextExtractor.extractText(RTFTextExtractor.java:60)\n\tat org.apache.jackrabbit.extractor.RTFTextExtractorTest.testExtractor(RTFTextExtractorTest.java:35)\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2405",
        "summary": "repository-2.0.dtd missing",
        "description": "We introduced new configuration elements that need to be reflected in a new DTD version.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1936",
        "summary": "Incorrect license headers in multiple components",
        "description": "As noticed by Thomas, we have a number of files with missing or incorrect license headers both in trunk and in the 1.5 branch.\n\nThe following lists all troublesome files in the 1.5.1 release candidate:\n\n !????? ./jackrabbit-api/src/main/java/org/apache/jackrabbit/api/security/user/User.java\n !????? ./jackrabbit-core/src/main/java/org/apache/jackrabbit/core/security/authorization/principalbased/ACLEditor.java\n !????? ./jackrabbit-core/src/main/java/org/apache/jackrabbit/core/security/authorization/principalbased/ACLProvider.java\n !????? ./jackrabbit-core/src/test/java/org/apache/jackrabbit/api/jsr283/retention/AbstractRetentionTest.java\n !????? ./jackrabbit-core/src/test/java/org/apache/jackrabbit/core/security/authorization/combined/TestAll.java\n !????? ./jackrabbit-core/src/test/java/org/apache/jackrabbit/core/security/authorization/principalbased/EvaluationTest.java\n !????? ./jackrabbit-core/src/test/java/org/apache/jackrabbit/core/security/authorization/principalbased/TestAll.java\n !????? ./jackrabbit-core/src/test/java/org/apache/jackrabbit/core/security/principal/TestAll.java\n !????? ./jackrabbit-core/src/test/java/org/apache/jackrabbit/core/security/user/AdministratorTest.java\n !????? ./jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/manager/objectconverter/impl/AbstractLazyLoader.java\n !????? ./jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/manager/objectconverter/impl/OcmProxy.java\n !????? ./jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/manager/objectconverter/impl/OcmProxyUtils.java\n !????? ./jackrabbit-ocm/src/test/java/org/apache/jackrabbit/ocm/testmodel/MultiValueWithObjectCollection.java\n !????? ./jackrabbit-ocm/src/test/java/org/apache/jackrabbit/ocm/testmodel/SimpleAnnotedAbstractClass.java\n !????? ./jackrabbit-ocm/src/test/java/org/apache/jackrabbit/ocm/testmodel/SimpleAnnotedClass.java\n !????? ./jackrabbit-ocm/src/test/java/org/apache/jackrabbit/ocm/testmodel/SimpleInterface.java\n !????? ./jackrabbit-ocm/src/test/java/org/apache/jackrabbit/ocm/testmodel/UnmappedInterface.java\n !????? ./jackrabbit-ocm/src/test/java/org/apache/jackrabbit/ocm/testmodel/version/Author.java\n !????? ./jackrabbit-ocm/src/test/java/org/apache/jackrabbit/ocm/testmodel/version/PressRelease.java\n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-163",
        "summary": "Maven build failure in textfilter contrib project",
        "description": "I've tried to build the textfilters contrib but get the following error:\n\nAttempting to download jackrabbit-0.16.4.1-dev.jar.\nWARNING: Failed to download jackrabbit-0.16.4.1-dev.jar.\nThe build cannot continue because of the following unsatisfied dependency:\njackrabbit-0.16.4.1-dev.jar\n\nI tried changing the project.xml to look for jackrabbit-1.0-dev.jar instead, but it didn't work, not sure what maven expects here, but should be an easy fix for somebody in the know.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-2418",
        "summary": "Read permission on parent node required to access an item's definition",
        "description": "If a session is granted all permissions on a given item B but lacks permission to read it's parent node A an attempt to\naccess the definition of B by means of Node.getDefinition or Property.getDefinition will fail with AccessDeniedException.\n\nSimilarly, the same session will not be able to modify that item B - e.g. add a child node in case it was a node - since implementation e.g. checks of that\nitem B isn't protected, which is determined by looking at the definition.\n\nMy feeling is, that the item definition should be accessible even if the parent node cannot be read.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-974",
        "summary": "Manage Lucene FieldCaches per index segment",
        "description": "Jackrabbit uses an IndexSearcher which searches on a single IndexReader which is most likely to be an instance of CachingMultiReader. On every search that does sorting or range queries a FieldCache is populated and associated with this instance of a CachingMultiReader. On successive queries which operate on this CachingMultiReader you will get a tremendous speedup for queries which can reuse  those associated FieldCache instances.\nThe problem is that Jackrabbit creates a new CachingMultiReader _everytime_ one of the underlying indexes are modified. This means if you just change _one_ item in the repository you will need to rebuild all those FieldCaches because the existing FieldCaches are associated with the old instance of CachingMultiReader.\nThis does not only lead to slow search response times for queries which contains range queries or are sorted by a field but also leads to massive memory consumption (depending on the size of your indexes) because there might be multiple instances of CachingMultiReaders in use if you have a scenario where a lot of queries and item modifications are executed concurrently.\nThe goal is to keep those FieldCaches as long as possible.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2437",
        "summary": "Upgrade to easymock 2.5.2",
        "description": "Currently we have a dependency on easymock:easymock:1.1 in the jackrabbit-parent pom's dependency management section. This dependency is not actually used, but I am planning to start using it soon in the core. Upgrading it to 2.5.2 would give us generics support and a lot of improvements and bug fixes.\n\nNote that the upgrade changes the groupId of the dependency.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-332",
        "summary": "Upgrade to Maven 2",
        "description": "If you are interested in migrating to maven2 (or adding optional maven 2 build scripts) this is a full maven 2 pom.xml for the main jackrabbit jar.\n\nAll the xpath/javacc stuff, previously done in maven.xml, was pretty painfull to reproduce in maven2... the attached pom exactly reproduces the m1 build by using the maven2 javacc plugin + a couple of antrun executions.\nTest configuration is not yet complete, I think it will be a lot better to reproduce the previous behaviour (init tests run first) without any customization (maybe using a single junit test suite with setUp tasks). Also custom packaging goals added to maven.xml (that can be esily done in m2 by using the assembly plugin) are not yet reproduced too.\n\nIf there is interest, I can also provide poms for the contribution projects (that will be easy, the only complex pom is the main one).\n",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "RFE"
    },
    {
        "key": "JCR-949",
        "summary": "PostgreSQL support in clustering module",
        "description": "There is no ddl file for PostgreSQL in clustering module, so I'm attaching here the one we are using in our project. Hope it helps.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1179",
        "summary": "Event filtering by path not working as specified",
        "description": "When filtering node events by path, the event filter doesn't compare using the \"associated parent path\", see JSR-170, 8.3.3:\n\n\"The set of events can be filtered by specifying restrictions based on characteristics of the associated parent node of the event. The associated parent node of an event is the parent node of the item at (or formerly at) the path returned by Event.getPath. The following restrictions are available:\n\n\u2022 absPath, isDeep: Only events whose associated parent node is at absPath (or within its subtree, if isDeep is true) will be received. It is permissible to register a listener for a path where no node currently exists.\"\n\n(for property events, filtering is correct)\n\nTo fix this, the special handling of node events in EventFilter.blocks() simply needs to be removed.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2759",
        "summary": "Collapse nested OR expressions",
        "description": "Executing a query with multiple OR expressions in a predicate leads to score values that depend on the order of the operands.\n\nFor example, the following query:\n\n//*[jcr:contains(@prop1, 'foo') or jcr:contains(@prop2, 'foo') or jcr:contains(@prop3, 'foo')] order by @jcr:score descending\n\nwill return a slightly different result compared to:\n\n//*[jcr:contains(@prop3, 'foo') or jcr:contains(@prop1, 'foo') or jcr:contains(@prop2, 'foo')] order by @jcr:score descending\n\nInternally jackrabbit parses the predicate of the first query into a tree:\n\norExpr(orExpr(contains(prop1, 'foo'), contains(prop2, 'foo')), contains(prop3, 'foo'))\n\nLucene will calculate the score for the inner OR expression first and then for the outer, which is not equivalent with a nested expression that has property names in a different sequence.\n\nThe query should be translated internally into a single OR expression with three operands. That way, the score value is always the same, irrespective of the order of the operands.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1233",
        "summary": "Create org.apache.jackrabbit.core.id",
        "description": "I'd like to create a separate package for the identifier interfaces and classes in jackrabbit-core. Currently all the identifiers are in org.apache.jackrabbit.core, which makes almost all the other packages have dependencies to o.a.j.core and causes trouble for various package-level code quality and dependency analysis tools.\n\nFor now the package would contain the ItemId, NodeId, and PropertyId classes.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1767",
        "summary": "XML serialization in JDK 1.4 broken (mostly for WebDAV)",
        "description": "WebDAV uses XmlRequestEntity for serializing XML, which in turn uses org.apache.jackrabbit.commons.xml.SerializingContentHandler to work around the JDK 1.4 problem (serializing in absence of explicit namespace declarations).\n\nThe following test fails under JDK 1.4, but passed with newer JDKs:\n\n    public void testXmlSerialization() throws ParserConfigurationException, IOException, SAXException {\n        \n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        \n        Document doc = db.newDocument();\n        doc.appendChild(doc.createElementNS(\"DAV:\", \"propfind\"));\n        \n        XmlRequestEntity xmlent = new XmlRequestEntity(doc);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        xmlent.writeRequest(bos);\n        \n        Document doc2 = db.parse(new ByteArrayInputStream(bos.toByteArray()));\n        Element docelem = doc2.getDocumentElement();\n        assertEquals(\"DAV:\", docelem.getNamespaceURI());\n    }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2048",
        "summary": "Workspace is shut down while creating initial index",
        "description": "This only happens when a maxIdleTime is configured for the workspaces in the repository.xml and the workspace to index is not the default workspace.\n\nThe idle check considers a workspace as idle when there only a system session is open and the configured idle time elapsed. This is also the case when the workspace is initializing.\n\nThe repository should either check if a workspace is still initializing or we need to move the search manager initialization into the WorkspaceInfo.doInitialize() method.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2648",
        "summary": "PropertyImpl.getNode() and NamePropertyTest use different exception than documented in the JCR API JavaDoc",
        "description": "The Property.getNode() method's JavaDoc [1] lists 3 types of exceptions: ValueFormatException, ItemNotFoundException, and RepositoryException, and that ItemNotFoundException is to be thrown when the target node could not be found.  However, the NamePropertyTest.testGetProperty() method is checking for a PathNotFoundException rather than the documented ItemNotFoundException (see [2], line 189).  Jackrabbit's implementation in PropertyImpl (see [3] line 539) delegates to Session.getNode(absolutePath) or Property.getParent().getNode(relativePath), and these methods are documented as throwing PathNotFoundException (see [4] and [5]).\n\nTherefore, the unit test and PropertyImpl.getNode() implementation appear to be in disagreement with the JCR 2.0 API JavaDoc.\n\n[1] http://www.day.com/maven/javax.jcr/javadocs/jcr-2.0/javax/jcr/Property.html#getNode()\n[2] http://svn.apache.org/viewvc/jackrabbit/trunk/jackrabbit-jcr-tests/src/main/java/org/apache/jackrabbit/test/api/NamePropertyTest.java?revision=772352&view=markup\n[3] http://svn.apache.org/viewvc/jackrabbit/trunk/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/PropertyImpl.java?revision=948827&view=markup\n[4] http://www.day.com/maven/javax.jcr/javadocs/jcr-2.0/javax/jcr/Session.html#getNode(java.lang.String)\n[5] http://www.day.com/maven/javax.jcr/javadocs/jcr-2.0/javax/jcr/Node.html#getNode(java.lang.String)\n",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-55",
        "summary": "VFS backed file system",
        "description": "File System implementation backed by commons VFS. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1883",
        "summary": "Moved node disappears",
        "description": "Moving a node and then refreshing it can make it disappear.\n\ndeleteDirectory(new File(\"repository\"));\nRepository rep = new TransientRepository();\nSession session = rep.login(new SimpleCredentials(\"\", new char[0]));\nNode root = session.getRootNode();\nNode a = root.addNode(\"a\");\nNode b = a.addNode(\"b\");\nsession.save();\nsession.move(\"/a/b\", \"/b\");\nb.refresh(false);\n// session.save(); // no effect\nfor (NodeIterator it = root.getNodes(); it.hasNext();) {\n    Node n = it.nextNode();\n    System.out.println(n.getName());\n    for (NodeIterator it2 = n.getNodes(); it2.hasNext();) {\n        System.out.println(\"  \" + it2.nextNode().getName());\n    }\n}\n\nIn the trunk, the node 'b' is not listed after the refresh (not under the root page, and not under a). The output is:\njcr:system\n  jcr:versionStorage\n  jcr:nodeTypes\na\n\n\nJackrabbit 1.4.x throws an exception:\n\njcr:system\n  jcr:versionStorage\n  jcr:nodeTypes\na\nException in thread \"main\" javax.jcr.RepositoryException: failed to resolve name of acee31c4-c33b-4ed4-b1b5-39db6f17fb09\n\tat org.apache.jackrabbit.core.HierarchyManagerImpl.getName(HierarchyManagerImpl.java:451)\n\tat org.apache.jackrabbit.core.CachingHierarchyManager.getName(CachingHierarchyManager.java:287)\n\tat org.apache.jackrabbit.core.NodeImpl.getName(NodeImpl.java:1931)\n\tat org.apache.jackrabbit.core.fuzz.TestMoveRemoveRefresh.test(TestMoveRemoveRefresh.java:33)\n\tat org.apache.jackrabbit.core.fuzz.TestMoveRemoveRefresh.main(TestMoveRemoveRefresh.java:15)\n\n\nvoid deleteDirectory(File file) {\n    if (file.isDirectory()) {\n        File[] list = file.listFiles();\n        for(int i=0; i<list.length; i++) {\n            deleteDirectory(list[i]);\n        }\n    }\n    file.delete();\n}\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-495",
        "summary": "TCK: SessionReadMethodsTest#testIsLive calls logout() more than once",
        "description": "SessionReadMethodsTest#testIsLive calls logout more than once in a session (once in the test, once in tearDown).  JSR-170 doesn't prohibit an implementation from throwing an unchecked exception (such as IllegalStateException) if logout is called more than once.\n\nProposal: change tearDown to test isLive before calling logout.\n\n--- SessionReadMethodsTest.java (revision 422074)\n+++ SessionReadMethodsTest.java (working copy)\n@@ -57,7 +57,7 @@\n      * Releases the session aquired in {@link #setUp()}.\n      */\n     protected void tearDown() throws Exception {\n-        if (session != null) {\n+        if (session != null && session.isLive()) {\n             session.logout();\n         }\n         super.tearDown();\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2876",
        "summary": "org.apache.jackrabbit.server.io.IOUtil getTempFile misses dot in tmp suffix",
        "description": "At line 168:\nFile tmpFile = File.createTempFile(\"__importcontext\", \"tmp\");\nSuffix tmp has no use because the dot is missing.\n\nShould be:\nFile tmpFile = File.createTempFile(\"__importcontext\", \".tmp\");\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-757",
        "summary": "Allow multiple producers to feed/consume journal",
        "description": "Some clustered application based on jackrabbit might want to append custom records to the central journal in order to synchronize all nodes. Therefore, journal should provide support for multiple consumers/producers.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2142",
        "summary": "InternalValue should implement QValue.discard() for BINARY types",
        "description": "currently jackrabbit-core always extracts the BLOBFileValue in order to free resources. Since InternalValue now implements QValue this could be achieved on the InternalValue directly.\nHowever, currently the base implementation is inherited instead of dealing with the BLOBFileValues.\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1175",
        "summary": "Test cases for all FileSystem implementations",
        "description": "Currently we only have test cases for MemoryFileSystem, but those tests could easily be generalized to cover also the other FileSystem implementations.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-533",
        "summary": "failing Node.lock() might leave inconsistent transient state",
        "description": "When I try to node.lock(true, false) a node and the lock fails due to lak of user privilegies, the lock stay in the user transient session. If a perform a node.refresh(false) the node still is locked in the transient session.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2576",
        "summary": "DbInputStream does not support mark()/reset() when exhausted.",
        "description": "The DbDataStore implementation uses a DbInputStream to read binary properties from the database. When a new binary property is created, Jackrabbit attempts to index it. Tika's CharsetDetector is used in the process, which marks the input stream, reads the first 8000 bytes and then resets the stream.\n\nThis results in the stacktrace shown at the end of the issue, if the following two conditions hold true:\n* the property is larger than the minRecordLength configuration of the Datastore and\n* the property is smaller than 8000 bytes\n\nThe DbInputStream needs to have the following properties:\n1. lazy instantiation of the underlying stream\n2. auto-close underlying stream when EOF is reached\n3. fully support mark()/reset() even if  the underlying stream is auto-closed due to 2.\n\n\n12.03.2010 15:53:28 *WARN * LazyTextExtractorField: Failed to extract text from a binary property (LazyTextExtractorField.java, line 165)\njava.io.EOFException\n        at org.apache.jackrabbit.core.data.db.DbInputStream.reset(DbInputStream.java:180)\n        at org.apache.tika.io.ProxyInputStream.reset(ProxyInputStream.java:156)\n        at org.apache.tika.io.ProxyInputStream.reset(ProxyInputStream.java:156)\n        at org.apache.tika.parser.txt.CharsetDetector.setText(CharsetDetector.java:131)\n        at org.apache.tika.parser.txt.TXTParser.parse(TXTParser.java:77)\n        at org.apache.tika.parser.CompositeParser.parse(CompositeParser.java:120)\n        at org.apache.tika.parser.AutoDetectParser.parse(AutoDetectParser.java:101)\n        at org.apache.tika.parser.AutoDetectParser.parse(AutoDetectParser.java:114)\n        at org.apache.jackrabbit.core.query.lucene.LazyTextExtractorField$ParsingTask.run(LazyTextExtractorField.java:160)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)\n        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:138)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:98)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:207)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n        at java.lang.Thread.run(Thread.java:619)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1799",
        "summary": "JCR2SPI: updating events swallowed (CacheBehavior.OBSERVATION)",
        "description": "with CacheBehavior.OBSERVATION the hierarchy held within jcr2spi is updated based on events.\n\nif Session-A persistently adds a mix:referenceable to a Node that is already loaded in Session-B, the latter will not be informed about this change.\n\nReason: upon processing the SPI Event (-> HierarchyEventListener#onEvent) the parent is retrieved by the Event ItemId, which in the former case contains a uniqueID part, which is not known yet to the listening Session-B.\nConsequently the NodeEntry affected by the event is not updated.\n\nPossible fix: If looking up the parent entry of the event doesn't succeed, a 2nd lookup using the Event path should be performed.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-451",
        "summary": "PropertyTypeRegistry should also yield if property is multi-valued",
        "description": "Currently only the PropertyType is available for a certain property name. In some cases it is also required to know if the property is single- or multi-valued.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3016",
        "summary": "inconsistent repository after overlapping node add operations",
        "description": "It seems I can reproduce a sequence of operations that cause the repository to be inconsistent.\n\nThe short version: 2 sessions add a same-named child node to the same parent folder (not allowing same-name-siblings). Session 1's save() succeeds. Session 2's save() fails, but succeeds on retry (!).\n\nAfter the operation, the child node created by session 1 is still present, but the parent doesn't list it as child node anymore.\n\n(will add test case)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-57",
        "summary": "WorkspaceImpl.dispose() might cause ClassNotFoundException",
        "description": "Wenn using Jackrabbit in an environment, where ClassLoaders may get inactivated in the sense, the loading new classes is not possible anymore, shutting down the repository may result in a ClassNotFoundException during WorkspaceImpl.dispose().\n\nReason for this is, that in the dispose() method, the ObservationManager is asked for all registered event listeners for them to be removed from the ObservationManager one-by-one. Asking for the listeners results in a new EventListenerIteratorImpl object being created.\n\nIf now, this class has never been used during the live time of the repository, this would cause a ClassNotFoundException because the class loader is not laoding classes anymore in the specific environment.\n\nThe specific environment is Eclipse, where one plugin is managing different Repository instances provided by separate plugins. When now the Jackrabbit provider plugin has already been stopped while the managing plugin tries to shutdown the Jackrabbit repository, the EventListenerIteratorImpl class cannot be loaded anymore and disposing the WorkspaceImpl in a controlled way fails.\n\nI suggest adding an ObservationManagerImpl.dispose() method, which is called by the WorkspaceImpl like :\n    WorkspaceImpl.dispose() {\n       if (obsMgr != null) {\n         obsMgr.dispose();\n         obsMgr = null;\n        }\n    }\n\nAs a side effect of not calling getObservationManager[Impl]() the observation manager would also not be created if not existing yet.\n\nAs a side effect to having the dispose method is, that the ObservationManagerImpl class could also do other cleanup work in addition to clearing the listener lists.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2894",
        "summary": "AbstractLoginModule#logout() : credentials will not be clared as Subject.getPublicCredentials(Class) isn't backed by the subject internal set",
        "description": "AbstractLoginModule#logout()  clears the credentials list retrieved by calling Subject.getPublicCredentials(Class).\nthis doesn't have the desired effect as the returned set isn't backed by the subjects internal credentials set. (see API documentation of javax.security.auth.Subject)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1099",
        "summary": "jcr2spi NodeEntryImpl.getPath() blows stack due to getIndex() calling itself",
        "description": "The jcr2spi NodeEntryImpl class contains logic that causes getIndex() to call itself.\n\nCalling code:\n\n    Session sess = repo.login(creds);\n    Node inboxNode = sess.getRootNode().getNode(\"Inbox\");\n    inboxNode.getPath(); <== blows stack\n\nTracing reveals:\n\n    1. NodeEntryImpl.getPath() ultimately calls getIndex()\n    2. getIndex() calls NodeState.getDefinition()\n    3. which calls ItemDefinitionProviderImpl.getQNodeDefinition(...)\n    4. which catches a RepositoryException then calls NodeEntryImpl.getWorkspaceId()\n    5. which calls NodeEntryImpl.getWorkspaceIndex()\n    6. which calls getIndex() (back to step 2, ad infinitum)\n\nConfiguration:\n    1. A configuration is loaded specifying in-memory persist manager\n    2. Config is wrapped in TransientRepository\n    3. that's wrapped in spi2jcr's RepositoryService using default BatchReadConfig\n    4. a jcr2spi provider is instantiated that directly couples to spi2jcr\n    5. Node in question is created as follows:\n\n    Session sess = repo.login(creds);\n    sess.getRootNode().addNode(\"Inbox\", \"nt:folder\");\n    sess.save();\n\nI guess that's about it.\nDavid",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1071",
        "summary": "PROPPATCH on collection gets 403 Forbidden",
        "description": "DefaultHandler.canImport(PropertyImportContext, boolean) prevents setting properties (PROPPATCH) on collections through WebDAV ... returns 403 Forbidden. It checks to see whether the contextItem is not a collection, or has a jcr:content node. This test fails for a collection and should probably allow collections or nodes that have a jcr:content subnode. Here is a patch for the change\n\nIndex: jackrabbit-jcr-server/src/main/java/org/apache/jackrabbit/server/io/DefaultHandler.java\n===================================================================\n--- jackrabbit-jcr-server/src/main/java/org/apache/jackrabbit/server/io/DefaultHandler.java\t(revision 567695)\n+++ jackrabbit-jcr-server/src/main/java/org/apache/jackrabbit/server/io/DefaultHandler.java\t(working copy)\n@@ -570,7 +570,7 @@\n         }\n         Item contextItem = context.getImportRoot();\n         try {\n-            return contextItem != null && contextItem.isNode() && (!isCollection || ((Node)contextItem).hasNode(JcrConstants.JCR_CONTENT));\n+            return contextItem != null && contextItem.isNode() && (isCollection || ((Node)contextItem).hasNode(JcrConstants.JCR_CONTENT));\n         } catch (RepositoryException e) {\n             log.error(\"Unexpected error: \" + e.getMessage());\n             return false;\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2625",
        "summary": "spi2davex: reduce memory footprint of Node/PropertyInfoImpl",
        "description": "the in-memory footprint of o.a.jackrabbit.spi2davex.NodeinfoImpl & PropertyInfoImp is quite big. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-814",
        "summary": "Oracle bundle PM fails checking schema if 2 users use the same database",
        "description": "When using the OracleBundlePersistenceManager there is an issue when two users use the same database for persistence. In  that case, the checkSchema() method of the BundleDbPersistenceManager  does not work like it should. More precisely, the call \"metaData.getTables(null,  null, tableName, null);\" will also includes table names of other  schemas/users. Effectively, only the first user of a database is able to create  the schema.\n\nprobably same issue as here: JCR-582",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2071",
        "summary": "IndexMerger throws null pointer exception without stacktrace",
        "description": "I get the following errors in my log file randomly.  It seems to happen most often when creating the lucene indices, but has happened at other times as well:\n\n[IndexMerger] ERROR - Error while merging indexes: java.lang.NullPointerException\n\nThe code at org.apache.jackrabbit.core.query.lucene.IndexMerger line 344 appears to be the point where the error is logged, but no other information is provided because the throwable isn't sent to the log (only the toString() version of the exception).  I haven't been able to tell if any indexes are corrupt when this happens.\n\nI suggest that the logger be changed to determine where the null pointer is coming from first, then resolve the actual issue that is occurring.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3124",
        "summary": "Stats for Queries",
        "description": "Re-enable the stats for queries, as they were disabled during the refactoring phase.",
        "label": "NUG",
        "classified": "TASK",
        "type": ""
    },
    {
        "key": "JCR-1712",
        "summary": "JSR 283: JCR Names",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1705",
        "summary": "Reduce memory usage of transient nodes",
        "description": "When adding lots of transient nodes, most of them don't have child nodes because they are leafs. The attached patch initializes NodeState.childNodeEntries with an unmodifiable empty ChildNodeEntries instance and turns it into a modifiable one only when needed.\n\nRunning a test with 100k nodes (10 children per node) the memory consumption for child node entries drops from 42MB to 12MB with this patch.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1090",
        "summary": "Superfluous AndQueryNode  in query tree built by SQL parser",
        "description": "Test query (tested with <http://people.apache.org/~mreutegg/jcr-query-translator/translator.html>):\n\n  SELECT * FROM nt:folder WHERE x = 1 \n\ngenerates the following query tree:\n\n+ Root node\n+ Select properties: *\n  + PathQueryNode\n    + LocationStepQueryNode:  NodeTest=* Descendants=true Index=NONE\n      + AndQueryNode\n        + RelationQueryNode: Op: =  Prop=@{}x Type=LONG Value=1\n      + NodeTypeQueryNode:  Prop={http://www.jcp.org/jcr/1.0}primaryType Value={http://www.jcp.org/jcr/nt/1.0}folder\n\nIt seems the AndQueryNode is superfluous.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3131",
        "summary": "NPE in ItemManager when calling Session.save() with nothing to save",
        "description": "I'm getting an NPE on the id.denoteNodes() call below, in ItemManager:\n\n    private ItemData retrieveItem(ItemId id) {\n        synchronized (itemCache) {\n            ItemData data = itemCache.get(id);\n            if (data == null && id.denotesNode()) {\n...\n\nbecause the id is null after taking the second branch of this if in SessionSaveOperation.perform:\n\n        if (context.getSessionImpl().hasPermission(\"/\", Session.ACTION_READ)) {\n            id = context.getRootNodeId();\n        } else {\n            id = context.getItemStateManager().getIdOfRootTransientNodeState();\n        }\n\ncontext.toString() says:\n\nsession-author-3623:\nItemManager (org.apache.jackrabbit.core.ItemManager@1e911ccc)\nItems in cache:\n\nSessionItemStateManager (org.apache.jackrabbit.core.state.SessionItemStateManager@15472b43)\n[transient]\n{}[attic]\n{}\n\nwhich I assume means there's nothing to save.\n\nThe correct behavior is probably to do nothing in perform to avoid the NPE.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-458",
        "summary": "session.move() throws ItemExistsException despite same name siblings",
        "description": "code to reproduce:\n\n            Session session = r.login(new SimpleCredentials(\"johndoe\", \"\".toCharArray()), wspName);\n            Node root = session.getRootNode();\n\n            // setup test case\n            if (!root.hasNode(\"foo\")) {\n                root.addNode(\"foo\");\n                root.save();\n            }\n            if (!root.hasNode(\"bar\")) {\n                root.addNode(\"bar\");\n                root.save();\n            }\n\n            session.move(\"/foo\", \"/bar\");    // ==> ItemExistsException\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3237",
        "summary": "add missing name constants for mix:title",
        "description": "",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-952",
        "summary": "Support lower and upper case functions in \"order by\" clause",
        "description": "The query languages should support lower- and upper-case functions within the \"order by\" clause.  This would provide case-insensitive ordering of query results.\n\nExample:  Find all \"nt:base\" nodes ordered by the \"foo\" property, but ignoring case\n\nIn XPath:\n\n//element(*,nt:base) order by fn:lower-case(@foo)\n\nIn SQL:\n\nSELECT * FROM nt:base ORDER BY lower(foo)\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-841",
        "summary": "BundleDbPersistenceManager does not work with MySQL",
        "description": "It seems that the bundle persistence manager base does not work with MySQL. A SQLException is thrown on the line \"con.commit();\" in BundleDbPersistenceManager.checkSchema() because autoCommit is set to true in the init method. For some reason, this is ignored by the Oracle and MSSQL drivers. Anyway, commenting out the line fixes the issue, I think.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3009",
        "summary": "Prefix fulltext queries with Japanese or Chinese characters fail to match",
        "description": "Prefix fulltext queries with Japanese or Chinese characters do not match because the prefix part is not tokenized. This means, when the prefix length is >1 the sequence of characters is taken as one term to do the index lookup. This will not match anything because on indexing time such characters are always broken into individual tokens.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1216",
        "summary": "Unreferenced sessions should get garbage collected",
        "description": "If an application opens many sessions and doesn't close them, they are never garbage collected. After some time, the virtual machine will run out of memory. This code will run out of memory after a few thousand logins:\n\nRepository rep = new TransientRepository();\nfor (int i = 0; ; i++) {\n  rep.login(new SimpleCredentials(\"\", new char[0]));\n}\n\nUsing a finalizer to close SessionImpl doesn't work, because it seems there are references from the (hard referenced part of the cache) to the SessionImpl objects. Maybe it is possible to remove those references, or change them to weak references.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-822",
        "summary": "TCK: Transfer of lock token should be tested using open-scoped locks",
        "description": "despite the fact that jsr170 does not limit the usage of Session.removeLockToken(String) and Session.addLockToken(String) to tokens obtained from open-scoped locks, i don't see too much benefit of it. Therefore (and due to the fact that this issue will be addressed within the scope of jsr283), i would  like to suggest to modify those test-cases dealing with transfer of lock tokens and create open-scoped locks.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2234",
        "summary": "changed behavior of javax.jcr.Value get* methods",
        "description": "stream handling semantics of javax.jcr.Value has been simplified in JCR 2.0:\n\nSection '5.10.5.1 Deprecated Binary Behavior'\n\n[...]\nUnlike in JCR 1.0, calling a get method other than getStream before \ncalling getStream on the same Value object will never cause an \nIllegalStateException. \n\n\nsee https://jsr-283.dev.java.net/issues/show_bug.cgi?id=658",
        "label": "NUG",
        "classified": "SPEC",
        "type": ""
    },
    {
        "key": "JCR-797",
        "summary": "Typo in the deploy/jboss/4.x/jcr-ds.xml file",
        "description": "\nThe datasource descriptor in the jboss 4.x example xml file has a type in this line:\n\n<config-property name=\"bindSessionToTrasaction\" type=\"java.lang.Boolean\">true</config-property>\n\nbindSessionToTrasaction ought to be bindSessionToTransaction - there is an 'n' missing from Transaction.\n\nFound this on the tagged release in the subversion repo.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2346",
        "summary": "Dont use nt:frozenNode to create nodes",
        "description": "Some test cases may end up trying to create a new node of type nt:frozenNode which fails.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1699",
        "summary": "Do not log warning when coercing value in query is not possible",
        "description": "The LuceneQueryBuilder currently logs a warning when a String literal cannot be coerced into a type derived from information provided by the node type manager. The log level should be lowered to debug.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1500",
        "summary": "removing properties through SPI: two ways to do it",
        "description": "Batch currently provides two ways to delete a property, similarly to JCR:\n\n- Batch.remove()\n- Batch.setValue(..., null)\n\nJCR2SPI currently uses (AFAIK) Batch.remove().\n\nProposal:\n\n- clarify that the QValue argument in setValue must be non-null (same for setValues)\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-739",
        "summary": "String literal must not interpret entity references",
        "description": "The ampersand character in a string literal is interpreted as a start character for an entity reference. This is because Jackrabbit uses an XQuery parser where a string literal is slightly more constraint than in XPath.\n\nExample:\n\n//element(*, nt:base)[jcr:contains(., 'max&moritz')]\n\nthrows a parse exception. Instead the parser should simply recognize the ampersand as regular character.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1534",
        "summary": "Use POIExtractor wherever possible",
        "description": "POI scratchpad comes with a couple of text extractor utilities, which makes it easier to extract text. We should rather use those utilities than writing our own extractor code. This helps avoid issues like JCR-1530.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1263",
        "summary": "Move SimpleWebdavServlet to jcr-server and make it abstract",
        "description": "In line with isse JCR-417, I suggest to partially move the SimpleWebdavServlet from the jcr-webapp project to the jcr-server project. By partially I mean, that the new (moved) servlet will be abstract and the getRepository() method will be abstract. The jcr-webapp project will still contain a SimpleWebdavServlet (for backwards compatibility maintaing the same name) which just extends the new servlet and implements the getRepository() method using the RepositoryAccess servlet.\n\nThis allows for the reuse of the jcr-server project including the abstract SimpleWebdavServlet in other environments. My intention is to include this project (along with the webdav) project in Sling.\n\nWill provide a patch for this proposal\n\n(This issue is separated out of JCR-1262 as suggested by Angela)\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3198",
        "summary": "Broken handling of outer join results over davex",
        "description": "The davex join support added in JCR-3089 only works correctly when the join returns at least one row and none of the returned rows contain null values for any of the selectors. This should be reasonably straightforward to fix.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-893",
        "summary": "More query classes with missing extractTerms()",
        "description": "The query classes DerefQuery, RangeQuery and WildcardQuery do not overwrite the method extractTerms().",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2579",
        "summary": "InvalidItemStateException when attempting concurrent, non conflicting writes",
        "description": "I'm having some problems doing concurrent addition of nodes to a parent node in Jackrabbit.  I've attached a simple test which starts up a bunch of threads which add nodes to a parent node concurrently. If I add in locks I can get this to work, however according to the mailing list this should work without locks. However, the test always fails with this:\n\njavax.jcr.InvalidItemStateException: Item cannot be saved because it has been modified externally: node /testParent\n\tat org.apache.jackrabbit.core.ItemImpl.getTransientStates(ItemImpl.java:281)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:939)\n\tat org.mule.galaxy.impl.JackrabbitConcurrentWriteTest$1.run(JackrabbitConcurrentWriteTest.java:71)\n\nI'm using Jackrabbit 1.6.1. Here is my (verbose) node type:\n\n  <nodeType name=\"galaxy:noSiblings\" \n    isMixin=\"false\" \n    hasOrderableChildNodes=\"false\"\n    primaryItemName=\"\">\n    <propertyDefinition name=\"*\" requiredType=\"undefined\" onParentVersion=\"COPY\" />\n    <propertyDefinition name=\"*\" requiredType=\"undefined\" onParentVersion=\"COPY\" multiple=\"true\"/>\n    <childNodeDefinition name=\"*\" defaultPrimaryType=\"nt:unstructured\" onParentVersion=\"COPY\" sameNameSiblings=\"false\" />\n    <supertypes>\n        <supertype>nt:base</supertype>\n        <supertype>mix:referenceable</supertype>\n        <supertype>mix:lockable</supertype>\n    </supertypes>\n  </nodeType>\n\nAnd my test:    \n\npackage org.mule.galaxy.impl;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.jcr.LoginException;\nimport javax.jcr.Node;\nimport javax.jcr.Repository;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.SimpleCredentials;\n\nimport junit.framework.TestCase;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.jackrabbit.api.JackrabbitNodeTypeManager;\nimport org.apache.jackrabbit.core.RepositoryImpl;\nimport org.apache.jackrabbit.core.TransientRepository;\nimport org.apache.jackrabbit.core.config.RepositoryConfig;\n\npublic class JackrabbitConcurrentWriteTest extends TestCase {\n    \n    private Repository repository;\n    private Session session;\n    private String parentUUID;\n    private boolean continueLoop = true;\n    \n    public void setUp() throws Exception {\n        FileUtils.deleteDirectory(new File(\"repository\"));\n        File repoDir = new File(\"repository\");\n        repoDir.mkdirs();\n        RepositoryConfig config = RepositoryConfig.create(new File(\"src/test/resources/META-INF/jackrabbit-repo-test.xml\"), repoDir);\n        repository = RepositoryImpl.create(config);\n        session = createSession();\n        \n        createCustomNodeTypes(session);\n        \n        parentUUID = session.getRootNode().addNode(\"testParent\", \"galaxy:noSiblings\").getUUID();\n        session.save();\n        session.logout();\n    }\n\n    private Session createSession() throws LoginException, RepositoryException {\n        return repository.login(new SimpleCredentials(\"username\", \"password\".toCharArray()));\n    }\n    \n    public void testConcurrency() throws Exception {\n        final List<Exception> exceptions = new ArrayList<Exception>();\n        int threadCount = 20;\n        final CountDownLatch latch = new CountDownLatch(threadCount);\n        \n        for (int i = 0; i < threadCount; i++) {\n            Thread thread = new Thread() {\n\n                @Override\n                public void run() {\n                    try {\n                        while (continueLoop) {\n                            Session session = createSession();\n                            try {\n                                Node node = session.getNodeByUUID(parentUUID);\n                                node.addNode(UUID.randomUUID().toString());\n                                node.save();\n                                session.save();\n                            } finally {\n                                session.logout();\n                            }   \n                        }\n                    } catch (RepositoryException e) {\n                        exceptions.add(e);\n                        continueLoop = false;\n                    }\n                    latch.countDown();\n                }\n                \n            };\n            thread.start();\n        }\n        \n        latch.await(10, TimeUnit.SECONDS);\n        continueLoop = false;\n        \n        for (Exception e : exceptions) {\n            e.printStackTrace();\n        }\n        assertEquals(0, exceptions.size());\n    }\n    \n    public void createCustomNodeTypes(Session session) throws RepositoryException, IOException {\n        // Get the JackrabbitNodeTypeManager from the Workspace.\n        // Note that it must be cast from the generic JCR NodeTypeManager to\n        // the Jackrabbit-specific implementation.\n        // (see: http://jackrabbit.apache.org/node-types.html)\n        JackrabbitNodeTypeManager manager = (JackrabbitNodeTypeManager) session.getWorkspace().getNodeTypeManager();\n\n        // Register the custom node types defined in the CND file\n        InputStream is = Thread.currentThread().getContextClassLoader()\n                .getResourceAsStream(\"org/mule/galaxy/impl/jcr/nodeTypes.xml\");\n        manager.registerNodeTypes(is, JackrabbitNodeTypeManager.TEXT_XML);\n    }\n}",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1906",
        "summary": "Make observation polling time configurable",
        "description": "Currently the polling time is hard coded to 3 seconds in org.apache.jackrabbit.jcr2spi.WorkspaceImpl. I suggest to make it configurable similar to CacheBehaviour. That is, add a respective setting to org.apache.jackrabbit.jcr2spi.config.RepositoryConfig",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1965",
        "summary": "[PATCH] Remove Stutter in ItemValidator",
        "description": "ItemValidator duplicates code for no reason. Remove the duplication\n\n        if (permissions > Permission.NONE) {\n            Path path = item.getPrimaryPath();\n            if (!accessMgr.isGranted(item.getPrimaryPath(), permissions)) {\n                return false;\n            }\n\nto\n\n        if (permissions > Permission.NONE) {\n            Path path = item.getPrimaryPath();\n            if (!accessMgr.isGranted(path, permissions)) {\n                return false;\n            }\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-363",
        "summary": "Node.setProperty(String, ...) implementation not according to the specification",
        "description": "to illustrate the issue assume the following  property definition:\n\nname: someText\ntype: String\nnon-mandatory\nnon-autocreate\n\nthe following call would throw a ConstraintViolationException\nif the property doesn't exist yet:\n\nnode.setProperty(\"someText\", 12345);\n\nthe rules used to find an applicable definition in this case are too strict.",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-4",
        "summary": "jira notifications",
        "description": "I have set up Jackrabbit's jira so that notifications will\ngo to the dev mailing list.  If that gets annoying, I can easily\nswitch it to a different list or turn off notifications such that\npeople have to register as watchers.\n\nLet me know what is best for you.\n\n....Roy\n",
        "label": "NUG",
        "classified": "TASK",
        "type": "TASK"
    },
    {
        "key": "JCR-2156",
        "summary": "Usage of \"qualified name\" in JavaDoc and Comments",
        "description": "Within jackrabbit the term \"qualified name\" is used, when the internal representation of a JCR name is referred according to the usage of \"fully-qualified name\" within the JSR 170 specification.\n\nBased on input by julian (Issue #449) the phrasing has been adjusted in JSR 283 to match the terminology used in XMLNS.\n\nAs of JSR 283\n\n- Qualified Name -> refers to a JCR Name in the form prefix:localname\n- Expanded Name -> is used for what was formerly called \"fully-qualified name\".\n\nIn order to avoid confusion i would suggest to fix the javadoc throughout the project and eventually add explanations in cases where method or class names are misleading.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-329",
        "summary": "NodeReferencesId.equals() is not symetric",
        "description": "NodeReferencesId.equals() is not symetric when equality is tested against a NodeId.\n\nCode example:\nUUID uuid = UUID.randomUUID();\nNodeId id = new NodeId(uuid);\nNodeReferencesId refId = new NodeReferencesId(uuid);\nid.equals(refId); // will return true\nrefId.equals(id); // will return false\n\nNodeReferencesId should be decouled from the ItemId hierarchy. The class NodeReferences already does not extend from NodeState which makes perfectly sense. So, the same should apply to the identifier of NodeReferences.\n\nThe attached patch to NodeReferencesId also requires minor changes to some of the persistence managers.",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3019",
        "summary": "RepositoryImpl.activeSessions should use Session instead of SessionImpl",
        "description": "Turn Map<SessionImpl, SessionImpl> activeSessions into Map<Session, Session> activeSessions as there is not clear need for the use of SessionImpl.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3098",
        "summary": "Add hit miss statistics and logging to caches",
        "description": "The current caches (ConcurrentCache) doesn't maintain hit and miss statistics. This makes it very hard to know if you need to increase the caches in a deployment. This functionality does exist in the 1.5 and 1.6 branches, but is missing from the 2.x branches. The patch adds these statistics and adds logging on info level. The frequency of the logging is by default configured to maximal once a minute but can be configured with the system property \"org.apache.jackrabbit.cacheLogStatsInterval\" (in ms). \n\nThe log lines look like:\n\n07.10.2011 09:00:39 INFO  [org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.logCacheStats():737] name=defaultBundleCache[ConcurrentCache@54fb02fd] num=21074 mem=34504k max=65536k hits=93352 miss=21074 puts=21135\n07.10.2011 09:00:40 INFO  [org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.logCacheStats():737] name=versionBundleCache[ConcurrentCache@47b1de1a] num=10637 mem=250k max=8192k hits=36352 miss=10637 puts=10637\n\nThis patch will also make possible to later on expose these statistics over JMX when the initial JMX work has been settled.  ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1319",
        "summary": "NullPointerException when accessing the SimpleWebdavServlet at the prefix path",
        "description": "When accessing the SimpleWebdavServlet with the \"root\" path, that is the same path as set with the resource-path-prefix, a NullPointerException is thrown:\n\njava.lang.NullPointerException\n\tat org.apache.jackrabbit.name.ParsingPathResolver.getQPath(ParsingPathResolver.java:91)\n\tat org.apache.jackrabbit.name.CachingPathResolver.getQPath(CachingPathResolver.java:74)\n\tat org.apache.jackrabbit.core.SessionImpl.getQPath(SessionImpl.java:601)\n\tat org.apache.jackrabbit.core.SessionImpl.getItem(SessionImpl.java:804)\n\tat org.apache.sling.jcr.api.internal.PooledSession.getItem(PooledSession.java:157)\n\tat org.apache.jackrabbit.webdav.simple.ResourceFactoryImpl.getNode(ResourceFactoryImpl.java:140)\n\tat org.apache.jackrabbit.webdav.simple.ResourceFactoryImpl.createResource(ResourceFactoryImpl.java:89)\n\tat org.apache.jackrabbit.webdav.server.AbstractWebdavServlet.service(AbstractWebdavServlet.java:187)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:820)\n\tat org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:487)\n\tat org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:362)\n\tat org.ops4j.pax.web.service.internal.HttpServiceServletHandler.handle(HttpServiceServletHandler.java:51)\n\tat org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)\n\tat org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:722)\n\tat org.ops4j.pax.web.service.internal.HttpServiceContext.handle(HttpServiceContext.java:87)\n\tat org.ops4j.pax.web.service.internal.JettyServerHandlerCollection.handle(JettyServerHandlerCollection.java:63)\n\tat org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:139)\n\tat org.mortbay.jetty.Server.handle(Server.java:324)\n\tat org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:505)\n\tat org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:828)\n\tat org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:514)\n\tat org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:211)\n\tat org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:380)\n\tat org.mortbay.jetty.bio.SocketConnector$Connection.run(SocketConnector.java:228)\n\tat org.mortbay.thread.BoundedThreadPool$PoolThread.run(BoundedThreadPool.java:450)\n\n\nThe problem seems to be that the ResourceFactoryImpl.createResource method (or rather the getNode method) is not prepared to a DavResourceLocator instance whose resourcePath is null.\n\nI could imagine, that the ResourceFactoryImpl.getNode() method might want to return the root node in this case ?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2433",
        "summary": "NPE when copying nodes with Workspace.copy()",
        "description": "I get a NullpointerException when using Workspace.copy():\n\njava.lang.NullPointerException\nat org.apache.jackrabbit.core.BatchedItemOperations.copyNodeState(BatchedItemOperations.java:1834)\nat org.apache.jackrabbit.core.BatchedItemOperations.copyNodeState(BatchedItemOperations.java:1806)\nat org.apache.jackrabbit.core.BatchedItemOperations.copyNodeState(BatchedItemOperations.java:1806)\nat org.apache.jackrabbit.core.BatchedItemOperations.copy(BatchedItemOperations.java:423)\nat org.apache.jackrabbit.core.WorkspaceImpl.internalCopy(WorkspaceImpl.java:444)\nat org.apache.jackrabbit.core.WorkspaceImpl.copy(WorkspaceImpl.java:666)\nat xxx.MyClass.myMeth(MyClass.java)\n\nIt seems that it happens not all the time. The error occurs since we use Jackrabbit 1.6.0. We do not get the error with previous versions. It seems that we only get the error when trying to copy nodes that were created with Jackrabbit 1.4 and copied with Jackrabbit 1.6.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-717",
        "summary": "Upgrade to SLF4J 1.3",
        "description": "Version 1.1 of the SLF4J logging facade was recently released. It contains no functional improvements that we'd need, but is split to a separate slf4j-api library and a set of backend-specic logging adapters. This would allow us to avoid exposing log4j as a transitive dependency for projects that depend on Jackrabbit.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1518",
        "summary": "BundleFsPersistenceManager has no property called: minBlobSize",
        "description": "2008-04-03 16:48:51,ERROR,org.apache.jackrabbit.core.RepositoryImpl,Thread-237 failed to start Repository: Cannot instantiate persistence manager org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager: The bean of type: org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager has no property called: minBlobSize\njavax.jcr.RepositoryException: Cannot instantiate persistence manager org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager: The bean of type: org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager has no property called: minBlobSize: The bean of type: org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager has no property called: minBlobSize\n\tat org.apache.jackrabbit.core.RepositoryImpl.createPersistenceManager(RepositoryImpl.java:1176)\n\tat org.apache.jackrabbit.core.RepositoryImpl.createVersionManager(RepositoryImpl.java:390)\n\tat org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:294)\n\tat org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:557)\n\tat pps.jcr.util.RepositoryManager.createRepository(RepositoryManager.java:117)\n\tat pps.jcr.util.RepositoryManager.startRepository(RepositoryManager.java:43)\n\tat pps.jcr.ejb.session.JcrUtilFacade.startRepository(JcrUtilFacade.java:62)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat com.sun.enterprise.security.application.EJBSecurityManager.runMethod(EJBSecurityManager.java:1067)\n\tat com.sun.enterprise.security.SecurityUtil.invoke(SecurityUtil.java:176)\n\tat com.sun.ejb.containers.BaseContainer.invokeTargetBeanMethod(BaseContainer.java:2895)\n\tat com.sun.ejb.containers.BaseContainer.intercept(BaseContainer.java:3986)\n\tat com.sun.ejb.containers.EJBLocalObjectInvocationHandler.invoke(EJBLocalObjectInvocationHandler.java:197)\n\tat com.sun.ejb.containers.EJBLocalObjectInvocationHandlerDelegate.invoke(EJBLocalObjectInvocationHandlerDelegate.java:127)\n\tat $Proxy181.startRepository(Unknown Source)\n\tat pps.jcr.web.JcrLifecycleListener.contextInitialized(JcrLifecycleListener.java:55)\n\tat org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4523)\n\tat org.apache.catalina.core.StandardContext.start(StandardContext.java:5184)\n\tat com.sun.enterprise.web.WebModule.start(WebModule.java:326)\n\tat org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:973)\n\tat org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:957)\n\tat org.apache.catalina.core.StandardHost.addChild(StandardHost.java:688)\n\tat com.sun.enterprise.web.WebContainer.loadWebModule(WebContainer.java:1584)\n\tat com.sun.enterprise.web.WebContainer.loadWebModule(WebContainer.java:1222)\n\tat com.sun.enterprise.web.WebContainer.loadJ2EEApplicationWebModules(WebContainer.java:1147)\n\tat com.sun.enterprise.server.TomcatApplicationLoader.doLoad(TomcatApplicationLoader.java:141)\n\tat com.sun.enterprise.server.AbstractLoader.load(AbstractLoader.java:244)\n\tat com.sun.enterprise.server.ApplicationManager.applicationDeployed(ApplicationManager.java:336)\n\tat com.sun.enterprise.server.ApplicationManager.applicationDeployed(ApplicationManager.java:210)\n\tat com.sun.enterprise.server.ApplicationManager.applicationDeployed(ApplicationManager.java:645)\n\tat com.sun.enterprise.admin.event.AdminEventMulticaster.invokeApplicationDeployEventListener(AdminEventMulticaster.java:928)\n\tat com.sun.enterprise.admin.event.AdminEventMulticaster.handleApplicationDeployEvent(AdminEventMulticaster.java:912)\n\tat com.sun.enterprise.admin.event.AdminEventMulticaster.processEvent(AdminEventMulticaster.java:461)\n\tat com.sun.enterprise.admin.event.AdminEventMulticaster.multicastEvent(AdminEventMulticaster.java:176)\n\tat com.sun.enterprise.admin.server.core.DeploymentNotificationHelper.multicastEvent(DeploymentNotificationHelper.java:308)\n\tat com.sun.enterprise.deployment.phasing.DeploymentServiceUtils.multicastEvent(DeploymentServiceUtils.java:226)\n\tat com.sun.enterprise.deployment.phasing.ServerDeploymentTarget.sendStartEvent(ServerDeploymentTarget.java:298)\n\tat com.sun.enterprise.deployment.phasing.ApplicationStartPhase.runPhase(ApplicationStartPhase.java:132)\n\tat com.sun.enterprise.deployment.phasing.DeploymentPhase.executePhase(DeploymentPhase.java:108)\n\tat com.sun.enterprise.deployment.phasing.PEDeploymentService.executePhases(PEDeploymentService.java:919)\n\tat com.sun.enterprise.deployment.phasing.PEDeploymentService.start(PEDeploymentService.java:591)\n\tat com.sun.enterprise.deployment.phasing.PEDeploymentService.start(PEDeploymentService.java:635)\n\tat com.sun.enterprise.admin.mbeans.ApplicationsConfigMBean.start(ApplicationsConfigMBean.java:744)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:375)\n\tat com.sun.enterprise.admin.MBeanHelper.invokeOperationInBean(MBeanHelper.java:358)\n\tat com.sun.enterprise.admin.config.BaseConfigMBean.invoke(BaseConfigMBean.java:464)\n\tat com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:836)\n\tat com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:761)\n\tat sun.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat com.sun.enterprise.admin.util.proxy.ProxyClass.invoke(ProxyClass.java:90)\n\tat $Proxy1.invoke(Unknown Source)\n\tat com.sun.enterprise.admin.server.core.jmx.SunoneInterceptor.invoke(SunoneInterceptor.java:304)\n\tat com.sun.enterprise.interceptor.DynamicInterceptor.invoke(DynamicInterceptor.java:174)\n\tat com.sun.enterprise.deployment.client.DeploymentClientUtils.startApplication(DeploymentClientUtils.java:145)\n\tat com.sun.enterprise.deployment.client.DeployAction.run(DeployAction.java:537)\n\tat java.lang.Thread.run(Thread.java:619)\nCaused by: java.lang.IllegalArgumentException: The bean of type: org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager has no property called: minBlobSize\n\tat org.apache.commons.collections.BeanMap.put(BeanMap.java:367)\n\tat org.apache.jackrabbit.core.config.BeanConfig.newInstance(BeanConfig.java:109)\n\tat org.apache.jackrabbit.core.RepositoryImpl.createPersistenceManager(RepositoryImpl.java:1171)\n\t... 64 more\n\n<?xml version=\"1.0\"?>\n<Repository>\n    <DataStore class=\"org.apache.jackrabbit.core.data.FileDataStore\">\n        <param name=\"path\" value=\"${rep.home}/datastore\"/>\n        <param name=\"minRecordLength\" value=\"100\"/>\n    </DataStore>    \n    <FileSystem class=\"org.apache.jackrabbit.core.fs.local.LocalFileSystem\">\n        <param name=\"path\" value=\"${rep.home}\"/>\n    </FileSystem>    \n    <Security appName=\"Jackrabbit\">\n        <AccessManager class=\"org.apache.jackrabbit.core.security.SimpleAccessManager\" />\n        <LoginModule class=\"org.apache.jackrabbit.core.security.SimpleLoginModule\">\n            <param name=\"anonymousId\" value=\"anonymous\" />\n        </LoginModule>\n    </Security>\n    <Workspaces rootPath=\"${rep.home}/workspaces\" defaultWorkspace=\"default\" />\n    <Workspace name=\"${wsp.name}\">\n        <FileSystem class=\"org.apache.jackrabbit.core.fs.local.LocalFileSystem\">\n            <param name=\"path\" value=\"${rep.home}/${wsp.name}\"/>\n        </FileSystem>            \n        <!--  <PersistenceManager class=\"org.apache.jackrabbit.core.persistence.obj.ObjectPersistenceManager\"/>  -->\n        <PersistenceManager class=\"org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager\">\n            <param name=\"bundleCacheSize\" value=\"8\"/> \n            <param name=\"blobFSBlockSize\" value=\"0\"/> \n            <param name=\"minBlobSize\" value=\"4096\"/> \n            <param name=\"errorHandling\" value=\"\"/>             \n        </PersistenceManager>        \n        <SearchIndex class=\"org.apache.jackrabbit.core.query.lucene.SearchIndex\">\n            <param name=\"path\" value=\"${wsp.home}/index\"/>    \n            <param name=\"textFilterClasses\" value=\"\n                   org.apache.jackrabbit.extractor.MsExcelTextExtractor,\n                   org.apache.jackrabbit.extractor.MsPowerPointTextExtractor,\n                   org.apache.jackrabbit.extractor.MsWordTextExtractor,\n                   org.apache.jackrabbit.extractor.PdfTextExtractor,\n                   org.apache.jackrabbit.extractor.PlainTextExtractor,\n                   org.apache.jackrabbit.extractor.HTMLTextExtractor,\n                   org.apache.jackrabbit.extractor.XMLTextExtractor,\n                   org.apache.jackrabbit.extractor.RTFTextExtractor,\n            org.apache.jackrabbit.extractor.OpenOfficeTextExtractor\"/>\n        </SearchIndex>\n    </Workspace>\n    <Versioning rootPath=\"${rep.home}/version\">\n        <FileSystem class=\"org.apache.jackrabbit.core.fs.local.LocalFileSystem\">\n            <param name=\"path\" value=\"${rep.home}/version\"/>\n        </FileSystem>                \n        <!-- <PersistenceManager class=\"org.apache.jackrabbit.core.persistence.obj.ObjectPersistenceManager\"/> -->\n        <PersistenceManager class=\"org.apache.jackrabbit.core.persistence.bundle.BundleFsPersistenceManager\">\n            <param name=\"bundleCacheSize\" value=\"8\"/> \n            <param name=\"blobFSBlockSize\" value=\"0\"/> \n            <param name=\"minBlobSize\" value=\"4096\"/> \n            <param name=\"errorHandling\" value=\"\"/>             \n        </PersistenceManager>            \n    </Versioning>\n    <SearchIndex class=\"org.apache.jackrabbit.core.query.lucene.SearchIndex\">\n        <param name=\"path\" value=\"${rep.home}/index\"/>    \n        <param name=\"textFilterClasses\" value=\"\n               org.apache.jackrabbit.extractor.MsExcelTextExtractor,\n               org.apache.jackrabbit.extractor.MsPowerPointTextExtractor,\n               org.apache.jackrabbit.extractor.MsWordTextExtractor,\n               org.apache.jackrabbit.extractor.PdfTextExtractor,\n               org.apache.jackrabbit.extractor.PlainTextExtractor,\n               org.apache.jackrabbit.extractor.HTMLTextExtractor,\n               org.apache.jackrabbit.extractor.XMLTextExtractor,\n               org.apache.jackrabbit.extractor.RTFTextExtractor,\n        org.apache.jackrabbit.extractor.OpenOfficeTextExtractor\"/>\n    </SearchIndex>    \n</Repository>\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-985",
        "summary": "[PATCH] refactor access to SAXParser and log which parser class is used",
        "description": "This parser collects code that was duplicated in the SessionImpl and WorkspaceImpl class to initialize the SAXParser.\n\nAlso, the actual SAXParser class being used is logged (once only) to make it easier to debug problems like JCR-984.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-917",
        "summary": "Migrate to maven 2 the other OCM subprojects",
        "description": "Migrate to maven 2 the other OCM subprojects : jcr-nodemanagement & spring. ",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3000",
        "summary": "SQL2 Join with OR clause still has some issues",
        "description": "There are still some issues with Joins that have OR clauses in them. I changed the test, so that it reflects the changes",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1231",
        "summary": "Jcr2Spi: Unneeded call to getPropertyInfo upon creating a new NodeState",
        "description": "creating a new NodeState may result in additional (but unneeded) calls to getPropertyInfo if a jcr:uuid or jcr:mixinTypes property is present. This can be avoided since the corresponding property values are already present.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2544",
        "summary": "spi2dav : list of known issues in the pom.xml",
        "description": "",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-859",
        "summary": "rep:excerpt() may return malformed XML",
        "description": "The rep:excerpt() function does not encode the prefined XML entities but writes them as is into the excerpt XML. This may produce malformed XML.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-962",
        "summary": "Deadlocks in ConcurrentVersioningWithTransactionsTest",
        "description": "Patch follows for a ConcurrentVersioningWithTransactionsTest, based on the existing ConcurrentVersioningTest but using transactions around the versioning operations.\n\nOn my macbook, running the test with CONCURRENCY = 100 and NUM_OPERATIONS = 100 causes a deadlock after a few seconds, thread dumps follow.\n\nNote that I had to ignore StaleItemStateException (which is probably justified, due to not locking stuff IIUC) to let the threads run long enough to show the problem.\n\nRunning the test a few times showed the same locking pattern several times: some threads are locked at line 87 (session.save(), no transaction) while others are at line 93 (transaction.commit()), in testConcurrentCheckinInTransaction():\n\n    80    public void testConcurrentCheckinInTransaction() throws RepositoryException {\n    81      runTask(new Task() {\n    82        public void execute(Session session, Node test) throws RepositoryException {\n    83          int i = 0;\n    84          try {\n    85            Node n = test.addNode(\"test\");\n    86            n.addMixin(mixVersionable);\n    87            session.save();\n    88            for (i = 0; i < NUM_OPERATIONS / CONCURRENCY; i++) {\n    89              final UserTransaction utx = new UserTransactionImpl(test.getSession());\n    90              utx.begin();\n    91              n.checkout();\n    92              n.checkin();\n    93              utx.commit();\n    94            }\n    95            n.checkout();\n    96          } catch (Exception e) {\n    97            final String threadName = Thread.currentThread().getName();\n    98            final Throwable deepCause = getLevel2Cause(e);\n    99            if(deepCause!=null && deepCause instanceof StaleItemStateException) {\n   100              // ignore \n   101            } else {\n   102              throw new RepositoryException(threadName + \", i=\" + i + \":\" + e.getClass().getName(), e);\n   103            }\n   104          }\n   105        }\n   106      }, CONCURRENCY);\n   107    }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1317",
        "summary": "Add a MBean method to programatically create a new Workspace.",
        "description": "Would be useful to have a mbean method to create a new workspace to use if with a jmx console.\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2464",
        "summary": "Reduce usage of String.intern()",
        "description": "String.intern() is used for interning the namespace URI in NameImpl. For some trivial cases the intern() method shouldn't be called but a constant should be\nused. E.g. I'm thinking about the empty namespace URI, where calling String.intern() is way more expensive than checking if the length of the URI string is zero. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2879",
        "summary": "SQL Azure support: clustered indexes",
        "description": "We tried to install JackRabbit in the Windows Azure cloud using SQL Azure. One of the limitations of SQL Azure is that it needs clustered indexes to work but the current implementation of the JackRabbit creates the indexes not clustered.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-56",
        "summary": "allow case insensitive searches",
        "description": "would be nice to be able to search specific properties like a fulltext search, e.g. with an ignore-case flag, so you could find a subset of the results of\n\n  select * from nt:base where contains('bla')\n\nusing something like\n\n  select * from nt:base where jcr:bla like '%bla%'\n\n(currently, the value must contain 'bla' exactly as it is to be found by the second query)\n\ni suggest to extend the contains function with an additional argument for the property to search in, e.g.\n\n  select * from nt:base where contains('bla',jcr:bla)\n\nthis could then also easily be used in XPath.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3160",
        "summary": "Session#move doesn't trigger rebuild of parent node aggregation",
        "description": "The summary says it all.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1658",
        "summary": "Executing query throws UnsupportedRepositoryOperationException(LEVEL_2_SUPPORTED) for a level 1 only implementation ",
        "description": "Executing a query  throws UnsupportedRepositoryOperationException(LEVEL_2_SUPPORTED) it the spi implementation is not level 2. This is because org.apache.jackrabbit.jcr2spi.query.execute() calls session.getValueFactory() which - by contract - throws if level 2 is not supported. A quick fix would be to call getJcrValueFactory() (available from the ManagerProvider interface implemented by SessionImpl) instead of getValueFactory(). However, I think a better fix might be to pass the ManagerProvider to the QueryImpl constructor instead of the session, all the managers and providers separately.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2137",
        "summary": "Use type StaticOperand for fullTextSearchExpression",
        "description": "See: https://jsr-283.dev.java.net/issues/show_bug.cgi?id=691",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2144",
        "summary": "InternalValue refactoring",
        "description": "Now that we have use the value factory from spi-commons, the InternalValue code should be simplified.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2095",
        "summary": "Use an enumeration for QOM join types",
        "description": "Like JCR-2094 but for join types. The join type constants in the PFD version of QueryObjectModelConstants are broken, and a type-safe enumeration would in any case be a good alternative to the string constants.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-492",
        "summary": "TCK: PropertyReadMethodsTest#testGetValues fails if it cannot find a single valued STRING property",
        "description": "If the JCR repository being tested does not contain any single valued property of type STRING, PropertyReadMethodsTest#testGetValues fails with the following exception:\n\njava.lang.NullPointerException at org.apache.jackrabbit.test.api.PropertyReadMethodsTest.testGetValues(PropertyReadMethodsTest.java:273) at org.apache.jackrabbit.test.AbstractJCRTest.run(AbstractJCRTest.java:401)\n\nThe test should either try to find a single valued property of any type (it is guaranted that it will at least find jcr:primaryType) or should throw NotExecutableException if is does not find the property it needs.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2796",
        "summary": "Restoring a node fails (partially) if done within a XA transaction",
        "description": "A problem occurs with the following sequence of steps: \n\n1) Create a versionable node that has a child and a grandchild.\n2) Perform a check-in of the versionable node and give a version-label.\n3) Perform a restore by using the version-label.\n4) Access the grandchild.\n\nStep 4 fails, if step 3 is executed within a transaction. If no transaction is used, then step 4 succeeds. \nThe test-case attached below can be executed within XATest.java (http://svn.apache.org/repos/asf/jackrabbit/trunk/jackrabbit-core/src/test/java/org/apache/jackrabbit/core/XATest.java).\n\n\npublic void testRestore() throws Exception {\n        Session session = null;\n        try {\n            session = getHelper().getSuperuserSession();\n\n            // make sure that 'testNode' does not exist at the beginning of the test\n            for (NodeIterator ni = session.getRootNode().getNodes(); ni.hasNext();) {\n                Node aNode = ni.nextNode();\n                if (aNode.getName().equals(\"testNode\")) {\n                    aNode.remove();\n                }\n            }\n\n            // 1) create 'testNode' that has a child and a grandchild\n            session.getRootNode().addNode(\"testNode\").addMixin(NodeType.MIX_VERSIONABLE);\n            session.getRootNode().getNode(\"testNode\").addNode(\"child\").addNode(\"grandchild\");\n            session.save();\n\n            // 2) check in 'testNode' and give a version-label\n            Version version = session.getWorkspace().getVersionManager().checkin(\n                    session.getRootNode().getNode(\"testNode\").getPath());\n            session.getWorkspace().getVersionManager().getVersionHistory(\n                    session.getRootNode().getNode(\"testNode\").getPath()).addVersionLabel(version.getName(),\n                    \"testLabel\", false);\n\n            // 3) do restore by label\n            UserTransaction utx = new UserTransactionImpl(session);\n            utx.begin();\n            session.getWorkspace().getVersionManager().restoreByLabel(\n                    session.getRootNode().getNode(\"testNode\").getPath(), \"testLabel\", true);\n            utx.commit();\n\n            // 4) try to get the grandchild (fails if the restoring has been done within a transaction)\n            session.getRootNode().getNode(\"testNode\").getNode(\"child\").getNode(\"grandchild\");\n        } finally {\n            if (session != null) {\n                session.logout();\n            }\n        }\n    } ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-924",
        "summary": "Use the Jackrabbit RMI extensions by default in jackrabbit-webapp",
        "description": "Using the Jackrabbit RMI extensions by default in jackrabbit-webapp\n\nRef :  http://www.nabble.com/Custom-node-types-with-RMI-tf3728625.html\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1875",
        "summary": "Failing Node.unlock() might leave inconsistent transient state",
        "description": "Similar to issue JCR-538 but for Node.unlock():\n\nIf updating the lock related properties (jcr:lockIsDeep or jcr:lockOwner) fails e.g. due to missing permission, there might be inconsistent transient modifications pending.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3200",
        "summary": "consistency check should get node ids in chunks, not rely on total count",
        "description": "The PM consistency checker should use the paging feature to fetch nodeIds in chunks, and also not rely on the total number of ids for logging purposes.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-68",
        "summary": "Lock.getNode() does not return lock holder",
        "description": "spec: \" N.getLock().getNode() (where N is a locked node) ... If N is in the subtree of the lock holder, H, then this call will return H.\"\n\nnow N is returned.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-48",
        "summary": "XMLPersistenceManager trims string property values",
        "description": "The XMLPersistenceManager trims the text of property values read in, so what's returned doesn't match the value set if it included whitespace at the start or end.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1217",
        "summary": "Aggregate include ignored if no primaryType set",
        "description": "If the include element of an aggregate definition does not have a primaryType attribute then the include is never matched.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2332",
        "summary": "Unable to delete a non session-scoped locked node in XA Environment",
        "description": "You must first add a valid lockToken to the Session and then try to remove this node in a XA Environment.\nThis will resulting in a NoSuchItemStateException: State has been marked destroyed.\nThe  problem is that the unlock Operation will be done after that the node has been marked for destroyed.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1374",
        "summary": "[PATCH] DbDataStore: Make sure streams are closed",
        "description": "Stream isn't closed on end of use. this patch fixes it.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2642",
        "summary": "JackrabbitParser and tika 0.7 parser",
        "description": "Hi,\n\nI was trying to implement a custom parser and found the following problem.\nSince tika 0.7 it is possible to implement your custom parser and specify it into a service provider configuration file (META-INF/services/org.apache.tika.parser.Parser). In this way there would be no need to maintain a custom tika-config.xml file if you'd like to implement a custom parser.\n\nThe problem that I had was in the JackrabbitParser because I wasn't able to instantiate the AutoDetectParser with the default constructor is will be instantiated using the default TikaConfig constructor.\nBasically from tika 0.7, the TikaConfig.getTikaConfig() is instantiating the TikaConfig using the default constructor instead of accessing the tika-config.xml file from withing the package, and reads the service provider configuration files and populate the parsers map.\n\nWhat I'm proposing is to change the JackrabbitParser to instantiate the AutoDetectParser using the default constructor, in this way the using tika version >= 0.7 we could easily implement our own parsers and there won't be a reason to maintain the tika-config.xml, also a sort of \"backward\" compatibility would be maintained because using the AutoDetectParser default constructor the TikaConfig is instantiated using TikaConfig.getTikaConfig() wich for tika versions < 0.7 calls the TikaConfig(InputStream) constructor whcih reads the configuration directly from the package.\n\nBasically the JackrabbitParser should look like this:\n\n    public JackrabbitParser() {\n            \tparser = new AutoDetectParser();\n    }\n \nThanks,\nDan",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-29",
        "summary": "Node.addNode() does not scale with increasing content",
        "description": "With increasing repository content (and versions), the time to create new nodes increases. For example with around 6500 nodes and 33500 properties, it takes around 3 seconds (!) to just add one single node !\n\nWhen attaching to the application with a Debugger and delibaretly suspending the VM, this stack trace is displayed all the times :\n\n   [ changing internals of access List iterator ]\n   PersistentNodeState(NodeState).getChildNodeEntries(String) line: 362\n   PersistentNode.getName() line: 84\n   PersistentVersionManager.getVersion(String) line: 278\n   VersionManager.getVersion(String) line: 304\n   VersionItemStateProvider.getNodeState(NodeId) line: 124\n   VersionItemStateProvider.hasPropertyState(PropertyId) line: 154\n   VersionItemStateProvider.hasItemState(ItemId) line: 174\n   SessionItemStateManager.getItemState(ItemId) line: 246\n   ItemManager.createItemInstance(ItemId) line: 563\n   ItemManager.getItem(ItemId) line: 332\n   NodeImpl.getProperty(QName) line: 876\n   NodeImpl.hasProperty(QName) line: 893\n   NodeImpl.safeIsCheckedOut() line: 2515\n   NodeImpl.internalAddChildNode(QName, NodeTypeImpl, String) line: 527\n   NodeImpl.internalAddNode(String, NodeTypeImpl, String) line: 475\n   NodeImpl.internalAddNode(String, NodeTypeImpl) line: 436\n   NodeImpl.addNode(String, String) line: 1145\n   ...\n\nIt seems, that virtual item state providers are asked for whatever property is looked for and this in return calls into the version handler, which loops over some child entries (currently around 1100 entries) to find one single entry with a given UUID.\n\nBesides the latter not being optimal and certainly not scaling, the former has its problems in its own right.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2462",
        "summary": "IllegalStateException on session#save()",
        "description": "The following code throws an IllegalStateException:\n\nNode node = ...\nSession session = node.getSession();\nnode.setProperty( \"tags\", \"test1\");\nnode.setProperty( \"tags\", \"test2\");\nnode.remove();\nsession.save();\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1322",
        "summary": "Cluster information is not persisted to database when connected to case sensitive MS SQL Server 2005",
        "description": "After a call to Session::save, we observed that cluster information was not written to the ${schemaObjectPrefix}JOURNAL and ${schemaObjectPrefix}GLOBAL_REVISION tables. We tested against Oracle 10 database servers and MS Sql Server 2005 servers. The problem was noticed only with MS Sql Server 2005. \n\nInitially, the problem was masked since the test was written as part of our unit test environment and the exceptions generated by JDBC were not showing up in the logs. A separate test with was carried out as shown by the code below\n\n<pre>\nimport java.io.FileInputStream;\n\nimport javax.jcr.Node;\nimport javax.jcr.Repository;\nimport javax.jcr.Session;\nimport javax.jcr.SimpleCredentials;\n\nimport org.apache.jackrabbit.core.TransientRepository;\nimport org.apache.jackrabbit.core.config.RepositoryConfig;\n\npublic class Main\n{\n    public static void main(String[] args)\n        throws Exception\n    {\n        System.setProperty(\"org.apache.jackrabbit.core.cluster.node_id\", \"testid\");\n        \n        RepositoryConfig config = RepositoryConfig.create(new FileInputStream(\"repository.xml\"), \"repository\");\n        \n        Repository repository = new TransientRepository();\n        \n        Session session = repository.login(new SimpleCredentials(\"username\", \"password\".toCharArray()));\n        \n        Node root = session.getRootNode();\n        \n        root.addNode(\"node1\");\n        root.addNode(\"node2\");\n        root.addNode(\"node3\");\n        \n        session.save();\n    }\n}\n</pre>\n\nThe configuration file used to configure the repository is attached.\n\nAfter debugging this, we obtained the exceptions that were previously not visible. Note that, JackRabbit continues to run (is that because the cluster code is running in a separate thread?) even after this exception. The problem was that the 'revision_id' field did not exist. The mssql.ddl schema file sets up the table names in capitals. However, at least two of the SQL statements in DatabaseJournal use lower case table names. For example:-\n\n<pre>\n        updateGlobalStmt = con.prepareStatement(\n                \"update \" + schemaObjectPrefix + \"global_revision \" +\n                \"set revision_id = revision_id + 1\");\n        selectGlobalStmt = con.prepareStatement(\n                \"select revision_id \" +\n                \"from \" + schemaObjectPrefix + \"global_revision\");\n</pre>\n\nAn additional error is that the mssql.ddl file is missing the following:\n\n<pre>\n# Inserting the one and only revision counter record now helps avoiding race conditions\ninsert into ${schemaObjectPrefix}GLOBAL_REVISION VALUES(0)\n</pre>\n\nFixing the above two issues, fixed the problem with MS SQL Server 2005.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-482",
        "summary": "DocViewSaxEventGenerator may generate non-NS-wellformed XML",
        "description": "The XML serialization code relies on the fact that all required prefix-to-uri mappings are known beforehand (actually, when serializing the root node). So there's an assumption that the permanent namespace registry will never change during serialization, which may be incorrect when another client adds namespace registrations while the XML export is in progress.\n\nTo fix this, \"addNamespacePrefixes\" should ensure that namespace declarations have been written for all prefixes used on the current node (node name + properties), potentially going back to the namespace resolver when needed.\n\n(Should there be consensus for that change I'm happy to give it a try)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1710",
        "summary": "Promote ChildNodeEntry and ChildNodeEntries to top level classes.",
        "description": "The current NodeState class is quite heavy weight (source code wise) and the inner class ChildNodeEntry is used in a lot of places outside of NodeState. I think it is useful to have them promoted to top level classes.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2843",
        "summary": "ConstraintSplitter.getSelectorNames doesn't support FullTextSearch constraints",
        "description": "The constraint type FullTextSearch is missing in the tested types in org.apache.jackrabbit.core.query.lucene.join.ConstraintSplitter.getSelectorNames(Constraint) method. Submitting a QOM query with a full-text constraint throws a javax.jcr.UnsupportedRepositoryOperationException, while the repository reports supporting such queries : session.getRepository().getDescriptorValue(Repository.QUERY_FULL_TEXT_SEARCH_SUPPORTED).getBoolean() returns TRUE.\n\nTypical stack trace :\n\njavax.jcr.UnsupportedRepositoryOperationException: Unknown constraint type: CONTAINS(r.[jcr:title], 'REGA -APA')\n\torg.apache.jackrabbit.core.query.lucene.join.ConstraintSplitter.getSelectorNames(ConstraintSplitter.java:177)\n\torg.apache.jackrabbit.core.query.lucene.join.ConstraintSplitter.getSelectorNames(ConstraintSplitter.java:195)\n\torg.apache.jackrabbit.core.query.lucene.join.ConstraintSplitter.getSelectorNames(ConstraintSplitter.java:157)\n\torg.apache.jackrabbit.core.query.lucene.join.ConstraintSplitter.split(ConstraintSplitter.java:106)\n\torg.apache.jackrabbit.core.query.lucene.join.ConstraintSplitter.split(ConstraintSplitter.java:104)\n\torg.apache.jackrabbit.core.query.lucene.join.ConstraintSplitter.<init>(ConstraintSplitter.java:80)\n\torg.apache.jackrabbit.core.query.lucene.join.QueryEngine.execute(QueryEngine.java:162)\n\torg.apache.jackrabbit.core.query.lucene.join.QueryEngine.execute(QueryEngine.java:147)\n\torg.apache.jackrabbit.core.query.QueryObjectModelImpl.execute(QueryObjectModelImpl.java:114)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1600",
        "summary": "Remove noLockHack in SharedItemStateManager",
        "description": "With the increased test coverage, specifically the recently added multi-threaded tests, I'm reasonably confident that the noLockHack in SharedItemStateManager is not needed anymore.\n\nAttached patch removes the hack. All tests still pass, including the daily integration tests.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2279",
        "summary": "Improve reusability of AbstractRepositoryService and AbstractReadableRepositoryService",
        "description": "Much of the functionality in AbstractReadableRepositoryService is not specific to reading but rather applies to any implementation (node types, name spaces, descriptors). I suggest to pull this functionality up from AbstractReadableRepositoryService to AbstractRepositoryService",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3091",
        "summary": "Lucene Scorer implementations should handle the 'advance' to NO_MORE_DOCS optimisation better",
        "description": "This is from the lucene Scorer (actually DocIdSetIterator) api:\n\"NOTE: this method may be called with NO_MORE_DOCS for efficiency by some Scorers. If your implementation cannot efficiently determine that it should exhaust, it is recommended that you check for that value in each call to this method.\"\n\nNone of the scorer implementations does that currently. Except for ChildAxisScorer thanks to JCR-3082.\n\nThis is a worthwhile effort, which can save us from bugs (JCR-3082) but also leverage some performance optimisation hints from the lucene api.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1326",
        "summary": "Log path of missing node when re-indexing fails",
        "description": "If one tries to re-index a corrupt workspace, then the UUID of the missing nodes is logged. If possible the log should also contain the path to the missing node.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-972",
        "summary": "Bundle consistency check does not work",
        "description": "The consistencyCheck feature in the database bundle persistence manager does not work because the correct table prefix is not used when loading all bundles.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3006",
        "summary": "UserManager: concurrent user creation using same intermediate path fails",
        "description": "concurrently creating users using same intermediate path fails with \"node ... has been modified externally\".\n\nthe problem is the intermediate path. if it doesn't exist multiple threads try to create it concurrently: \n\no.a.jackrabbit.core.security.user.UserManagerImpl, line 1310ff:\n\n\n            String[] segmts = defaultPath.split(\"/\");\n            NodeImpl folder = (NodeImpl) session.getRootNode();\n            String authRoot = (isGroup) ? groupsPath : usersPath;\n\n            for (String segment : segmts) {\n                if (segment.length() < 1) {\n                    continue;\n                }\n                if (folder.hasNode(segment)) {\n                    folder = (NodeImpl) folder.getNode(segment);\n                    if (Text.isDescendantOrEqual(authRoot, folder.getPath()) &&\n                            !folder.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {\n                        throw new ConstraintViolationException(\"Invalid intermediate path. Must be of type rep:AuthorizableFolder.\");\n                    }\n                } else {\n                    Node parent = folder;\n                    folder = addNode(folder, session.getQName(segment), NT_REP_AUTHORIZABLE_FOLDER);\n                }\n            }\n\nthe attached test case illustrates this issue/",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2343",
        "summary": "Utility class to tranform JCR-SQL2 to/from JCR-JQOM",
        "description": "The JCR2 doc specify that both contain the same thing and can be translated from one to another\nin a straightforward manner. The jackrabbit-jcr-commons module should offer a utility class to transform\nfrom one language to another in a generic way, \n\nfor exemple :\n- String toSQL2(QueryObjectModel qom)\n- QueryObjectModel toJQOM(QueryObjectModelFactory factory, String query)",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2534",
        "summary": "jcr-server: NPE in SearchResourceImpl if PathValue path is null",
        "description": "line 368 in SearchResourceImpl doesn't deal with null path thus causing NPE in the valuefactory. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1088",
        "summary": "WorkspaceRestoreTest extends RestoreTest",
        "description": "WorkspaceRestoreTest extends RestoreTest in order to re-use variables and setUp/tearDown code. \n\nOn the other hand, this causes all tests from RestoreTest that aren't overriden by WorkspaceRestoreTest to be run twice.\n\nProposal: decouple the classes, copying over the interesting parts from RestoreTest into WorkspaceRestoreTest.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-31",
        "summary": "sysview import cannot handle auto-created nodes",
        "description": "when importing a serialized system-view via the Session.importXML() method, an ItemExistsException is thrown, when a nodes has an auto-create child nodes.\n\nwhen the parent node is created during the import, the repository automatically creates the auto-create child nodes. when then import handler tries to create the respective child node, the exception is thrown.\n\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-2255",
        "summary": "activity storage path",
        "description": "JSR-283 states in 15.12.3:\n\n\"15.12.3 Activity Storage\nActivities are persisted as nodes of type nt:activity under system-generated\nnode names in activity storage below /jcr:system/jcr:activities.\"\n\nAs far as I can tell, this is currently not the case.\n\nA related test case, org.apache.jackrabbit.test.api.version.ActivitiesTest#testActivitiesPath, apparently was taken out accidentally.\n\nIf Jackrabbit can't implement this JCR requirement, we either need to document it, or raise it as issue in the JCR Expert Group.",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-3167",
        "summary": "Make Jackrabbit compile on Java 7",
        "description": "Compiling on Java 7 fails with the following error:\n\n    jackrabbit-core/src/main/java/org/apache/jackrabbit/core/util/db/DataSourceWrapper.java:[30,7] error:\n    DataSourceWrapper is not abstract and does not override abstract method getParentLogger() in CommonDataSource\n\nWe should fix that.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-918",
        "summary": "Avoid INFINITE RECURSION when Object Model has cycles.",
        "description": "The default ObjectConverterImpl is restricted to acyclic graphs in the object model.\n\nMany Java object models are NOT acyclic.   For instance, I am on your Friends list.   Yoar are on my Friends list.     Java encourages such structures.   Almost any large object model in Java will have hidden cycles.\n\nSaving an Object Model that contains cycles using Graffito causes an infinite recursion.\n\nClearly, it is important to maintain a 1-to-1 correspondence between Nodes and Objects to prevent this.   In the absence of Multiple Parent Nodes, it will be necessary to use REFERENCE or UNDEFINED Items in place of the 2nd (or greater) Node representing a given Object.   My preference si that the default ObjectConverterImpl should support REFERENCE.,    Failing this, use of UNDEFINED also solves this problem and would  acceptable (as default).  Whether or not REFERENCE is used, both insertion and retrieval must provide a reasonable result.   A custom ojbect converter should be available to switch UNDEFINED to REFERENCE, or vice versa.\n\nAlso, it is probably best to keep the targeted, well-defined Nodes close to the Root Node.    This implies that the default ObjectConverterImpl should implement a Breadth-First, rather than a Depth-First, traversal of the Object Model on both insertion and retrieval.   Again, if the default is Depth-First, a custom object converter should be available that implements Breadth-First.\n\nAdmittedly, support for (2 representations) X (2 traversals) implies a drastic refactoring and/or rewriting of the ObjectConverterImpl class.",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-1289",
        "summary": "Error reporting page for jackrabbit-webapp",
        "description": "The Jackrabbit webapp should have an error reporting page that would help users collect all relevant environment and log information for inclusion in bug reports.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1688",
        "summary": "Query parser builds invalid parse tree",
        "description": "Calling org.apache.jackrabbit.spi.commons.query.QueryParser.parse on \n\nSELECT prop1 FROM nt:unstructured WHERE prop1 IS NOT NULL ORDER BY prop1 ASC \n\nresults in the following parse tree\n\n+ Select properties: {}prop1\n + PathQueryNode\n   + LocationStepQueryNode:  NodeTest=* Descendants=true Index=NONE\n     + RelationQueryNode: Op: NOT NULL Prop=@{}prop1 Type=STRING Value=%\n     + NodeTypeQueryNode:  Prop={http://www.jcp.org/jcr/1.0}primaryType Value={http://www.jcp.org/jcr/nt/1.0}unstructured\n + OrderQueryNode\n   {}prop1 asc=true\n\nThe RelationQueryNode should not have a second operand since the NOT NULL operator is unary.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2199",
        "summary": "Improvements to user management",
        "description": "Container issue for various improvements needed for the user management implementation in jr-core.\n\nKnown improvements are:\n\n- extensibility\n- current structuring of users/groups in the JCR content doesn't allow for easy finding user/group by ID.\n- groupID should be unescaped before being returned by getID",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2922",
        "summary": "JcrParser: use of bitwise instead of logical AND operator",
        "description": "JcrParser, line 134:\n\n            if ((!insideSingleQuote & !insideDoubleQuote & Character\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1025",
        "summary": "Node Type Management subproject : Default namespace should be emtpy",
        "description": "When creating node types matching to the class descriptors,  the default namespace should be empty instead of  'ocm'.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2215",
        "summary": "SPI2DAVex: HttpClient StringPart uses charset US-ASCII by default",
        "description": "if the diff is sent as multipart instead of a urlencoded post string properties may be garbeled.\nreason: instances of httpclient StringPart are created without specifying the charset in which case US-ASCII is used by default.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-18",
        "summary": "Multithreading issue with versioning",
        "description": "In a multithreading environment with two or more threads accessing the same version history, inconsistent state may be encountered. Concretely, the first thread is currently checking in the node to which the version history is attached while the second thread walks this same version history by means of a \"self-built\" iterator, which just accesses the successors of each version to get the \"next\" to visit.\n\nAt a certain point the second point may encounter an ItemNotFoundException with a stack trace similar to this:\n\njavax.jcr.ItemNotFoundException: c9bd405b-dff4-46ef-845c-d98e073e473a\n        at org.apache.jackrabbit.core.ItemManager.createItemInstance(ItemManager.java:354)\n        at org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:230)\n        at org.apache.jackrabbit.core.SessionImpl.getNodeByUUID(SessionImpl.java:494)\n        at org.apache.jackrabbit.core.version.VersionImpl.getSuccessors(VersionImpl.java:86)\n        ....\n\nIt seems that the first thread has already filled the successor of the version, while the node is not yet accessible by the createItemInstance method.\n\nThis bug seems to not be enforcible, but it is easily reproducible.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-389",
        "summary": "WebDAV server should treat non-wellformed XML in request bodies as error",
        "description": "The WebDAV server should treat non-wellformed XML request bodies as errors (instead of treating the request as if the request body was missing).\n\n(causes Litmus test suite failure in test case propfind_invalid)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-946",
        "summary": "Create a sample search page",
        "description": "The web application should have a search page that shows how to use the query features in jackrabbit.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2961",
        "summary": "Improve logging of Session.save() to trace back root cause of externally modified nodes",
        "description": "Currently it's very difficult to find the root cause of error like: javax.jcr.InvalidItemStateException: <UUID> has been modified externally.\n\nTo better trace back such issues, it would be nice to add DEBUG logging for the Session.save() call.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "RFE"
    },
    {
        "key": "JCR-2265",
        "summary": "AbstractReadableRepositoryService should pass credentials to createSessionInfo",
        "description": "Currently AbstractReadableRepositoryService.obtain() calls checkCredentials() followed by createSessionInfo() where it only passes the userId rather than the credentials. In many cases an implementation will need the credentials to create the SessionInfo. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2741",
        "summary": "Improved logging for session operations",
        "description": "I'd like to add the following logging features to SessionOperations:\n\n* Use MDC [1] to make it possible to filter and redirect logs based on which session is being used\n* Add simple debug-level timing information for executed SessionOperations to help pinpoint performance issues\n* Classify SessionOperations as read or write operations, and log warnings (instead of the current debug messages) for concurrent writes on a session\n\n[1] http://logback.qos.ch/manual/mdc.html",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-699",
        "summary": "Clustering: re-registration of nodetypes is not  synchronized",
        "description": "The re-registration of nodetypes is not yet synchronized between clusternodes, although re-registration is already (partially) implemented in the NodeTypeRegistry.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2458",
        "summary": "Allow basic regexp in namespace prefix of index-rule",
        "description": "Currently a regular expression is limited to the local name, which makes fallback declarations that should match everything else difficult to write. I.e. you have to write a line per namespace in the node type registry, which bloats the index-rule unnecessarily.\n\nCurrently:\n\n<property isRegexp=\"true\">.*</property>\n\nwill only match properties with the empty namespace URI.\n\nI propose we allow a basic regular expression in the prefix. That is the match all pattern: '.*' (dot star).\n\nThe following would match any property, including any namespace:\n\n<property isRegexp=\"true\">.*:.*</property>\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-563",
        "summary": "encode/decode",
        "description": "As I mention in my email executing <code>ISO9075.decode(\"StringWith$inside\")</code> leads to exception:\njava.lang.StringIndexOutOfBoundsException: String index out of range: 1\n\tat java.lang.String.charAt(String.java:444)\n\tat java.util.regex.Matcher.appendReplacement(Matcher.java:559)\n\tat com.day.crx.domino.util.NameEncoderDecoder.decode(NameEncoderDecoder.java:117)\n\tat integration.query.QueryTest.testQuery(QueryTest.java:49)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\n\nThe problem is in Matcher.appendReplacement() method, because it didn't correctly interpret '$' and '\\' sign. Both have to be escaped with '\\' sign.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1466",
        "summary": "ConfigurationException constructors are package private",
        "description": "ConfigurationException constructors are package private which prevents reusing them in other packages. eg. when extending the configuration.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "BUG"
    },
    {
        "key": "JCR-44",
        "summary": "Overwriting a reference property with different type corrupts rep",
        "description": "- create node n1\n- create node n2\n- n2.setProperty(\"prop\", n1)\n- save()\n- n2.setProperty(\"prop\", \"hello, world.\")\n- save()\n- n1.remove()\n- save() --> exception\n\nsee also ReferencesTest case\n\nbtw: removing the property or overwriting with a different reference works.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1333",
        "summary": "jackrabbit-jcr-rmi: Supplied javax.transaction.xa.Xid is assumed serializable, but is not on some environments.",
        "description": "Websphere provides a non-serializable javax.transaction.xa.Xid implementation, causing ClientXAResource to fail with NotSerializableException when passing Xid over RMI.\nI have worked around this by converting the supplied Xid to a local serializable Xid implementation that takes the supplied Xid parameters, and implements hashCode() and equals() correctly:\n\n    private static class SerializableXID implements javax.transaction.xa.Xid, Serializable {\n    \t/**\n\t\t * Serial version ID\n\t\t */\n\t\tprivate static final long serialVersionUID = -1390620315181450507L;\n\t\t\n\t\tprivate final byte[] branchQualifier;\n    \tprivate final byte[] globalTransactionId;\n    \tprivate final int formatId;\n    \tprivate final int hashCode;\n   \t\n    \tpublic SerializableXID(Xid xid) {\n    \t\tbranchQualifier = xid.getBranchQualifier();\n    \t\tglobalTransactionId = xid.getGlobalTransactionId();\n    \t\tformatId = xid.getFormatId();\n    \t\thashCode = xid.hashCode();\n    \t}\n\n\t\tpublic byte[] getBranchQualifier() {\n\t\t\treturn branchQualifier;\n\t\t}\n\n\t\tpublic int getFormatId() {\n\t\t\treturn formatId;\n\t\t}\n\n\t\tpublic byte[] getGlobalTransactionId() {\n\t\t\treturn globalTransactionId;\n\t\t}\n\n        public final int hashCode() {\n        \treturn hashCode;\n        }\n        \n        public final boolean equals(Object obj) {\n\t        if(obj == this) {\n\t            return true;\n\t        }\n\t        \n        \tif(!(obj instanceof Xid)) {\n        \t\treturn false;        \t\t\n        \t}\n        \t\n        \tXid xidimpl = (Xid)obj;\n        \tif(formatId != xidimpl.getFormatId()) {\n        \t\treturn false;\n        \t}\n\t        else {\n\t            return Arrays.equals(branchQualifier, xidimpl.getBranchQualifier())\n\t            \t&& Arrays.equals(globalTransactionId, xidimpl.getGlobalTransactionId());\n\t        }\n    \t}\n    }\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-832",
        "summary": "BundleDBPersistenceManager does not free blobStore resources",
        "description": "When removing binary property from node or removing node containing binary property, resources occupied by binary property are not freed (orphaned records remains in associated ${schemaObjectPrefix}BINVAL table).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-516",
        "summary": "remove dependencies of XPathQueryBuilder on core Jackrabbit code",
        "description": "The XPath query parser currently has a single dependency on SearchManager, for the sole purpose of importing two namespace URIs (for XML Schema and XPath 2.0 functions). This makes it harder than it should be to use it stand-alone.\n\nI propose to copy the two namespace URIs into XPathQueryBuilder, getting rid of the dependency.\n\n",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-457",
        "summary": "Path returned by FileSystemBLOBStore.createId() is not absolute",
        "description": "Hi,\n\nI have developed my own FileSystem in which I call FileSystemPathUtil.checkFormat(path) for every operation on the file system.\nWhen the file system is called to store a BLOB value, the path I get is always relative, resulting in a \"not an absolute path\" FileSystemException.\n\nThe problem has been traced back to org.apache.jackrabbit.core.state.util.FileSystemBLOBStore.creatId().\nI think there should be a:\n   sb.append(FileSystem.SEPARATOR_CHAR);\nbefore the for loop.\n\nThanks.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3052",
        "summary": "spi2dav: avoid reusing the same document in repositoryserviceimpl",
        "description": "... instead each call should create it's own document (credits due to jukka :)\nthat seems to avoid that odd npe in DomUtil.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2478",
        "summary": "Improve logging in LazyItemIterator#prefetchNext ",
        "description": "When LazyItemIterator#prefetchNext fails an item it should spell out the name of that item in  the respective log message. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2811",
        "summary": "Allow to override LockManager creation",
        "description": "Currently, Repository.getLockManager() internally creates a new lock manager if needed.\n\nJackrabbit should provide an extension point so that a JCR repository that extends it can create a custom lock manager.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2134",
        "summary": "Data Store: enable and fix tests",
        "description": "Currently the unit test TestTwoGetStreams fails in the trunk (it worked in older versions). This should be fixed. \n\nAlso, the data store is disabled by default, so this test doesn't run by default. The data store should be enabled for testing.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-220",
        "summary": "Make it possible to configure Lucene Analyzer for SearchIndex",
        "description": "Jackrabbit does not support the specification of a Lucene analyzer class (org.apache.lucene.analysis.Analyzer) to be used by a SearchIndex (or other Lucene based indices) declared in an XML configuration file. Custom analyzer is useful for indexing language specific content.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1990",
        "summary": "Optimize queries with relative path in order by clause",
        "description": "This is a follow up to JCR-800 and adds a way to configure relative property paths for aggregates in the indexing configuration. Aggregated properties are handled much more efficiently when used in an order by. The implementation from JCR-800 is used as a fallback when no aggregate is configured. See attached patch for details.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2500",
        "summary": "spi2davex NodeInfoImpl should use HashSet instead of ArrayList for childInfos",
        "description": "The subsequent contains call is prohibitively expensive since it returns in an equals call for all existing child infos. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2962",
        "summary": "InputStream not being explicitly closed",
        "description": "After deploying a j2ee artifact that uses jackrabbit and org.apache.jackrabbit.core.persistence.pool.MySqlPersistenceManager, Glassfish starts complaining there are input streams without being explicitly closed.\nThe specific inputStream mey be found at org.apache.jackrabbit.core.persistence.pool.BundleDbPersistenceManager.createCheckSchemaOperation(BundleDbPersistenceManager.java:584).\n\nI've checked the code and in BundleDbPersistenceManager:530 the run method is invoked to the object CheckSchemaOperation.\nIn run method CheckSchemaOperation:78, the finally block that calls IOUtils.closeQuietly(ddl); to close the stream is inside the condition if (!conHelper.tableExists(table)) (CheckSchemaOperation:79).\nSo, if this condition is false, the inputStream will not be explicitly closed.\n\nIn my opinion, there are two fix alternatives:\nThe most robust should be:\n1 - insert a finalize() method:\n    @Override\n    protected void finalize() throws Throwable {\n\t    if (ddl!=null){\n            IOUtils.closeQuietly(ddl);\n\t    }\n\t\tsuper.finalize();\n\t}\n\nAnother alternative:\n2 - Put the condition if (!conHelper.tableExists(table)) inside try-finally block.\n\n\nStackTrace:\n[#|2011-05-05T11:43:28.087-0300|WARNING|glassfish3.1|javax.enterprise.system.core.classloading.com.sun.enterprise.loader|_ThreadID=1233;_ThreadName=Thread-1;|Input stream has been finalized or forced closed without being explicitly closed; stream instantiation reported in following stack trace\njava.lang.Throwable\n        at com.sun.enterprise.loader.ASURLClassLoader$SentinelInputStream.<init>(ASURLClassLoader.java:1230)\n        at com.sun.enterprise.loader.ASURLClassLoader$InternalJarURLConnection.getInputStream(ASURLClassLoader.java:1338)\n        at java.net.URL.openStream(URL.java:1010)\n        at java.lang.ClassLoader.getResourceAsStream(ClassLoader.java:1195)\n        at com.sun.enterprise.loader.ASURLClassLoader.getResourceAsStream(ASURLClassLoader.java:872)\n        at java.lang.Class.getResourceAsStream(Class.java:2030)\n        at org.apache.jackrabbit.core.persistence.pool.BundleDbPersistenceManager.createCheckSchemaOperation(BundleDbPersistenceManager.java:584)\n        at org.apache.jackrabbit.core.persistence.pool.BundleDbPersistenceManager.init(BundleDbPersistenceManager.java:530)\n        at org.apache.jackrabbit.core.persistence.pool.MySqlPersistenceManager.init(MySqlPersistenceManager.java:51)\n        at org.apache.jackrabbit.core.RepositoryImpl.createPersistenceManager(RepositoryImpl.java:1353)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-336",
        "summary": "Concurrent locking operations fail",
        "description": "I prepared simple test which tries to lock/unlock single node from many\nthreads. I expected only LockExceptions thrown by some threads which can\noccur if node is already locked by other thread.\n\nBut I get incorrect effect sporadically. It looks like some thread\nmanaged to acquire lock, but then can't release it.\n\nFollowing exception is thrown then :\n\njavax.jcr.InvalidItemStateException:\n7c198c7b-76c8-47c8-96a8-d9dfefd4b387 has been modified externally\n    at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1193)\n    at org.apache.jackrabbit.core.NodeImpl.unlock(NodeImpl.java:3790)\n    at JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:95)\n\nadditionally warning appears in log\n\norg.apache.jackrabbit.core.lock.LockManagerImpl$LockInfo.loggingOut(LockManagerImpl.java:892)\n- Unable to unlock session-scoped lock on node\n'7c198c7b-76c8-47c8-96a8-d9dfefd4b387-W': Unable to unlock node. Node\nhas pending changes: /folder\n\nIn consequence node is left in locked state. It looks like a bug.\nIf one thread locked node successfully, then none other can modify it,\nand the same thread should release lock without any problems.\n\nShouldn't be lock operation atomic itself ?\n\nPrzemo\n\n\npackage com.oyster.mom.contentserver.jcr.transaction;\n\nimport javax.jcr.Node;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.SimpleCredentials;\nimport javax.jcr.lock.LockException;\n\nimport org.apache.jackrabbit.core.RepositoryImpl;\nimport org.apache.jackrabbit.core.config.RepositoryConfig;\n\npublic class JrTestConcurrentLocks extends Thread {\n\n   private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(JrTestConcurrentLocks.class);\n\n   public static String REPOSITORY_HOME = \"d:/repo/jackrabbit/\";\n\n   public static String REPOSITORY_CONFIG = REPOSITORY_HOME + \"repository.xml\";\n\n   public static void main(String[] args) throws Exception {\n\n       JrTestConcurrentLocks test = new JrTestConcurrentLocks(-1);\n       test.startup();\n\n       JrTestConcurrentLocks tests[] = new JrTestConcurrentLocks[3];\n\n       for (int i = 0; i < tests.length; i++) {\n           JrTestConcurrentLocks x = new JrTestConcurrentLocks(i);\n           x.setSession(repository.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray())));\n           x.start();\n           tests[i] = x;\n       }\n\n       for (int i = 0; i < tests.length; i++) {\n           tests[i].join();\n           tests[i].getSession().logout();\n       }\n\n       test.shutdown();\n   }\n\n   private static RepositoryImpl repository;\n\n   private int id;\n\n   private Session session;\n\n   public void setSession(Session session) {\n       this.session = session;\n   }\n\n   public Session getSession() {\n       return this.session;\n   }\n\n   public JrTestConcurrentLocks(int i) {\n       this.id = i;\n   }\n\n   public void startup() throws Exception {\n       System.setProperty(\"java.security.auth.login.config\", \"c:/jaas.config\");\n\n       RepositoryConfig config = RepositoryConfig.create(REPOSITORY_CONFIG, REPOSITORY_HOME);\n       repository = RepositoryImpl.create(config);\n\n       Session session = repository.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray()));\n       Node rootNode = session.getRootNode();\n       if (!rootNode.hasNode(\"folder\")) {\n           Node folder = rootNode.addNode(\"folder\");\n           folder.addMixin(\"mix:versionable\");\n           folder.addMixin(\"mix:lockable\");\n           rootNode.save();\n       }\n       session.logout();\n   }\n\n   public void shutdown() throws RepositoryException {\n       repository.shutdown();\n   }\n\n   public Node getFolder(Session session) throws RepositoryException {\n       return session.getRootNode().getNode(\"folder\");\n   }\n\n   public void run() {\n\n       for (int i = 0; i < 10; i++) {\n           log.info(\"START id:\" + id + \", i=\" + i);\n\n           try {\n               session.refresh(false);\n\n               Node folder = getFolder(session);\n               folder.lock(false, true);\n               folder.unlock();\n\n               log.info(\"SUCCESS id:\" + id + \", i=\" + i);\n           }\n           catch (LockException e) {\n               log.info(\"FAIL:\" + id + \", i=\" + i);\n           }\n           catch (Exception e) {\n               log.warn(\"ERROR:\" + id + \", i=\" + i, e);\n           }\n\n\n       }\n\n   }\n}\n\n\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=0\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=0\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=0\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=0\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=1\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=1\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=0\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=1\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=1\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=2\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=2\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=3\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=3\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=4\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=2\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=2\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=3\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=3\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=4\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=4\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=5\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:97) - SUCCESS id:1, i=4\n15:46:17 WARN  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:103) - ERROR:0, i=5\njavax.jcr.ItemNotFoundException: 7c198c7b-76c8-47c8-96a8-d9dfefd4b387/{http://www.jcp.org/jcr/1.0}lockOwner\n       at org.apache.jackrabbit.core.ItemManager.createItemInstance(ItemManager.java:463)\n       at org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:319)\n       at org.apache.jackrabbit.core.NodeImpl.getProperty(NodeImpl.java:1436)\n       at org.apache.jackrabbit.core.NodeImpl.getOrCreateProperty(NodeImpl.java:428)\n       at org.apache.jackrabbit.core.NodeImpl.internalSetProperty(NodeImpl.java:1267)\n       at org.apache.jackrabbit.core.NodeImpl.lock(NodeImpl.java:3740)\n       at JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:94)\n15:46:17 WARN  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:103) - ERROR:2, i=0\njavax.jcr.InvalidItemStateException: 7c198c7b-76c8-47c8-96a8-d9dfefd4b387 has been modified externally\n       at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1193)\n       at org.apache.jackrabbit.core.NodeImpl.unlock(NodeImpl.java:3790)\n       at JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:95)\n15:46:17 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=5\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=6\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=1\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=5\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=6\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=1\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=6\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=7\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=2\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=6\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=7\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=2\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=7\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=8\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=3\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=7\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=8\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=3\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=8\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:0, i=9\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=4\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:1, i=8\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:0, i=9\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=4\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:1, i=9\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=5\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=5\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=6\n15:46:18 WARN  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:103) - ERROR:1, i=9\njavax.jcr.InvalidItemStateException: /folder: the node cannot be saved because it has been modified externally.\n       at org.apache.jackrabbit.core.NodeImpl.makePersistent(NodeImpl.java:908)\n       at org.apache.jackrabbit.core.ItemImpl.persistTransientItems(ItemImpl.java:682)\n       at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1173)\n       at org.apache.jackrabbit.core.NodeImpl.lock(NodeImpl.java:3744)\n       at JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:94)\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=6\n15:46:18 WARN  org.apache.jackrabbit.core.lock.LockManagerImpl$LockInfo.loggingOut(LockManagerImpl.java:892) - Unable to unlock session-scoped lock on node '7c198c7b-76c8-47c8-96a8-d9dfefd4b387-W': Unable to unlock node. Node has pending changes: /folder\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=7\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=7\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=8\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=8\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:88) - START id:2, i=9\n15:46:18 INFO  JrTestConcurrentLocks.run(JrTestConcurrentLocks.java:100) - FAIL:2, i=9\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1543",
        "summary": "Improve reliability of canAddMixin",
        "description": "The current implementation of canAddMixin in JCR2SPI lacks flexibility. It only consults the (SPI) node type registry, checking for (1) whether the mixin exists, and (2) whether it is already present and (3) whether it's consistent with the node's type.\n\nThis is fine for stores where any legal mixin can be added anywhere. It doesn't work well for stores that are limited in what they can do; for instance when nt:file nodes can be made mix:versionable, but nt:folder nodes can't.\n\nProposal: enhance QNodeTypeDefinition with\n\n  public Name[] getSupportedMixins();\n\nwhere the return value is either null (no constraints or no constraints known), or a list of mixin types that are supported for this node type.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2195",
        "summary": "Provide possibility to import protected items using Session import functionality",
        "description": "SessionImporter and WorkspaceImporter currently skip all protected items encountered during import except for some special cases\n(see JCR-2172 and WorkspaceImporter#postProcessNode).\nThe specification only mandates that protected content is treated in a consistent manner, but allows the implementation to either import or ignore it.\n\nFind attached a patch containing some initials steps to allow to extend the default import behavior:\nInstead of skipping protected items (and in case of nodes the complete tree below it), they should be passed to a separate handler,\nthat may or may not be able to deal with them and needs to assert, that they are in a valid format.\n\nThe patch includes:\n\n- Abstract classes for that protected item import\n- Default implementations that never import protected nodes (same behavior as we have today)\n- An example implementation for the AC-content (just to see if it works for simple cases) + some trivial tests.\n- Changes to SessionImporter to demonstrate how import of protected items would be enabled.\n\nThe patch doesn't include yet:\n\n- Changes to WorkspaceImporter (would +- be according to SessionImporter)\n- Changes to WorkspaceImpl/SessionImpl as well as configuration that would allow to modify the default behavior.\n- Examples for import of protected properties.\n- Examples for workspace import.\n\nThe patch has the following limitations or TODOs:\n\n- Proper handling of protected references properties or non-protected ref properties with the tree defined by a protected node.\n- Test / Careful review if the various ImportUUIDBehaviors are/can properly be covered, specially in case of \"replace-existing\".\n\nThe patch in addition addresses:\n\n- An inconsistency in the SessionImporter:\n  > Attempt to import protected content below an existing protected node => skipped\n  > Attempt to import protected content that doesn't yet exist => first node is imported, ConstraintViolationException for child-nodes.\n  > This behavior is also reflected in the Node-stack... where in the first case 'null' is pushed, in the second case the first protected node.\n     (see also JCR-2172 for details).\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-359",
        "summary": "JCA project tests assume Windows paths",
        "description": "The org.apache.jackrabbit.jca package in the top-level jca directory has unit tests that assume a Windows environment. It should be fixed to work in any environment. The best solution may be to use a test repository configuration file in the current directory.\n\nThe following is the start of the test case failures that I got running on MacOS X.\n\nTestsuite: org.apache.jackrabbit.jca.test.ConnectionFactoryTest\nTests run: 3, Failures: 0, Errors: 3, Time elapsed: 0.778 sec\n\nTestcase: testAllocation(org.apache.jackrabbit.jca.test.ConnectionFactoryTest): Caused an ERROR\norg.apache.jackrabbit.core.config.ConfigurationException: Configuration file could not be read.: /Users/mark/Documents/school/whisper/jackrabbit/jackrabbit-trunk/jca/c:\\dev\\jcr\\repository.xml (N\no such file or directory): /Users/mark/Documents/school/whisper/jackrabbit/jackrabbit-trunk/jca/c:\\dev\\jcr\\repository.xml (No such file or directory)\norg.apache.jackrabbit.core.config.ConfigurationException: Configuration file could not be read.: /Users/mark/Documents/school/whisper/jackrabbit/jackrabbit-trunk/jca/c:\\dev\\jcr\\repository.xml (N\no such file or directory): /Users/mark/Documents/school/whisper/jackrabbit/jackrabbit-trunk/jca/c:\\dev\\jcr\\repository.xml (No such file or directory)\n        at org.apache.jackrabbit.jca.JCAManagedConnectionFactory.createRepository(JCAManagedConnectionFactory.java:278)\n        at org.apache.jackrabbit.jca.JCAManagedConnectionFactory.createConnectionFactory(JCAManagedConnectionFactory.java:116)\n        at org.apache.jackrabbit.jca.JCAManagedConnectionFactory.createConnectionFactory(JCAManagedConnectionFactory.java:108)\n        at org.apache.jackrabbit.jca.test.ConnectionFactoryTest.testAllocation(ConnectionFactoryTest.java:43)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-3224",
        "summary": "SystemSession#createSession should return SessionImpl again",
        "description": "a long with the fix of  JCR-2890 (revision 1089436) the behavior of SystemSession#createSession has changed to\nreturn a SystemSession instead of SessionImpl as it used to be.\n\nwhile i basically consider this move to be correct and the better way of dealing with that session-cloning\nmechanism as it prevents the user of this method to convert a SystemSession into a regular session\nfor extra writing operations (such as e.g. access control editing that is not supported with the\nsystem session to prevent chicken-egg-problems on repo startup).\n\ntherefore i would like to revert that change for the 2.4 release in order to prevent regressions.\n\nfor the time after 2.4 i would however suggest that we finally take the time to clearly define the\nusages, abilities and responsibilities of the system session and also review how and where we\nexpose them to the individual 'modules' of jackrabbit core..  i started working on this but decided\nthat this is definitely too risky for 2.4 whereas reverting the change mentioned above should\nimo impose very limited risk as all usages of those sessions i am aware of use them as \"Session\"\nor \"SesssionImpl\", most of them not even having access to the SystemSession class.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "BUG"
    },
    {
        "key": "JCR-1162",
        "summary": "Improve logging in NodeTypeRegistry.persistCustomNodeTypeDefs",
        "description": "When the closing of out in the finally block of persistCustomNodeTypeDefs throws an IOException this is ignored. At least some logging should take place, because an IOException here might still mean that the custom nodetype definitions were not stored correctly. This is the case, for instance, when a DatabaseFileSystem is used: the call to out.close triggers the SQL statement execution which causes an IOException if it fails. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-745",
        "summary": "TCK: more tests assuming that 'addMixin' immediately taking effect",
        "description": "jsr170 allows an implementation to have Node.addMixin only taking affect upon a save-call.\n\nsome tests already got adjusted.\nattached patch for additional tests, that make usage of addMixin",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-3030",
        "summary": "Permit using different tablespaces for tables and indexes with Oracle",
        "description": "OracleFileSystem, OraclePersistenceManager and OracleDatabaseJournal already provide a tableSpace parameter to customize the DDL, but the same tablespace is used for both tables and indexes. It is common place to use distinct tablespaces for these. Jackrabbit could provide support for this.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2780",
        "summary": "Best effort merge if concurrent modifications include changes to mixin types",
        "description": "currently the NodeStateMerger#merge method immediately aborts if the mixin types of the 2 nodes are not the same.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1988",
        "summary": "AbstractRecord does inefficient List.indexOf()",
        "description": "AbstractRecord keeps a list of already used UUIDs and references\nthem by index when used again in a record. Using a List does not\nscale well, when the record grows larger. e.g. a transaction of\n10k nodes takes more than a minute on my machine when the journal\nis enabled. Most of the time is spent doing List.indexOf() in\nAbstractRecord.getOrCreateIndex().",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-11",
        "summary": "XMLPersistenceManager incorrectly handles properties",
        "description": "JCR Property instances are written by the XMLPersistenceManager as java.util.Properties files and loaded through the loadPropertyState() method as Properties files. Unfortunately the reload() method tries to re-load the Property states from XML files, which is not possible.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-802",
        "summary": "Create a jackrabbit-site subproject",
        "description": "The Jackrabbit web site sources should be moved to a new \"jackrabbit-site\" subproject so that the top-level Jackrabbit POM would only be used for the multimodule build setup and generic project metadata. This way the web site could be built more easily without invoking all the subprojects, and Eclipse would also be happier since the site project wouldn't \"contain\" the other Jackrabbit modules.",
        "label": "NUG",
        "classified": "TASK",
        "type": "TASK"
    },
    {
        "key": "JCR-2716",
        "summary": "OracleDatabaseJournal should assume Oracle defaults",
        "description": "OracleFileSystem and OraclePersistenceManager assumes defaults for certain properties, such as driver and databaseType.  These defaults should be extended to OracleDatabaseJournal for consistency and ease of use.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3049",
        "summary": "NPE in ConsolidatingChangeLog for id base NodeId",
        "description": "ConsolidatingChangeLog does not guard guard against null in the path value of a NodeId. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1686",
        "summary": "Catch Throwables while calling TextExtractors",
        "description": "There are different Exception Handlings in the current TextExtractors.\nThe Method Signature throws IOException but the internal Handling is different.\n\nFor example in the MsExcelTextExtractor there will be RuntimeException's catched but not in all Extractors.\n@see JCR-574\n\nI think we should catch Throwables in the NodeIndexer to prevent OutOfMemoryErros while indexing a node.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-393",
        "summary": "WebDAV Library: VersionControlledResource constant lists wrong method",
        "description": "VersionControlledResource .methods_checkedIn constant lists UNCHECKOUT which is obviously\nwrong.\n\nRFC3253 lists the UNCHECKOUT method as mandatory method for checked-out vc-resource\nfor the 'checkout-in-place'  feature.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1304",
        "summary": "Support system properties in ${...} vars in XML config files",
        "description": "The variable replacement (${...}) in config files like repository.xml currently only allows for the special variables introduced by Jackrabbit, eg. ${wsp.name} or ${rep.home}. But it would be useful to support all java system properties here as it is some kind of a standard in Java XML config files (see Spring for an example).\n\nThis makes it easier to inject variables from outside the config file, eg. by setting them on the command line or injecting them programmatically in test cases. Typical parameters for that include database connection credentials, which one wants to avoid to put into repository.xml files that are often checked into SVN.\n\nThis is especially true for test cases, eg. I currently work on a persistence manager component and I want to include the repository.xml in the source tree (under applications/test) but without my specific credentials. These are applied by loading a user-specific properties file through the test case before the repository is started and the config is read.\n",
        "label": "NUG",
        "classified": "OTHER",
        "type": "RFE"
    },
    {
        "key": "JCR-1325",
        "summary": "Problems mapping custom collections",
        "description": "When using a custom list that extends from java.util.AbstractList, ManageableCollectionUtil.getManageableCollection raises a JcrMappingException because it does not consider the custom list to be a java.util.List. This is because it uses \"if (object.getClass().equals(List.class))\" instead of \"if (object instanceof List)\". The same thing will probably happen when using a custom Collection, a custom ArrayList, etc. This is the stack trace:\n\norg.apache.jackrabbit.ocm.exception.JcrMappingException: Unsupported collection \ntype : *********** (MyCustomList class) \n        at org.apache.jackrabbit.ocm.manager.collectionconverter.ManageableColle \nctionUtil.getManageableCollection(ManageableCollectionUtil.java:153) \n        at org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverte \nrImpl.insertCollectionFields(ObjectConverterImpl.java:780) \n        at org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverte \nrImpl.insert(ObjectConverterImpl.java:221) \n        at org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverte \nrImpl.insert(ObjectConverterImpl.java:146) \n        at org.apache.jackrabbit.ocm.manager.impl.ObjectContentManagerImpl.inser \nt(ObjectContentManagerImpl.java:407) \n\nI have come up to this bug using a MyCustomList<MyClass>, with MyCustomList extending java.util.AbstractList<MyClass>.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2181",
        "summary": "Faster packaging of the standalone jar",
        "description": "Currently the standalone jar is created by first unpacking all the dependencies to target/classes and then packaging the resulting directory tree into the resulting jar file. This takes quite a while as all the writing and reading of uncompressed class files requires lots of disk IO. We could avoid these extra copies by using the bundle or assembly plugin to build the standalone jar.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2784",
        "summary": "NodeStateMerger.merge should abort if the primary type of the 2 states to be compare are not the same",
        "description": "the NodeStateMerger#merge currently aborts if the mixin types of the passed state and its overlayed state are not equal.\nas of jsr 283 not the only the mixin types but also the primary type of a node can be modified.\n\nfor consistency reasons NodeStateMerger#merge should abort and return false if the primary types are not the same.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1020",
        "summary": "Use repository service wide namespace cache",
        "description": "The jcr2spi layer requests namespaces for each new session that is created. It should rather cache them and make them available to other sessions.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2764",
        "summary": "JackrabbitIndexReader prevents use of DocNumberCache",
        "description": "The JackrabbitIndexReader was introduced in 1.5 by JCR-1363. Unfortunately it does not overwrite the method termDocs(Term), which means the default implementation in IndexReader is used. This bypasses the DocNumberCache built into CachingIndexReader, which is used for UUID terms that look up individual documents.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-553",
        "summary": "problem in jcr-server/project.properties dependencies?",
        "description": "There seems to be a mismatch in the version numbers in the dependencies defined in jcr-server/project.properties. It refers to version 1.0, yet the other components are already at 1.1.\n\nThe attached patch solves the problem for me, but I don't claim to fully understand how this works...\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-207",
        "summary": "moving locked node removes locked state",
        "description": "when moving a locked node it looses it locked state.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1170",
        "summary": "Repository lock keeps file open",
        "description": "The RepositoryLock opens a RandomAccessFile, but does not close it. The problematic line is:\n\nlock = new RandomAccessFile(file, \"rw\").getChannel().tryLock();\n\nThis is usually not a problem as the file will be closed when the RandomAccessFile object is garbage collected. However, if called a lot in a short time frame, this results in 'too many open files' in some environments (for example Linux). ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1891",
        "summary": "jcr2spi: use Soft refs for hierarchy",
        "description": "stefan suggested to use soft refs for the hierarchy.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2182",
        "summary": "LockableFileRevision not thread-safe",
        "description": "LockableFileRevision works well across process boundaries, but does not within the same JVM. The methods lock() and unlock() must be synchronized similar to DatabaseRevision.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-981",
        "summary": "XPath relative path support missing for \"is null\" and \"is not null\"",
        "description": "I believe the change for issue JCR-247 is incomplete, for instance\n\n  //*[@x]\n\nand\n\n  //*[foo/@x]\n\nare parsed into the same query tree.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1246",
        "summary": "In DatabasePersistenceManager.store(), if the exception is null or its cause is not an SQLException, then the PM keeps looping forever",
        "description": "In the line\nif (ise != null && ise.getCause() instanceof SQLException && --trials > 0) {\nif one of the first two checks fails, the shortcircuit doesn't decrement trials.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-22",
        "summary": "DefaultItemStateProvider contains grow-only cache",
        "description": "The DefaultItemStateProvider class contains a private HashMap \"items\" which contains references to ItemState objects. The bad thing about this cache is, that it only grows, but is not being managed to forget about \"unused\" items.\n\nExample: A repository which is filled with 9350 nodes and 52813 properties grows this items map to 1'667'557 (!) entries. In this concrete case, the VM all13ates 213MB to the heap of which 57MB is referenced by the DefaultItemStateProvider.items map.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1097",
        "summary": "Move the XASession interface to jackrabbit-api",
        "description": "As discussed in JCR-953, it would probably make sense to move the org.apache.jackrabbit.core.XASession from jackrabbit-core to jackrabbit-api as org.apache.jackrabbit.api.XASession.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2417",
        "summary": "RepositoryException when using BindVariables in JCR-SQL2 CONTAINS",
        "description": "When using a BindVariable in a JCR-SQL2 CONTAINS constraint, the query fails with a RepositoryException.\n\nFor example:\n\nString sql = \"SELECT * FROM [nt:unstructured] WHERE ISCHILDNODE([/testroot]) AND CONTAINS(mytext, $searchExpression)\";\nQuery q = superuser.getWorkspace().getQueryManager().createQuery(sql, Query.JCR_SQL2);\nq.bindValue(\"searchExpression\", superuser.getValueFactory().createValue(\"fox\"));\nq.execute();\n\nResults in:\n\njavax.jcr.RepositoryException: Unknown static operand type: org.apache.jackrabbit.spi.commons.query.qom.BindVariableValueImpl@591a4d\n        at org.apache.jackrabbit.core.query.lucene.LuceneQueryFactoryImpl.create(LuceneQueryFactoryImpl.java:215)\n        at org.apache.jackrabbit.core.query.lucene.constraint.FullTextConstraint.<init>(FullTextConstraint.java:42)\n        at org.apache.jackrabbit.core.query.lucene.constraint.ConstraintBuilder$Visitor.visit(ConstraintBuilder.java:175)\n        at org.apache.jackrabbit.spi.commons.query.qom.FullTextSearchImpl.accept(FullTextSearchImpl.java:117)\n        at org.apache.jackrabbit.core.query.lucene.constraint.ConstraintBuilder$Visitor.visit(ConstraintBuilder.java:137)\n        at org.apache.jackrabbit.spi.commons.query.qom.AndImpl.accept(AndImpl.java:72)\n        at org.apache.jackrabbit.core.query.lucene.constraint.ConstraintBuilder.create(ConstraintBuilder.java:82)\n        at org.apache.jackrabbit.core.query.lucene.QueryObjectModelImpl.execute(QueryObjectModelImpl.java:109)\n        at org.apache.jackrabbit.core.query.QueryImpl.execute(QueryImpl.java:127)\n\nI tried to fix this issue but there is no way to access the BindVariables from the ConstraintBuilder from the LuceneQueryFactoryImpl and the ConstraintBuilder just passes the FullTextSearchImpl QOM subtree to the factory (via FullTextConstraint constructor) without any further visiting. If the signature would be \"LuceneQueryFactoryImpl#create(FullTextSearchImpl fts, Value searchExpression)\" we could visit the StaticOperand in the ConstraintBuilder and then modify the FullTextSearchImpl constructor accordingly, but this would imply that LuceneQueryFactory interface would need to be change accordingly and I don't know what that would mean.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1078",
        "summary": "ChangeLog serialization causes cache inconsistencies",
        "description": "The ordering of actions is taken into account when a ChangeLog is built through session manipulations (see, for instance,  ChangeLog.deleted(ItemState state)). When it is serialized in ClusterNode.write(Record record, ChangeLog changeLog, EventStateCollection esc), however, this implicit ordering might be changed. As a consequence,  the deserialization in ClusterNode.consume(Record record) might produce a different ChangeLog with the effect that the local caches get out-of-sync with the persistent state of the repository.\n\nThe issue should be reproducable as follows:\n- Setup a clustered environment with two Jackrabbit instances, say A and B.\n- On instance A add a property \"P\" with value \"x\" to some node and save the session.\n- On instance B read property \"P\" -> it will have value \"x\".\n- On instance A delete property P and then add it again with value \"y\" and save the session.\n- On instance B read property \"P\" -> it will still have value \"x\" after the cluster sync...",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2473",
        "summary": "Cloning a tree containing shareable nodes into another workspace throws ItemExistsException",
        "description": "There's a problem when trying to clone a tree in another workspace, when this tree contains shareable nodes.\n\nLet ws1 be one workspace, which contains one node A. This node has two sub-nodes B and C. B and C share a shareable sub-node D :\n\nA \n|   \\\nB  C\n|    |\nD  D\n\nLet ws2 be a second workspace. Then calling ws2.clone(\"ws1\" , \"/A\" , \"/A\" , false) throws an ItemExistsException ( copyNodeState line 1628 ) . This is done when the copyNodeState is checking if the nodeId is already present in the workspace - which is the case when copying the second instance of the shareable node. I can't find in the specification something about this case - but it would be logical to add a share to the node when coming across this situation - at least in the CLONE ( and probable COPY too ) cases. I don't know what would be expected in the CLONE_REMOVE_EXISTING case - we might not want to remove the node if it's shareable, and also add a share here.\n\nI fixed the issue by handling the case the node is shareable in the COPY and CLONE cases of copyNodeState - you'll find attached the corresponding patch. Do you think this solution is ok ?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1469",
        "summary": "Data store garbage collection: ScanEventListener not working",
        "description": "The ScanEventListener is currently only called when using the 'scan all nodes recursively' strategy. It is not called when all persistence managers implement IterablePersistenceManager (GarbageCollector.scanPersistenceManagers). The ScanEventListener should be called in every case, otherwise it is not possible to see the progress of the garbage collection.\n\nHowever there is a problem: IterablePersistenceManager.getAllNodeIds() doesn't return Node objects, and it would make little sense to create real node objects (the performance advantage of scanPersistenceManagers would be lost).\n\nTherefore, I propose a workaround: the ScanEventListener is called using a 'PseudoNode'. This is a class that implements Node but only has meaningful getUUID() and toString() methods. This allows to create a meaningful progress bar (as the UUIDs are returned in order).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1565",
        "summary": "JSR 283 lifecycle management",
        "description": "JSR 283 specifies a simple lifecycle management mechanism for nodes, and as the reference implementation we should implement that feature. We also need to implement the related TCK tests.\n\nThis feature introduces a few new API methods, but during Jackrabbit 1.x we can just introduce them as custom jsr-283 API extensions.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-652",
        "summary": "NodeCanAddMixinTest.testCheckedIn() has wrong option check",
        "description": "NodeCanAddMixinTest.testCheckedIn() checks for locking option instead of versioning option.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2487",
        "summary": "WorkspaceItemStateFactory#createItemStates throws ClassCastException",
        "description": "When the first item in the ItemInfo iterator returned by the RepositoryService is a PropertyInfo instead a NodeInfo, a ClassCastException is thrown. This should rather be a ItemNotFoundException.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1608",
        "summary": "JSR 283: Workspace Management",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1213",
        "summary": "UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader ",
        "description": "Queries that use ChildAxisQuery or DescendantSelfAxisQuery make use of getParent() functions to know wether the parents are correct and if the result is allowed. The getParent() is called recursively for every hit, and can become very expensive. Hence, in DocId.UUIDDocId, the parents are cached. \n\nCurrently,  docId.UUIDDocId's are cached by having a WeakRefence to the CombinedIndexReader, but, this CombinedIndexReader is recreated all the time, implying that a gc() is allowed to remove the 'expensive' cache.\n\nA much better solution is to not have a weakReference to the CombinedIndexReader, but to a reference of each indexreader segment. This means, that in getParent(int n) in SearchIndex the return \n\nreturn id.getDocumentNumber(this) needs to be replaced by return id.getDocumentNumber(subReaders[i]); and something similar in CachingMultiReader. \n\nThat is all. Obviously, when a node/property is added/removed/changed, some parts of the cached DocId.UUIDDocId will be invalid, but mainly small indexes are updated frequently, which obviously are less expensive to recompute.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-390",
        "summary": "Move text extraction into a background thread",
        "description": "Even though text extraction is not done right on save() most of the extraction work is later done by a client thread. There is a mechanism in place that commits the deferred work in a background thread. But the background thread is only triggered by a timer and does not constantly write back pending index changes. For regular index changes this is done on purpose and should not be changed. However text extraction work should be moved completely into a background thread because it often takes a fair amount of time to index a large document.\n\nOutline of a possible solution:\n- all text filtering is tasks are put into a work queue\n- the work queue is processed by a background thread\n- basic indexing of nt:resource without text filtering takes place\n- the background thread updates the index when text filtering completed for a nt:resource\n\nThere should be a configuration parameter that allows to execute text filtering without the background thread. This way it is possible to get the existing behaviour of Jackrabbit: the fulltext index is always up-to-date and can be used.\nWith the background process this is no longer the case.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3076",
        "summary": "Mandatory authentication prevents webdav client connections",
        "description": "As seen on the mailing list:\n\njava -jar target/jackrabbit-standalone-2.3-SNAPSHOT.jar --cli http://localhost:8080\nException in thread \"main\" javax.jcr.RepositoryException: Unable to access a repository with the following settings:\n   org.apache.jackrabbit.repository.uri: http://localhost:8080\nThe following RepositoryFactory classes were consulted:\n   org.apache.jackrabbit.jcr2dav.Jcr2davRepositoryFactory: declined\n   org.apache.jackrabbit.jcr2spi.Jcr2spiRepositoryFactory: declined\n   org.apache.jackrabbit.commons.JndiRepositoryFactory: declined\n   org.apache.jackrabbit.core.RepositoryFactoryImpl: declined\n   org.apache.jackrabbit.rmi.repository.RmiRepositoryFactory: failed\n       because of RepositoryException: Failed to read the resource at URL http://localhost:8080\n       because of IOException: Server returned HTTP response code: 401 for URL: http://localhost:8080\nPerhaps the repository you are trying to access is not available at the moment.\n       at org.apache.jackrabbit.commons.JcrUtils.getRepository(JcrUtils.java:216)\n       at org.apache.jackrabbit.commons.JcrUtils.getRepository(JcrUtils.java:256)\n       at org.apache.jackrabbit.standalone.Main.run(Main.java:127)\n       at org.apache.jackrabbit.standalone.Main.main(Main.java:61)",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1375",
        "summary": "Limit fields read from index",
        "description": "Reading a lucene document from the index should be limited to only those fields that are necessary.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1904",
        "summary": "JSR 283: Event user data",
        "description": "Implement JSR 283 Event user data.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2243",
        "summary": "Automatic upgrade to 2.0",
        "description": "Jackrabbit 2.0 contains some changes that are not compatible with repositories created with earlier versions. It would be nice if Jackrabbit would automatically detect and upgrade repositories created with 1.x versions.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-886",
        "summary": "Index recovery may fail with IllegalArgumentException",
        "description": "When repeatedly killed and started up again, jackrabbit may throw an IllegalArgumentException on index recovery:\n\nCaused by: java.lang.IllegalArgumentException: already contains: _c\n   at org.apache.jackrabbit.core.query.lucene.IndexInfos.addName(IndexInfos.java:170)\n   at org.apache.jackrabbit.core.query.lucene.MultiIndex.deleteIndex(MultiIndex.java:716)\n   at org.apache.jackrabbit.core.query.lucene.MultiIndex$DeleteIndex.execute(MultiIndex.java:1553)\n   at org.apache.jackrabbit.core.query.lucene.MultiIndex.executeAndLog(MultiIndex.java:809)\n   at org.apache.jackrabbit.core.query.lucene.MultiIndex.flush(MultiIndex.java:740)\n   at org.apache.jackrabbit.core.query.lucene.Recovery.run(Recovery.java:160)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2472",
        "summary": "spi2dav: Accessing moved referenceble nodes results in PathNotFoundException",
        "description": "the following code fragment causes a PathNotFoundException on an existing path\nand there seems to be no way to recover the session from this incorrect state:\n\n\t// assuming an existing nt:file node at path /apps/foo/bar.txt\n\tNode n1 = session.getNode(\"/apps/foo/bar.txt\");\n\tNode n2 = n1.getNode(\"jcr:content\");\n\tn2.setProperty(\"jcr:data\", new java.io.ByteArrayInputStream(((String)(\"blahblah\")).getBytes()));\n\tn2.save();\n\tWorkspace ws0 = session.getWorkspace();\n\tws0.move(\"/apps/foo\", \"/apps/foo1\");\n\tNode n3 = session.getNode(\"/apps/foo1/bar.txt\");\n\tNode n4 = n3.getNode(\"jcr:content\");\n\tn4.refresh(false);\n\tNode n5 = n3.getNode(\"jcr:content\");     // => PathNotFoundException\n\nPlease note that the preceeding Node.refresh() call seems to cause the inconsistency.\nthe problem doesn't occur when omitting this call.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2688",
        "summary": "Provide utility for handling large number of child nodes/properties",
        "description": "Jackrabbit does not cope well with 'flat' hierarchies. That is with hierarchies where a node has many child nodes and/or properties. The current recommendation for such situations is to manually add intermediate nodes. \n\nIt would be nice to have an utility which adds/removes intermediate nodes as needed and expose a 'flat' view to users. Such an utility should:\n\n- expose a large number of nodes/properties as sequence\n- parametrize the order of how nodes/properties appear in the sequence\n- provide methods to lookup/add/remove nodes/properties by key \n- organize the node/properties in the underlying JCR hierarchy in a way which is both efficient for above operations and easily understandable to users looking at the hierarchy. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-594",
        "summary": "It's not possible to register event listeners that filters on mixin supertypes",
        "description": "The current implementation of blocks() in EventFilter does not check if the given EventState has a mixin that is derived from one of the given node types.",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-1800",
        "summary": "JCR2SPI: lockmgr isn't aware about external unlock (CacheBehavior.OBSERVATION)",
        "description": "issue occurring with CacheBehavior.OBSERVATION only:\n\nthe lock manager expects the jcr:lockIsDeep property to be created upon successful lock.\nthis however isn't the case since the time, we changed the Operation.persisted method to invalidate the affected states. consequently the mgr never started to listen on changes made to the jcr:lockIsDeep property and consequently wasn't aware of an external removal.\n\nsuggested fix:\nforce re-loading of the lock holding node.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1266",
        "summary": "Use creation tick instead of weak references in DocNumberCache",
        "description": "This avoids the need to keep two maps in CachingMultiIndexReader. And I guess the fewer weak references the better...",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1331",
        "summary": "Improper deprecation of Locked class",
        "description": "The Locked class in the jcr-commons package has been deprecated with 1.4 and moved to the spi-commons.\nHowever as this is a common class which does not depend on the spi, it should rather stay in jcr-commons.\nThe dependencies to spi can simply be removed again.",
        "label": "NUG",
        "classified": "BACKPORT",
        "type": "BUG"
    },
    {
        "key": "JCR-1708",
        "summary": "Impossible to import a string containing _x0020_  with Session.importXml",
        "description": "The importXml uses the ValueHelper.serialize methods. The option \"decodeBlanks\" does a simple string replace which replaces _x0020_ in spaces (line 695 and 793). This option is always set to true unless the imported data is binary. See: BufferedStringValue and StringValue getValue methods.\n\nThe result is that it is now impossible to import a string with _x0020_ in it, because it gets translated in a space. The simple solution would be to just turn off the declodeBlanks option, but I'm not sure why it was added in the first place. Another option would be to use real encoding instead of a replace like the o.a.j.util.ISO9075.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-468",
        "summary": "Item.isSame() may return true for 2 nodes from different workspaces.",
        "description": "the code in ItemImpl.isSame() only compares the item id, but not the source workspace.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1448",
        "summary": "nt:versionedChild problem",
        "description": "Problem occurs when both parent and child beans are versionable.  Jackrabbit creates an nt:versionedChild node that is referenced by the parent node, referencing the childs versionedHistory node of the child.  The current OCM code does not handle this correctly and produces an error:  \"Node type  'nt:versionedChild' does not match descriptor node type 'nt:unstructured'\"\n\nBelow is a example code of the problem and a patch that appears to correctly resolve the problem.\n\n\n Within ObjectConverterImpl created the below method.\n\n        public Node getActualNode(Session session,Node node) throws\n RepositoryException\n        {\n                NodeType type = node.getPrimaryNodeType();\n                if (type.getName().equals(\"nt:versionedChild\"))\n                {\n\n                        String uuid =\n node.getProperty(\"jcr:childVersionHistory\").getValue().getString();\n                        Node actualNode = session.getNodeByUUID(uuid);\n                        String name = actualNode.getName();\n                        actualNode = session.getNodeByUUID(name);\n\n                        return actualNode;\n                }\n\n                return node;\n        }\n\n AND modified the following to call the above method\n\n\n        public Object getObject(Session session, Class clazz, String path)\n        {\n                try {\n                        if (!session.itemExists(path)) {\n                                return null;\n                        }\n\n                        if (requestObjectCache.isCached(path))\n                    {\n                        return requestObjectCache.getObject(path);\n                    }\n\n                        ClassDescriptor classDescriptor =\n getClassDescriptor(clazz);\n\n                        checkNodeType(session, classDescriptor);\n\n                        Node node = (Node) session.getItem(path);\n                        if (!classDescriptor.isInterface()) {\n                                {\n                                node = getActualNode(session,node);\n                                checkCompatiblePrimaryNodeTypes(session,\n node, classDescriptor, true);\n                                }\n                        }\n\n                        ClassDescriptor alternativeDescriptor = null;\n                        if\n (classDescriptor.usesNodeTypePerHierarchyStrategy())\n {\n                                if\n (node.hasProperty(ManagerConstant.DISCRIMINATOR_PROPERTY_NAME))\n {\n                        String className =\n node.getProperty(ManagerConstant.DISCRIMINATOR_PROPERTY_NAME\n ).getValue().getString();\n                        alternativeDescriptor =\n getClassDescriptor(ReflectionUtils.forName(className));\n                                }\n                        } else {\n                                if\n (classDescriptor.usesNodeTypePerConcreteClassStrategy())\n {\n                                        String nodeType =\n node.getPrimaryNodeType().getName();\n                                        if\n (!nodeType.equals(classDescriptor.getJcrType()))\n {\n                                            alternativeDescriptor =\n classDescriptor.getDescendantClassDescriptor(nodeType);\n\n                                            // in case we an alternative\n could not be found by walking\n                                            // the class descriptor\n hierarchy, check whether we\n would\n                                            // have a descriptor for the\n node type directly (which\n                                            // may the case if the class\n descriptor hierarchy is\n                                            // incomplete due to missing\n configuration. See JCR-1145\n                                            // for details.\n                                            if (alternativeDescriptor ==\n null) {\n                                                alternativeDescriptor =\n mapper.getClassDescriptorByNodeType(nodeType);\n                                            }\n                                        }\n                                }\n                        }\n\n                        // if we have an alternative class descriptor,\n check whether its\n                        // extends (or is the same) as the requested class.\n                        if (alternativeDescriptor != null) {\n                            Class alternativeClazz =\n ReflectionUtils.forName(alternativeDescriptor.getClassName());\n                            if (clazz.isAssignableFrom(alternativeClazz)) {\n                                clazz = alternativeClazz;\n                                classDescriptor = alternativeDescriptor;\n                            }\n                        }\n\n                        // ensure class is concrete (neither interface nor\n abstract)\n                        if (clazz.isInterface() ||\n Modifier.isAbstract(clazz.getModifiers())) {\n                            throw new JcrMappingException( \"Cannot\n instantiate non-concrete\n class \" + clazz.getName()\n                        + \" for node \" + path + \" of type \" +\n node.getPrimaryNodeType().getName());\n                        }\n\n            Object object =\n ReflectionUtils.newInstance(classDescriptor.getClassName());\n\n            if (! requestObjectCache.isCached(path))\n            {\n                          requestObjectCache.cache(path, object);\n            }\n\n            simpleFieldsHelp.retrieveSimpleFields(session,\n classDescriptor, node, object);\n                        retrieveBeanFields(session, classDescriptor, node,\n path, object, false);\n                        retrieveCollectionFields(session, classDescriptor,\n node, object, false);\n\n                        return object;\n                } catch (PathNotFoundException pnfe) {\n                        // HINT should never get here\n                        throw new\n ObjectContentManagerException(\"Impossible to get\n the object\n at \" + path, pnfe);\n                } catch (RepositoryException re) {\n                        throw new\n org.apache.jackrabbit.ocm.exception.RepositoryException(\"Impossible to\n get the object at \" + path, re);\n                }\n        }\n\n\n\n\n>\n>\n>\n> > I am building a test application against OCM.  I have the following\n> > classes that are annotated for OCM.  The problem is that when I update\n> and\n> > version the root object PressRelease the Bean Author is versioned to\n> > nt:versionedChild.  While the OCM is checking for node type\n> compatibility\n> > it is throwing the following exception.  It looks like the\n> versionedChild\n> > is not handled correctly.  Any suggestions?\n> >\n> > I also attempted to retrieve the version based on the version name for\n> the\n> > rootVersion but also trapped. From a Version object how should I access\n> > each of the versioned entries?\n> >\n> > Thanks\n> > Wes\n> >\n> > @Node (jcrMixinTypes=\"mix:versionable\")\n> > public class PressRelease\n> > {\n> >       @Field(path=true) String path;\n> >       @Field String title;\n> >       @Field Date pubDate;\n> >       @Field String content;\n> >       @Bean Author author;\n> >       @Collection (elementClassName=Comment.class) List<Comment>\n> comments = new\n> > ArrayList<Comment>();\n> >\n> >       public String getPath() {\n> >               return path;\n> >       }\n> >       public void setPath(String path) {\n> >               this.path = path;\n> >       }\n> >       public String getContent() {\n> >               return content;\n> >       }\n> >       public void setContent(String content) {\n> >               this.content = content;\n> >       }\n> >       public Date getPubDate() {\n> >               return pubDate;\n> >       }\n> >       public void setPubDate(Date pubDate) {\n> >               this.pubDate = pubDate;\n> >       }\n> >       public String getTitle() {\n> >               return title;\n> >       }\n> >       public void setTitle(String title) {\n> >               this.title = title;\n> >       }\n> >       public Author getAuthor() {\n> >               return author;\n> >       }\n> >       public void setAuthor(Author author) {\n> >               this.author = author;\n> >       }\n> >       public List<Comment> getComments() {\n> >               return comments;\n> >       }\n> >       public void setComments(List<Comment> comments) {\n> >               this.comments = comments;\n> >       }\n> >\n> >\n> > }\n> >\n> > @Node (jcrMixinTypes=\"mix:versionable\")\n> > public class Author {\n> >\n> >       @Field(path=true) String path;\n> >       @Field String name;\n> >\n> >\n> >       public String getName() {\n> >               return name;\n> >       }\n> >       public void setName(String name) {\n> >               this.name = name;\n> >       }\n> >       public String getPath() {\n> >               return path;\n> >       }\n> >       public void setPath(String path) {\n> >               this.path = path;\n> >       }\n> >\n> > }\n> >\n> > MAIN\n> >\n> >       while (versionIterator.hasNext())\n> >       {\n> >           Version version = (Version) versionIterator.next();\n> >           System.out.println(\"version found : \"+ version.getName() + \" -\n> \" +\n> >                                 version.getPath() + \" - \" +\n> > version.getCreated().getTime());\n> >\n> >\n> >           if (!version.getName().equals(\"jcr:rootVersion\"))\n> >           {\n> >\n> > //      Get the object matching to the first version\n> >           pressRelease = (PressRelease)\n> > ocm.getObject(\"/newtutorial\",version.getName());\n> >\n> >\n> >               System.out.println(\"PressRelease title : \" +\n> pressRelease.getTitle());\n> >               System.out.println(\"             author: \" +\n> > pressRelease.getAuthor().getName());\n> >               System.out.println(\"            content: \" +\n> pressRelease.getContent());\n> >               List comments = pressRelease.getComments();\n> >               Iterator iterator = comments.iterator();\n> >               while (iterator.hasNext())\n> >               {\n> >                       comment = (Comment) iterator.next();\n> >                       System.out.println(\"Comment : <\" + comment.getData()\n> + \">\" +\n> > comment.getText());\n> >               }\n> >           }\n> >       }\n> >\n> >\n> > CONSOLE\n> > version found : jcr:rootVersion -\n> >\n> /jcr:system/jcr:versionStorage/fc/0b/fd/fc0bfd89-c487-4fbe-930f-d837e5dfed79/jcr:rootVersion\n> > - Thu Feb 28 15:54:42 EST 2008\n> > version found : 1.0 -\n> >\n> /jcr:system/jcr:versionStorage/fc/0b/fd/fc0bfd89-c487-4fbe-930f-d837e5dfed79/1.0\n> > - Thu Feb 28 15:54:59 EST 2008\n> > Exception in thread \"main\"\n> > org.apache.jackrabbit.ocm.exception.ObjectContentManagerException:\n> Cannot\n> > map object of type 'com..pc.repository.Author'. Node type\n> > 'nt:versionedChild' does not match descriptor node type\n> 'nt:unstructured'\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.checkCompatiblePrimaryNodeTypes\n> (ObjectConverterImpl.java:552)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.getObject\n> (ObjectConverterImpl.java:361)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.beanconverter.impl.DefaultBeanConverterImpl.getObject\n> (DefaultBeanConverterImpl.java:80)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.retrieveBeanField\n> (ObjectConverterImpl.java:666)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.retrieveBeanFields\n> (ObjectConverterImpl.java:621)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.getObject\n> (ObjectConverterImpl.java:309)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.impl.ObjectContentManagerImpl.getObject(\n> ObjectContentManagerImpl.java:313)\n> >       at com.pc.repository.Main.main(Main.java:345)\n\n\n\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2789",
        "summary": "toString() causes StackOverflowError",
        "description": "further regressions of JCR-2763...",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2513",
        "summary": "Omit default BatchReadConfig in Spi2davexRepositoryServiceFactory",
        "description": "i'd like to remove the default batchread configuration created in Spi2davexRepositoryServiceFactory (ll 79) and instead pass \nnull if the service configuration doesn't define the batch-read-config.\n\nfor test execution e.g. the given default isn't really optimal as sessions only have a short life time and only read\na very limited amount of items (in general)... always reading with depth 4 doesn't add any benefit in this case.\nrunning the level1 jcr tests in jcr2dav (that as far as i saw doesn't define an extra batchread-config took 1.5, 2.5 and 13 minutes\nfrom null-config -> depth2 -> depth4.\n\nif there is a strong reason for keeping that default in the factory we should at least change that for the tests.\nmichael, what do you think?",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2129",
        "summary": "Prevent data inconsistencies due to incorrect or missed merges in the ItemStateManagers",
        "description": "There are two places where transient state changes are merged with persisted state: (i) in the SessionISM.stateModified call back method (typically called by a saving thread after it's changes have been saved) and (ii) in the SharedISM.Update.begin method. Sometimes the merge strategy fails in the sense that corrupt data is written to database. \n\nHow to reproduce:\nThe attached test program contains steps to reproduce the issue. The testInconsistency1 method concurrently adds a node D to a node A and moves child node B of A to another place. This sometimes results in a situation in which node A still has a child reference to node B whereas B has another parent. In this situation, Jackrabbit cannot be started anymore if the search index is missing: \n\nJun 8, 2009 2:16:23 PM org.apache.jackrabbit.core.query.OnWorkspaceInconsistency$1 handleMissingChildNode\nSEVERE: Node /A (a7a29e8c-8d13-4fbd-b0ca-4f93f9c0ef42) has missing child 'B' (80aa13c5-1db6-4f62-b576-5e7f626d90c1)\nJun 8, 2009 2:16:23 PM org.apache.jackrabbit.core.RepositoryImpl initStartupWorkspaces\nSEVERE: Failed to initialize workspace 'wm9'\n\nThe testInconsistency2 method concurrently adds a reference property to a node B (the threads do exactly the same). This sometimes results in a situation in which the referenced node can never be removed anymore because there is a \"ghost\" reference to it which cannot be removed. (It gives a ReferentialIntegrityException).\n\nJun 8, 2009 2:19:51 PM org.apache.jackrabbit.core.state.MLRUItemStateCache cache\nWARNING: overwriting cached entry bc28ff87-216d-4ccd-bd73-03e7499ab54e/{}ref to B\nException in thread \"main\" javax.jcr.ReferentialIntegrityException: 9f025634-d3e1-448e-904c-1c285f6b1bf6: the node cannot be removed because it is still being referenced.\n\nIt seems the first problem (the parent-child relation) is caused by an incorrect merge in the NodeStateMerger class. The second problem might also be caused by an incorrect or missed merge, but I am not sure whether that's the real problem.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2700",
        "summary": "Allow for wildcard restriction in resource-based ACEs",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2314",
        "summary": "Open access modifier for RepositoryImpl.doShutdown()",
        "description": "This is required for a subclass of RepositoryImpl that wants to run additional code on shutdown, otherwise a deadlock may occur because the sequence of lock acquisition cannot be ensured.\n\nJackrabbit requires that the shutdownLock is first acquired and then the actual shutdown code is executed.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-788",
        "summary": "Upgrade to Lucene 2.2",
        "description": "Lucene 2.1 contains a number of useful enhancements, which could be benefical to jackrabbit:\n\n- less locking on index updates -> less IO calls\n- introduces FieldSelector -> allows jackrabbit to only load required fields",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2928",
        "summary": "LuceneQueryFactory should call QueryHits.close() after running a query",
        "description": "LuceneQueryFactory which is responsible for the JCR_SQL2 implementation does not close QueryHits after running a query.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2219",
        "summary": "Improved background text extraction",
        "description": "As recently discussed on the mailing list (see http://markmail.org/message/syt7lc2guzapt7la), the current approach to text extraction in background threads doesn't work that well especially with the Tika-based extractors that support streamed parsing of many document types.\n\nAlso, we currently *all* of the extracted text streams are buffered into Strings before being passed into the Lucene index. It would be good if we could somehow get back to passing just Readers to Lucene.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-701",
        "summary": "Upgrade to Xerces 2.8.1",
        "description": "Besides a number of bug fixes and new features in Xerces, upgrading to a newer version would also give us better dependency metadata, and thus avoid the need of having a separate xmlParserAPIs dependency in addition to the main xercesImpl dependency. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-798",
        "summary": "ConcurrentModificationException during logout",
        "description": "We regularly get the following exception:\n\njava.util.ConcurrentModificationException\n        at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceEntrySetIterator.checkMod(AbstractReferenceMap.java:761)\n        at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceEntrySetIterator.hasNext(AbstractReferenceMap.java:735)\n        at java.util.Collections$UnmodifiableCollection$1.hasNext(Collections.java:1009)\n        at java.util.Collections$UnmodifiableCollection$1.hasNext(Collections.java:1009)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.dispose(LocalItemStateManager.java:341)\n        at org.apache.jackrabbit.core.WorkspaceImpl.dispose(WorkspaceImpl.java:170)\n        at org.apache.jackrabbit.core.SessionImpl.logout(SessionImpl.java:1225)\n        at org.apache.jackrabbit.core.XASessionImpl.logout(XASessionImpl.java:379)\n\nTwo causes for this exception have been identified:\n\n (Taken from an email to the dev-list from Marcel Reutegger):\n> - session A reads some items I\n> - session B transiently removes items in I\n> - session A logs out and starts to iterate over I in  LocalItemStateManager (LISM)\n> - session B saves changes and removed items are evicted from A's LISM\n> - session A gets concurrent modification exception\n\nAnother scenario is the following:\n- Session A gets the iterator of the values of (the primary cache of) an ItemStateReferenceCache in LocalItemStateManager.dispose.\n- Session B then does something that triggers the CacheManager.\n- The CacheManager then calls resizeAll, and evicts some items from the secondary cache of the ItemStateReferenceCache of which the LocalItemStateManager has a values iterator.\n- The garbage collector then runs and evicts the removed items also from the primary cache, which effectively modifies the set over which is iterated.\n\nRegards,\n\nMartijn Hendriks",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1290",
        "summary": "tm-extractors.jar blocks usage of newer poi versions",
        "description": "The used tm-extractors-0.4.jar (http://repo1.maven.org/maven2/org/textmining/tm-extractors/) includes various classes from poi as well as poi-2.5.1 is referenced as dependency in the pom.xml.\nIt's seems not possible to use a newer version of poi (e.g. poi-3.0.1-FINAL) together with tm-extractors (and so jackrabbit).\n\nA solution could be using functions of newer poi versions (I'm not sure if they are only in scratchpad yet) or use a fixed version of tm-extractors.jar which doesn't inlude the poi classes.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-141",
        "summary": "Versioning does not make use of tx",
        "description": "for example:\n\n- begin transaction\n- create node\n- add mix:versionable\n- save --> will create version\n- checkin\n- cancel transaction\n\nshould not leave any traces in versioning",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2994",
        "summary": "Add method to remove mappings from NamespaceMapping",
        "description": "o.a.j.spi.commons.namespace.NamespaceMapping has currently no means to remove a mapping. I suggest to add a method\npublic String removeMapping(String uri) ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2706",
        "summary": "Evaluate if membershipcache (JCR-2703) obsoletes the cache in DefaultPrincipalProvider",
        "description": "",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2589",
        "summary": "WebDav MKCOL on a directory that already exists generates a IllegalStateException",
        "description": "when performing a MKCOL on a resource that already exists, following is thrown.\n\n31.03.2010 16:14:10.760 *ERROR* [127.0.0.1 [1270012450463] MKCOL /org.apache.sling.launchpad.testing-6-SNAPSHOT/apps HTTP/1.1] org.apache.sling.engine.impl.SlingMainServlet service: Uncaught Throwable java.lang.IllegalStateException: Response has already been committed\n       at org.apache.sling.engine.impl.SlingHttpServletResponseImpl.checkCommitted(SlingHttpServletResponseImpl.java:398)\n       at org.apache.sling.engine.impl.SlingHttpServletResponseImpl.setStatus(SlingHttpServletResponseImpl.java:265)\n       at org.apache.jackrabbit.webdav.WebdavResponseImpl.setStatus(WebdavResponseImpl.java:276)\n       at org.apache.jackrabbit.webdav.server.AbstractWebdavServlet.doMkCol(AbstractWebdavServlet.java:548)\n       at org.apache.jackrabbit.webdav.server.AbstractWebdavServlet.execute(AbstractWebdavServlet.java:256)\n       at org.apache.jackrabbit.webdav.server.AbstractWebdavServlet.service(AbstractWebdavServlet.java:196)\n       at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)\n       at org.apache.sling.engine.impl.request.RequestData.service(RequestData.java:523)\n....\n\n\nI think a return after the sendError is required ?\nin AbstractWebdavServlet.doMkCol(...) \n\n\n   protected void doMkCol(WebdavRequest request, WebdavResponse response,\n                          DavResource resource) throws IOException, DavException {\n\n       DavResource parentResource = resource.getCollection();\n       if (parentResource == null || !parentResource.exists() || !parentResource.isCollection()) {\n           // parent does not exist or is not a collection\n           response.sendError(DavServletResponse.SC_CONFLICT);\n           return;\n       }\n       // shortcut: mkcol is only allowed on deleted/non-existing resources\n       if (resource.exists()) {\n           response.sendError(DavServletResponse.SC_METHOD_NOT_ALLOWED);\n+          return;\n       }\n\n       if (request.getContentLength() > 0 || request.getHeader(\"Transfer-Encoding\") != null) {\n           parentResource.addMember(resource, getInputContext(request, request.getInputStream()));\n       } else {\n           parentResource.addMember(resource, getInputContext(request, null));\n       }\n       response.setStatus(DavServletResponse.SC_CREATED);\n   }\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1132",
        "summary": "XSLT pretty-printer for JCR document view export files",
        "description": "The attached XSLT pretty-prints Jackrabbit XML document view export files.\n\nI'm uploading it here so others can use it or improve it.\n\nFor now I'm using it standalone to document content structures, later I might create a servlet that applies it live to repository content.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1970",
        "summary": "populate.jsp uses Java 1.5 method",
        "description": "The method is URLConnection.setReadTimeout()\n",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "BUG"
    },
    {
        "key": "JCR-2365",
        "summary": "HTML Text Extractor does not extract or index numerics",
        "description": "Numerics such as addresses/dates/financial figures are not extracted or indexed by the current HTML Extractor.  These values are handled properly and searchable when done via the PlainTextExtractor",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-915",
        "summary": "Invalid Journal Record appearing when read during sync operation",
        "description": "ERROR: Error while processing revision 3161: Unknown entry type: \n(a) (2007-05-13 19:57:02,258 main_org.apache.jackrabbit.core.cluster.ClusterNode)\nERROR: Unable to start clustered node, forcing shutdown... (2007-05-13 19:57:02,259 main_org.apache.jackrabbit.core.RepositoryImpl)\norg.apache.jackrabbit.core.cluster.ClusterException: Unable to read record with revision: 3161\n        at org.apache.jackrabbit.core.cluster.ClusterNode.sync(ClusterNode.java:285)\n        at org.apache.jackrabbit.core.cluster.ClusterNode.start(ClusterNode.java:229)\n        at org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:308)\n        at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:584)\n        at org.sakaiproject.jcr.jackrabbit.RepositoryBuilder.init(RepositoryBuilder.java:213)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:585)\n\n\nThis is a 2 node cluster, with persistance managers in the DB and journal on the shared filesystem.\n\nStart the first node in the cluster up from a completely clean and empty repo.\n\nLet it add some note types, and create a since workspace (called sakai) and then connect via webdav (using OSX Finder) which creates some Journal Records (due to the finder putting some .xxxx files in)\n\nDont add any files.\n\nThen start the second node in the cluster up,\n\nIt runs through the first 15 or so journal entries and then hits a one where the entry is unknown (stack trace above)\n\nSome analysis to follow\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3089",
        "summary": "javax.jcr.RepositoryException when a JOIN SQL2 query is send via Davex and has results",
        "description": "see the following thread for details:\nhttp://www.mail-archive.com/users@jackrabbit.apache.org/msg17975.html\n\nassuming a data structure as follows:\n/foo [nt:unstructured]\n/foo/bar [nt:unstructured]\n/foo/bar@lala = huii (lala is string property of bar)\n/ding [nt:unstructured]\n/ding@dong = ##barUUID### (dong is a property of type \"Reference\")\n\nthen the following code will throw an exception:\n\nDavexClient Client = new DavexClient(url);\nRepository repo = Client.getRepository();\nCredentials sc = new SimpleCredentials(\"admin\",\"admin\".toCharArray());\nSession s = repo.login(sc,workspace);\n\nQueryManager qm = s.getWorkspace().getQueryManager();\n\nString sql = \"SELECT data.* FROM [nt:unstructured] AS data WHERE data.lala= 'huii'\";\nsql = \"SELECT * FROM [nt:unstructured] AS data INNER JOIN [nt:unstructured] AS referring ON referring.[dong] = data.[jcr:uuid] WHERE data.lala = 'huii'\";\nsql = \"SELECT * FROM [nt:unstructured] AS data INNER JOIN [nt:unstructured] AS referring ON ISDESCENDANTNODE(data, referring) WHERE data.lala = 'huii'\";\nQuery query = qm.createQuery(sql, Query.JCR_SQL2);\nQueryResult qr = query.execute();\n\nThe first query works just fine and I can iterate over the result. Neither the second nor the third query works.\nIn both cases I end up with a javax.jcr.RepositoryException. Note the exception only happens if the query returns results. Aka a join will work just fine if it matches no rows.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-719",
        "summary": "XPath parser ignores parent axis",
        "description": "The query handler in Jackrabbit does not support the parent axis and should throw an invalid query exception in that case.\n\nExample query:\n\n//foo/..",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2602",
        "summary": "Removal of first version throws javax.jcr.ReferentialIntegrityException",
        "description": "A ReferentialIntegrityException occurs when I delete the first version succeeding the root version. Deleting other versions works fine. Here is the stack:\n\njavax.jcr.ReferentialIntegrityException: Unable to remove version. At least once referenced.\n        at org.apache.jackrabbit.core.version.InternalVersionHistoryImpl.removeVersion(InternalVersionHistoryImpl.java:379)\n        at org.apache.jackrabbit.core.version.InternalVersionManagerBase.internalRemoveVersion(InternalVersionManagerBase.java:684)\n        at org.apache.jackrabbit.core.version.InternalVersionManagerImpl$5.run(InternalVersionManagerImpl.java:495)\n        at org.apache.jackrabbit.core.version.InternalVersionManagerImpl$DynamicESCFactory.doSourced(InternalVersionManagerImpl.java:760)\n        at org.apache.jackrabbit.core.version.InternalVersionManagerImpl.removeVersion(InternalVersionManagerImpl.java:493)\n        at org.apache.jackrabbit.core.version.InternalXAVersionManager.removeVersion(InternalXAVersionManager.java:264)\n        at org.apache.jackrabbit.core.version.VersionHistoryImpl.removeVersion(VersionHistoryImpl.java:253)\n\nThe code is simple:\n\nVersionHistory vh = session.getWorkspace().getVersionManager().getVersionHistory(path);\nvh.removeVersion(version); // where version is the first version succeeding the root version\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-225",
        "summary": "LockInfo.logginOut(SessionImpl): javadoc does not correspond to executed code",
        "description": "/**\n     * {@inheritDoc}\n     * <p/>\n     * When the owning session is logging out, we have to perform some\n     * operations depending on the lock type.\n     * (1) If the lock was session-scoped, we unlock the node.\n     * (2) If the lock was open-scoped, we remove the lock token\n     *     from the session.\n     */\n    public void loggingOut(SessionImpl session) {\n        if (live) {\n            if (sessionScoped) {\n                lockMgr.unlock(this);\n            } else {\n                if (session.equals(lockHolder)) {\n                    lockHolder = null;\n                }\n            }\n        }\n    } \n\n\nif (2) is true, the lockToken is not removed from the session (at least not within the method).\n\nregards\nangela",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2058",
        "summary": "JSR 283: VersionManager and new versioning methods",
        "description": "JSR 283 introduces a new interface \"VersionManager\" that exposes all versioning functionality that was formerly present on Node and Workspace. \n\nIn addition the following new methods:\n\n- checkpoint(String absPath) Version \n- merge(String absPath, String srcWorkspace, boolean bestEffort, boolean isShallow) NodeIterator \n- merge(Node activityNode) NodeIterator \n\nSee Issue #JCR-1592 for Activity and Configuration feature.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2746",
        "summary": "Sleep in possibly endless loop in ObservationDispatcher",
        "description": "The rate-limitation code we added in JCR-2402 to prevent the observation queue from growing too large was a good idea, but the current implementation is a bit troublesome since it blocks the thread while it still holds the journal lock, the SISM reader lock, and the SessionState lock. This can cause a deadlock under heavy workloads if any of the observation listeners attempts to reuse the session (not recommended/supported, but can still happen) or write to the repository (quite likely).\n\nTo solve this problem we should move the rate-limiter code to outside the scope of any internal locks.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2177",
        "summary": "Node.getWeakReferences throws UnsupportedOperationException if not referenceable",
        "description": ".... while Node.getReferences() doesn't and returns an empty propertyiterator.\n\nFrom my point of view both methods should behave the same way and i prefer not throwing.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2838",
        "summary": "Tika regressions in 0.8",
        "description": "There are a few notable problems in Tika 0.8, namely TIKA-548 and TIKA-556, that may adversely affect users of Jackrabbit 2.2.\n\nSince we don't have a Tika 0.9 release available yet, I'll add workarounds for these issues in Jackrabbit.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1278",
        "summary": "Add configuration path to SynonymProvider",
        "description": "This is an enhancement to the SynonymProvider, which will be included in the 1.4 release. The current interface only has a getSynonyms() method but does not allow to initialize the SynonymProvider. It should be possible to initialize the provider with a configuration file. The configuration may then include the synonym definitions or a pointer to a location where the synonyms are defined. The configuration will be implementation dependent.\n\nIn addition there should be a simple default implementation in jackrabbit-core. The wordnet-synonyms in the sandbox are only of limited use and must be built manually.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-343",
        "summary": "Jcr-server: Report#init limits the Report interface to DeltaV compliant resources",
        "description": "Although the REPORT features is defined by RFC 3253 and required for DeltaV compliant resources it is not limited to deltaV. See RFC 3744 (WebDAV Access Control Protocol) for additional usage of the REPORT functionality.\n\nIn order to keep the Report interface open for later usage by resources providing support for RFC 3744,\nthe init method signature could be modified as follows:\n\nReport#init(DavResource, ReportInfo) instead of\nReport#init(DeltaVResource, ReportInfo)",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1872",
        "summary": "Improve performance of simple path queries",
        "description": "Queries with simple path constraints can be quite slow because of the way they are implemented. The current implementation basically does a hierarchical join with the context nodes and the set of nodes with the name of the next location step. When the specified path is quite selective the implementation should   rather resolve the path expression using the item state manager (similar to how regular paths are resolved in the JCR API).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2278",
        "summary": "Move NodeTypeStorage to spi-commons and provide default implementation",
        "description": "This facilitates the implementation of NodeTypes methods of RepositoryService.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-426",
        "summary": "WorkspaceInfo.dispose() does not deregister from obs dispatcher",
        "description": "JCR-305 introduces an automatic disposing of idle workspaces. this can lead to memory leaks because the observation factory is not deregistered from the delegating one.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1057",
        "summary": "Log at debug level rather that info in CacheManager",
        "description": "Please change org.apache.jackrabbit.core.state.CacheManager#resizeAll to log at DEBUG level rather that INFO.\n15:50:01,058 INFO  [CacheManager] resizeAll size=8\n\n--- jackrabbit-core/src/main/java/org/apache/jackrabbit/core/state/CacheManager.java    (revision 565102)\n+++ jackrabbit-core/src/main/java/org/apache/jackrabbit/core/state/CacheManager.java    (working copy)\n@@ -122,7 +122,7 @@\n      * Re-calcualte the maximum memory for each cache, and set the new limits.\n      */\n     private void resizeAll() {\n-        log.info(\"resizeAll size=\" + caches.size());\n+        log.debug(\"resizeAll size=\" + caches.size());\n         // get strong references\n         // entries in a weak hash map may disappear any time\n         // so can't use size() / keySet() directly\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1761",
        "summary": "OCM:Add the ability to specify name of a Collection Element through XML Mapping files.",
        "description": "Collection elements get mapped to a node \"collection-element\" when the mappings are specified through XML config files.  We need the ability to control this name through configuration.  Without that feature querying object structures is painful.  For example I have structure as below :\n\nclass Foo{\nString id;\n List<Foo> children\n List<Foo> friends\n}\n\nAnd I have a need to query a Foo with id : 100 .  If I am interested only in child nodes with id = 110 , I could specify through the Filter that look at only node names , \"childFoo\" ; If I have the flexibility of adding a child node name.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2714",
        "summary": "Selective disabling of checks in ItemValidator",
        "description": "I would like to be able to selectively disable checks in ItemValidator in the scope of an operation performed through methods of the SessionState class. Doing so would provide simple means for internally modifying (for example) protected items. Currently such modifications must be done 'manually' on the item state level. This approach is very error prone and not very DRY.\n\nWith my upcoming patch in place, setting a protected property would look like this:\n\nfinal Node parent = ...\nfinal Value value = ...\nSessionState sessionState = sessionContext.getSessionState();\n\nProperty property = sessionState.performUnchecked(new SessionOperation<Property>() {\n    public Property perform(SessionContext context) throws RepositoryException {\n        return parent.setProperty(\"foo\", value);\n    }\n}, ItemValidator.CHECK_CONSTRAINTS);\n\nThat is, users need to have access to the session context in order to disable checks which makes this only usable from inside Jackrabbit. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-344",
        "summary": "Jcr-server: DeltaVResource lists MKWORKSPACE in the method constant.",
        "description": "RFC 3253 requires REPORT to be supported by all DeltaV compliant resources.\nThe method constant therefore should list REPORT only.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-28",
        "summary": "Node.checkin() throws ArrayIndexOutOfBoundsException",
        "description": "I get an ArrayIndexOutOfBoundsException for index 0 when checking-in a node. After drilling into the code I found, that during checkin, the jcr:uuid property (defined as OPV INITIALIZE) is not copied from the node to the frozen node.\n\nAfter checkin though the implementation tries to access the string value of the jcr:uuid property, which is not existing, hence the internal property implementation throws the exception when accessing the first element in the empty value array.\n\nAs a workaround I currently the set jcr:uuid property to OPV=COPY in the mixin:referenceable node type. But I could imagine, that this might be incorrect according to the spec, yet it works in my use case.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2183",
        "summary": "Provide overridables for lock checking",
        "description": "Currently, checking whether a session is allowed to write to some locked node or whether it is allowed to unlock it is quite spread throughout the code. This should be collected to allow a custom lock manager overriding just a few methods to alter the default behavior.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2020",
        "summary": "Overlapping index aggregates not updated",
        "description": "When there are overlapping index aggregates in an indexing configuration and an item is updated that belongs to multiple aggregates, then only the first aggregate root is re-indexed.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2671",
        "summary": "AbstractLoginModule must not call abort() in commit()",
        "description": "AbstractLoginModule.commit() currently may call abort() when it detects that the login did not succeed. abort() will reset any state in the login module, including state shared between multiple login modules like Principals in the Subject. When there actually are multiple module, this will delete shared state that was set by other login modules. Moreover, the method commit() is only called when the overall authentication succeeded. Thus, it seems strange to call abort() from within commit().\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1166",
        "summary": "JCR2SPI does not provide actual size on RangeIterator.getSize()",
        "description": "Currently, JCR2SPI always returns -1 on RangeIterator.getSize().\n\nThis return value is legal (meaning \"unknown\"), but may cause clients to simply iterate through the whole list when what they really want is simply the count.\n\nUse case:\n\n\"The use case is to count the number of members of a NT_FOLDER without having to open up the NT_FOLDER and count all the members (and I assume load them into memory) \"\n\nTo make this happen we probably need to move away from simple Iterators on the SPI level, and put quite some additional work into JCR2SPI.\n\nFeedback appreciated.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-355",
        "summary": "Extract JDBC Connection Init",
        "description": "An intermediate step to allowing a PM to be easily configurable through JNDI would be to extract the connection init. This will allow system integrators to subclass/wrap and dynamically configure a customized Simple PM. In org.apache.jackrabbit.core.state.db.SimpleDbPersistenceManager:\n\nReplace lines (296-298) with\n\n        initConnection();\n\nAdd:\n\t/**\n\t* Initialize the JDBC connection\n\t**/\n\tprotected void initConnection() throws Exception {\n            Class.forName(driver);\n            con = DriverManager.getConnection(url, user, password);\n            con.setAutoCommit(false);\n\t}",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1086",
        "summary": "JCR2SPI: Workspace.getImportHandler creates a handler which doesn't work properly under JDK 1.4.",
        "description": "JCR2SPI returns an import handler which delegates work to a SAXTransformerHandler. In JDK, that one has a known issue not processing namespace prefix mappings properly (will attach a separate test case).\n\nProposals:\n\n- drop JDK 1.4 support\n- tune the JCR2SPI handler to create namespace attributes when needed\n- use an entirely different serializer\n\nMy personal preference would be just to drop JDK 1.4 support, but that may not be acceptable for everyone.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1292",
        "summary": "Deprecated classes point to wrong replacements (due to various package renamings)",
        "description": "classes that have been replaced by equivalents in jackrabbit-spi-commons point to wrong replacements in the @deprecated javadoc tag.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-667",
        "summary": "Variant spelling \"Trasaction\" and \"Transaction\" now in codebase",
        "description": "Incorrectly spelled \"Trasaction\" now in codebase.  The correctly spelled \"Transaction\" appears a far greater number of times.\n\nIsolated to package: org.apache.jackrabbit.jca\n\nIncorrectly  spelled \"Trasaction\" found in:\n(3x) JCAManagedConnection.java \n(7x) JCAManagedConnectionFActory.java\n\nCorrectly spelled \"Transaction\" found in:\n(20x) JCAManagedConnection.java \n(2x) JCAManagedConnectionFActory.java \n(1x) JCAResourceAdapter.java \n(12x) TransactionBoundXAResource.java \n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1726",
        "summary": "Hudson build doesn't detect Java 5 class references",
        "description": "Due to the fact that the Maven 2 support in Hudson only works on Java 5, our current CI build at http://hudson.zones.apache.org/hudson/job/Jackrabbit-trunk/ doesn't detect references to classes and methods that are only available in the Java 5 class library.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "TASK"
    },
    {
        "key": "JCR-1272",
        "summary": "Property.getValue() throws RepositoryException with internal error",
        "description": "Running ConcurrentReadWriteTest (NUM_NODES=5, NUM_THREADS=3, RUN_NUM_SECONDS=120) resulted in a RepositoryException calling Property.getValue():\n\njavax.jcr.RepositoryException: Internal error while retrieving value of b3fc1ea8-3364-4236-bcc7-dea0baf90640/{}test: null: null\n\nDebugging shows that it is a NullPointerException:\n\njava.lang.NullPointerException\n\tat org.apache.jackrabbit.core.PropertyImpl.getValue(PropertyImpl.java:481)\n\tat org.apache.jackrabbit.core.ConcurrentReadWriteTest$1$1.execute(ConcurrentReadWriteTest.java:68)\n\tat org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:110)\n\tat java.lang.Thread.run(Thread.java:619)\n\nIt's probably the state which has been discarded after the sanityCheck().",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1941",
        "summary": "AccessManager asks for property (jcr:created) permissions before the actual creation of the object",
        "description": "\nWhen implementing a custom AccessManager for Jackrabbit v1.5+ there a bug when creating a new object.\n\nI perform an addNode() and my own accessmanager the isGranted() method is override'd and performs the following code;\n\n            ......\n            String perm = null;\n            NodeId     nodeId = mHierMgr.resolveNodePath( pPath );\n            PropertyId propId = null;\n            if (nodeId==null) {\n              propId = mHierMgr.resolvePropertyPath( pPath );\n     System.out.println(\"path = \" + pPath.toString() );\n              // **** TODO is this ok?... it happens when a new object is created and the accessmanager ask for read access on a property.\n//              if (propId==null) return true;\n              nodeId = propId.getParentId();\n            }\n\nthis is the System.out.println result\n\npath = {}        {}JeCARS        {}default        {}Groups        {}testGroup        {http://www.jcp.org/jcr/1.0}created\n\n\nand the stacktrace\n\n\n\tat org.jecars.CARS_AccessManager.isGranted(CARS_AccessManager.java:844)\n\tat org.jecars.CARS_AccessManager.isGranted(CARS_AccessManager.java:806)\n\tat org.apache.jackrabbit.core.ItemManager.canRead(ItemManager.java:339)\n\tat org.apache.jackrabbit.core.ItemManager.canRead(ItemManager.java:326)\n\tat org.apache.jackrabbit.core.ItemManager.createItemData(ItemManager.java:696)\n\tat org.apache.jackrabbit.core.ItemManager.getItemData(ItemManager.java:291)\n\tat org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:228)\n\tat org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:493)\n\tat org.apache.jackrabbit.core.NodeImpl.createChildProperty(NodeImpl.java:479)\n\tat org.apache.jackrabbit.core.NodeImpl.createChildNode(NodeImpl.java:535)\n\tat org.apache.jackrabbit.core.NodeImpl.internalAddChildNode(NodeImpl.java:795)\n\tat org.apache.jackrabbit.core.NodeImpl.internalAddNode(NodeImpl.java:729)\n\tat org.apache.jackrabbit.core.NodeImpl.internalAddNode(NodeImpl.java:677)\n\tat org.apache.jackrabbit.core.NodeImpl.addNode(NodeImpl.java:2110)\n\n\nIt seems that READ permission for the jcr:created property is requested before the object is actually created\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1417",
        "summary": "[PATCH] remove code stutter",
        "description": "Method calls getQName for no reason\n\n\npublic String getName() throws RepositoryException {\n        checkStatus();\n        Name qName = getQName();\n        return session.getNameResolver().getJCRName(getQName());\n    }\n\npatch fixes it.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1640",
        "summary": "Not configuring the adminId, anonymousId, or defaultuserId causes login module to ignore credentials",
        "description": "Using the DefaultLoginModule, DefaultAccessManager, and DefaultSecurityManager and calling Repository.login(Credentials) causes the following stack trace to be thrown.  \n\njavax.jcr.LoginException: LoginModule ignored Credentials: LoginModule ignored Credentials: LoginModule ignored Credentials\n\tat org.apache.jackrabbit.core.RepositoryImpl.login(RepositoryImpl.java:1353)\n\tat org.apache.jackrabbit.commons.AbstractRepository.login(AbstractRepository.java:53)\n\tat com.cerner.system.configuration.repository.jcr.JackrabbitTest.testLoginWithCredentials(JackrabbitTest.java:23)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.junit.internal.runners.TestMethod.invoke(TestMethod.java:59)\n\tat org.junit.internal.runners.MethodRoadie.runTestMethod(MethodRoadie.java:98)\n\tat org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:79)\n\tat org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:87)\n\tat org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:77)\n\tat org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:42)\n\tat org.junit.internal.runners.JUnit4ClassRunner.invokeTestMethod(JUnit4ClassRunner.java:88)\n\tat org.junit.internal.runners.JUnit4ClassRunner.runMethods(JUnit4ClassRunner.java:51)\n\tat org.junit.internal.runners.JUnit4ClassRunner$1.run(JUnit4ClassRunner.java:44)\n\tat org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:27)\n\tat org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:37)\n\tat org.junit.internal.runners.JUnit4ClassRunner.run(JUnit4ClassRunner.java:42)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:45)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\nCaused by: javax.security.auth.login.FailedLoginException: LoginModule ignored Credentials\n\tat org.apache.jackrabbit.core.security.authentication.LocalAuthContext.login(LocalAuthContext.java:73)\n\tat org.apache.jackrabbit.core.RepositoryImpl.login(RepositoryImpl.java:1346)\n\t... 24 more\njavax.security.auth.login.FailedLoginException: LoginModule ignored Credentials\n\tat org.apache.jackrabbit.core.security.authentication.LocalAuthContext.login(LocalAuthContext.java:73)\n\tat org.apache.jackrabbit.core.RepositoryImpl.login(RepositoryImpl.java:1346)\n\tat org.apache.jackrabbit.commons.AbstractRepository.login(AbstractRepository.java:53)\n\tat com.cerner.system.configuration.repository.jcr.JackrabbitTest.testLoginWithCredentials(JackrabbitTest.java:23)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.junit.internal.runners.TestMethod.invoke(TestMethod.java:59)\n\tat org.junit.internal.runners.MethodRoadie.runTestMethod(MethodRoadie.java:98)\n\tat org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:79)\n\tat org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:87)\n\tat org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:77)\n\tat org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:42)\n\tat org.junit.internal.runners.JUnit4ClassRunner.invokeTestMethod(JUnit4ClassRunner.java:88)\n\tat org.junit.internal.runners.JUnit4ClassRunner.runMethods(JUnit4ClassRunner.java:51)\n\tat org.junit.internal.runners.JUnit4ClassRunner$1.run(JUnit4ClassRunner.java:44)\n\tat org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:27)\n\tat org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:37)\n\tat org.junit.internal.runners.JUnit4ClassRunner.run(JUnit4ClassRunner.java:42)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:45)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\n\nA testcase and repository.xml file will be attached shortly.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-42",
        "summary": "Workspace.move() and Session.move()  allow moves to an invalid path",
        "description": "When calling Workspace.move() with an invalid destination path, which is a child of the source path, e.g. move(\"/path\", \"/path/path2\"), results in the source path nodes being removed. When calling Session.move() the failure is a StackOverflowError when save is called.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2453",
        "summary": "Break the spi2dav dependency to jcr-server",
        "description": "Currently the spi2dav component has a dependency on the jcr-server component, which is troublesome due to the extra transitive dependencies and which strictly speaking should not be necessary from an architectural point of view.\n\nThe dependency exists mostly for sharing a number of JCR-specific WebDAV constants. I'd like to push those constants down to jackrabbit-webdav as they are essentially just shared strings and as jackrabbit-webdav already contains a number of constants used by JCR extensions.\n\nIn addition to constant values, code in the following classes is shared between jcr-server and spi2dav: JcrValueType, NamespacesProperty, NodeTypesProperty, SearchResultProperty, SubscriptionImpl, ValuesProperty. The shared code in JcrValueType and SubscriptionImpl is mostly just about mapping constant value mappings and could fairly easily be moved to jackrabbit-webdav. The Property classes are a but trickier, but it looks like it would be possible to split the code to separate server- and client-side classes for jcr-server and spi2dav.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1646",
        "summary": "NPE in OpenOfficeTextExtractor",
        "description": "I try to load some Open Office Writer document (see attachment) and receive such exception. \n\n2008-06-10 17:19:59 <WARN > [btpool0-1] CompositeTextExtractor: Failed to extract text content(92)\njava.lang.NullPointerException\n    at org.apache.jackrabbit.extractor.OpenOfficeTextExtractor.extractText(OpenOfficeTextExtractor.java:7\n8)\n    at org.apache.jackrabbit.extractor.CompositeTextExtractor.extractText(CompositeTextExtractor.java:90)\n    at org.apache.jackrabbit.core.query.lucene.JackrabbitTextExtractor.extractText(JackrabbitTextExtracto\nr.java:195)\n    at org.apache.jackrabbit.core.query.lucene.NodeIndexer.addBinaryValue(NodeIndexer.java:393)\n    at org.apache.jackrabbit.core.query.lucene.NodeIndexer.addValue(NodeIndexer.java:282)\n    at org.apache.jackrabbit.core.query.lucene.NodeIndexer.createDoc(NodeIndexer.java:221)\n    at org.apache.jackrabbit.core.query.lucene.SearchIndex.createDocument(SearchIndex.java:892)\n    at org.apache.jackrabbit.core.query.lucene.SearchIndex$2.next(SearchIndex.java:543)\n    at org.apache.jackrabbit.core.query.lucene.MultiIndex.update(MultiIndex.java:428)\n    at org.apache.jackrabbit.core.query.lucene.SearchIndex.updateNodes(SearchIndex.java:527)\n    at org.apache.jackrabbit.core.SearchManager.onEvent(SearchManager.java:504)\n    at org.apache.jackrabbit.core.observation.EventConsumer.consumeEvents(EventConsumer.java:231)\n    at org.apache.jackrabbit.core.observation.ObservationDispatcher.dispatchEvents(ObservationDispatcher.\njava:201)\n    at org.apache.jackrabbit.core.observation.EventStateCollection.dispatch(EventStateCollection.java:425\n)\n    at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:737\n)\n    at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:873)\n    at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:334)\n    at org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:337)\n    at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:310)\n    at org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:317)\n    at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1247)\n    at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:897)\n    at org.apache.jackrabbit.jca.JCASessionHandle.save(JCASessionHandle.java:178)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-525",
        "summary": "TCK: TextNodeTest and jcr:xmltext/jcr:xmlcharacters",
        "description": "Test creates jcr:xmltext nodes without jcr:xmlcharacters properties.  Some repositories may require jcr:xmltext nodes to have jcr:xmlcharacters properties, causing this test to fail.\n\nProposal: add a jcr:xmlcharacters property to each jcr:xmltext node.\n\n--- TextNodeTest.java   (revision 422074)\n+++ TextNodeTest.java   (working copy)\n@@ -62,6 +62,7 @@\n      */\n     public void testTextNodeTest() throws RepositoryException {\n         Node text1 = testRootNode.addNode(jcrXMLText);\n+        text1.setProperty(jcrXMLCharacters, \"foo\");\n         testRootNode.save();\n         String xpath = \"/\" + jcrRoot + testRoot + \"/text()\";\n         executeXPathQuery(superuser, xpath, new Node[]{text1});\n@@ -73,7 +74,9 @@\n      */\n     public void testTextNodeTestMultiNodes() throws RepositoryException {\n         Node text1 = testRootNode.addNode(jcrXMLText);\n+        text1.setProperty(jcrXMLCharacters, \"foo\");\n         Node text2 = testRootNode.addNode(nodeName1, testNodeType).addNode(jcrXMLText);\n+        text2.setProperty(jcrXMLCharacters, \"foo\");\n         testRootNode.save();\n         String xpath = \"/\" + jcrRoot + testRoot + \"//text()\";\n         executeXPathQuery(superuser, xpath, new Node[]{text1, text2});\n@@ -105,11 +108,13 @@\n             throw new NotExecutableException(\"Repository does not support position index\");\n         }\n         Node text1 = testRootNode.addNode(jcrXMLText);\n+        text1.setProperty(jcrXMLCharacters, \"foo\");\n         if (!text1.getDefinition().allowsSameNameSiblings()) {\n             throw new NotExecutableException(\"Node at path: \" + testRoot + \" does not allow same name siblings with name: \" + jcrXMLText);\n         }\n         testRootNode.addNode(nodeName1, testNodeType);\n         Node text2 = testRootNode.addNode(jcrXMLText);\n+        text1.setProperty(jcrXMLCharacters, \"foo\");\n         testRootNode.save();\n         String xpath = \"/\" + jcrRoot + testRoot + \"/text()[2]\";\n         executeXPathQuery(superuser, xpath, new Node[]{text2});\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1567",
        "summary": "Upgrade to PDFBox 0.7.3",
        "description": "while trying to upload a PDF document (which I can view fine with Acrobat Reader once it is loaded) I get the following exception: \n\n01.05.2008 12:24:44 *WARN * PdfTextExtractor: Failed to extract PDF text content (PdfTextExtractor.java, line 91)\njava.io.IOException: Error: Expected an integer type, actual='%%EOF'\n        at org.pdfbox.pdfparser.BaseParser.readInt(BaseParser.java:1159)\n        at org.pdfbox.pdfparser.PDFParser.parseObject(PDFParser.java:349)\n        at org.pdfbox.pdfparser.PDFParser.parse(PDFParser.java:132)\n        at org.apache.jackrabbit.extractor.PdfTextExtractor.extractText(PdfTextExtractor.java:69)\n        at org.apache.jackrabbit.extractor.CompositeTextExtractor.extractText(CompositeTextExtractor.java:90)\n        at org.apache.jackrabbit.core.query.lucene.JackrabbitTextExtractor.extractText(JackrabbitTextExtractor.java:195)\n        at org.apache.jackrabbit.core.query.lucene.NodeIndexer.addBinaryValue(NodeIndexer.java:393)\n ....\n\nI replaced the version of pdfbox (0.6.4) that is bundled with the jackrabbit war file with a more recent version (0.7.3 and fontbox 01.) and it worked fine. The bundled versions should be upgraded.\n\nOn the other hand, this software appears to be inactive. Probably a different package should be selected in the long run, but for now, a simple upgrade will do the trick.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2851",
        "summary": "Authentication Mechanism Based on Login Token",
        "description": "implementing an authentication mechanism that apart from simple credentials allows for credentials being built on a login token\ncould rely on the fact that jackrabbit stores the user data in the repository: adding additional information (generated tokens, expiration time, \nadditional security parameters) could be stored in additional subnodes to the user and used for matching during login as alternative\nways to authenticate against the system.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2164",
        "summary": "Change security configuration from 'simple' to the some reasonable default",
        "description": "I'd like to change the security configuration from 'simple' to a default that enables ac-management and user management (and consequently doesn't skip the corresponding tests).\n\nthere is currently an issue with WEAKREFERENCEs (see issue JCR-2135) that prevents me from changing the config.\nunless someone objects i would like to change the default config as soon as JCR-2135 is solved.\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "TASK"
    },
    {
        "key": "JCR-1137",
        "summary": "test cases relying on Node.equals()",
        "description": "Several test cases rely on Node.equals to compare nodes, where instead isSame() should be used:\n\norg.apache.jackrabbit.test.api.NodeTest.testNodeIdentity(NodeTest.java:751)\norg.apache.jackrabbit.test.api.NodeTest.testNodeIdentity(NodeTest.java:753)\norg.apache.jackrabbit.test.api.version.VersionHistoryTest.testInitallyGetAllVersionsContainsTheRootVersion(VersionHistoryTest.java:126)\norg.apache.jackrabbit.test.api.version.VersionHistoryTest.testGetVersion(VersionHistoryTest.java:180)\norg.apache.jackrabbit.test.api.version.CheckinTest.testMultipleCheckinHasNoEffect(CheckinTest.java:93)\norg.apache.jackrabbit.test.api.version.VersionGraphTest.testInitialBaseVersionPointsToRootVersion(VersionGraphTest.java:47)\norg.apache.jackrabbit.test.api.version.RemoveVersionTest.testRemoveVersionAdjustPredecessorSet(RemoveVersionTest.java:120)\norg.apache.jackrabbit.test.api.version.RemoveVersionTest.testRemoveVersionAdjustSucessorSet(RemoveVersionTest.java:144)\n\n ",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1598",
        "summary": "Problematic exception handling in Jackrabbit WebApp",
        "description": "In this project, the cause of the exception is often ignored, and only the message of the cause is used, as in:\n\n} catch (Exception e) {\n    log.error(\"Error in configuration: {}\", e.toString());\n    throw new ServletException(\"Error in configuration: \" + e.toString());\n}\n\nAn additional problem is that when using ServletException(String message, Throwable rootCause), the rootCause is not used in printStackTrace(), that means the cause is not logged. See also: http://closingbraces.net/2007/11/27/servletexceptionrootcause/\n\nIt is therefore better to convert \n  throw new ServletException(\"Unable to create RMI repository. jcr-rmi.jar might be missing.\", e);\nto\n  ServletException s = new ServletException(\"Unable to create RMI repository. jcr-rmi.jar might be missing.\");\n  s.initCause(e);\n  throw s;\n\n\n\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2567",
        "summary": "please have spi2dav create a test-jar",
        "description": "for my davex-on-sling integration tests, I need the test classes from spi2dav.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2120",
        "summary": "java.lang.Iterable support for RangeIterators",
        "description": "Make javax.jcr.RangeIterator extend java.lang.Iterable in order to enable foreach loops on implementations of RangeIterator.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-906",
        "summary": "Introduce similarity function",
        "description": "The query handler should support a similarity function that allows one to find nodes that are similar to a given existing one.\n\nExample:\n\n//*[rep:similar(\"/foo/bar\")]\n\nFinds nodes that are similar to node /foo/bar.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-414",
        "summary": "jcr:successors property not persisted correctly within a transaction",
        "description": "During a transaction, if you create a new version then read the version history the \"jcr:successors\" property is not updated. Note that \"jcr:predecessors\" is updated properly.\n\nAlso, the version history is sometimes not propertly read. During the transaction, it might appear empty. This behavior in not consistent from one execution to another.\n\nAfter a restart of the repository, the version history and the \"jcr:successors\" property is read properly.\n\n* Tests cases will follow shortly.\n\nThanks, \n\nNicolas",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2193",
        "summary": "builtin_nodetypes.cnd contains non-ascii chars and is not correctly decoded using websphere",
        "description": "jackrabbit can't be started within websphere with the following error:\n\nCaused by: \norg.apache.jackrabbit.spi.commons.nodetype.compact.ParseException: IOException\nwhile attempting to read input stream\n(org/apache/jackrabbit/core/nodetype/builtin_nodetypes.cnd, line 272)\n.\n.\nCaused by: \nsun.io.MalformedInputException\n\tat sun.io.ByteToCharUTF8.convert(ByteToCharUTF8.java:262)\n\tat sun.nio.cs.StreamDecoder$ConverterSD.convertInto(StreamDecoder.java:314)\n\tat sun.nio.cs.StreamDecoder$ConverterSD.implRead(StreamDecoder.java:345)\n\n\nI quickly checked the file and it contains some non ascii-7 characters. actually it should be stored, packaged and read as utf8. somthing was list in translation.\nthe simplest fix would be to remove all non-ascii7 characters from the file.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-628",
        "summary": "OutOfMemory problem: HandleMonitor does not release closed input streams",
        "description": "The class o.a.j.core.fs.local.HandleMonitor does not release closed MonitoredInputStream. There is a close method, but it is never called. The input streams are kept in a hash set / map of HandleMonitor. Eventually, this leads to an OutOfMemory exception after opening / closing many files.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1127",
        "summary": "Text extractor classes are obsolete in web",
        "description": "Text extractor classes are obsolete in http://jackrabbit.apache.org/doc/components/index-filters.html\n\n\"org.apache.jackrabbit.core.query\" are actually \"org.apache.jackrabbit.extractor\"\n\nPlain text extractor continue being \"org.apache.jackrabbit.core.query.lucene.TextPlainTextFilter\"? ",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-101",
        "summary": "misleading contrib/tck-webapp/...RepositoryServlet javadoc",
        "description": "In org.apache.jackrabbit.tck.j2ee.RepositoryServlet it says \"...puts the reference into the application context\" but according to the behavior it should say \"...puts the reference into a class variable\". In a j2ee environment the application context refers to the ServletConext instance bounded to the web application.\n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-2728",
        "summary": "Exclude JavaCC-generated code from static analysis",
        "description": "The JavaCC-generated code we have in spi-commons should be excluded from static analysis done by tools like Sonar.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1715",
        "summary": "Prevent excessive Path.Element instances",
        "description": "Even when a CachingHierarchyManager is used jackrabbit creates a lot of Path.Element instances. The internally used PathMap (spi-commons) creates new Path.Element instances whenever a path is constructed, even when the path is constructed from cached PathMap.Elements.\n\nRunning a test with 10k nodes results in 250k Path.Element instances being created and held in memory (mostly for events).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2816",
        "summary": "Repository is not unlocked if version manager init failed and assertions are enabled",
        "description": "The following test case will work as expected, except when assertions are enabled (java -ea ...):\n\nConnection conn = DriverManager.getConnection(\n        \"jdbc:derby:repository/version/db;create=true\");\nStatement stat = conn.createStatement();\nstat.execute(\"create table version_bundle(id int)\");\nTransientRepository rep = new TransientRepository();\ntry {\n    rep.login(new SimpleCredentials(\"\", new char[0]));\n} catch (Exception e) {\n    // ignore\n}\nrep.shutdown();\nstat.execute(\"drop table version_bundle\");\nnew TransientRepository().login(new SimpleCredentials(\"\", new char[0]));\n\nThe reason is the assertion in RepositoryContext.getInternalVersionManager. Because of this assertion, the repository lock is not released during the repository shutdown.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3250",
        "summary": "webapp welcome page shows incorrect port when port is the default port",
        "description": "See summary.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1492",
        "summary": "Make behaviour configurable when re-indexing detects workspace inconsistency",
        "description": "Currently the query handler throws an exception and the repository will not start.\n\nThere are multiple options how to deal with this situation:\n\n1) fail and repository startup will fail\n2) ignore and proceed\n3) fix the inconsistency and proceed\n\n1) and 2) can be implemented quite easily. with the recent enhancement JCR-1428, 3) can also be implemented with reasonable effort.\n\nIn any case an error message should be written to the log.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-661",
        "summary": "RMIC not working in subprojects when compiling parent using maven2",
        "description": "This is because there is a bug such that if you have a child build which uses the ant plugin it inherits the plugin dependencies of the first time the plugin is declared.\n\nThe workaround is to put the antrun plugin in the toplevel, and add the java jar to its plugin dependencies.\n\n(reference: http://mail-archives.apache.org/mod_mbox/maven-users/200602.mbox/%3CC2CDEFBECFC9A14892BCCFB4C95F4868044F8230@EX-201.mail.navisite.com%3E)",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-144",
        "summary": "Path parser does not allow trailing slashes",
        "description": "The current implementation of the Path class violates the spec in that the trailing slashes are not allowed while the path syntax clearly allows trailing slashes.\n\n(Of course the Path class violates the spec in another way, too, in that it allows for the root path \"/\" to be valid while the path syntax in the spec does not allow that, which is clearly an error of the spec of course).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1580",
        "summary": "Typo in PropertyDefinitionTemplate",
        "description": "setValueConstarints should read setValueConstraints\n\n\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "BUG"
    },
    {
        "key": "JCR-15",
        "summary": "PersistentNode.store() ignores status when storing",
        "description": "While looking for a performance bottle neck I came across this issue: When a PersistentNodeState is asked to store itself in the PersistentNodeState.store() method, it calls its PersistenceManager to store it.\n\nThis is not a problem in itself. The problem is, that if the PersistentNodeState has not been modified, the object does not need to be stored. Doiing it anyway just consumes cycles ! In the case of a deep, unmodified hierarchy, this just results in nodes being written to persistence for nothing.\n\nComes to it, that this method sends an event, which in the case of an unmodified node state will be notifyStateUpdated(), which is complete nonsense, because nothing has actually been updated.\n\nI suggest to modify the PersistentNodeState.store() method to only do work if modified.\n\nNote: I encountered this issue, whily tracking down performance problems when creating versionable nodes, which turned out to be located somewhere within the PersistentVersionManager.createVersionHistory(NodeImpl) method. And there, predominantly the store() methods consume time.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3114",
        "summary": "expose PM for versioning manager so that the consistency check can be run from test cases",
        "description": "We need to be able to run the PM consistency checks for the versioning store as well.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": ""
    },
    {
        "key": "JCR-369",
        "summary": "IllegalNameException when importing document view with two mixins",
        "description": "As reported by Manuel Simoni on the dev mailing list:\n\n----\n\nI have nodes with two mixin types, s1NT:comment and s1NT:authored.\n\nI am exporting the document view:\n\nsession.exportDocumentView(session.getRootNode().getPath(),\noutputStream, false, false);\n\nWhen I try to import the document again:\n\nsession.getWorkspace().importXML(session.getRootNode().getPath(),\ninputStream, ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);\n\n...I get this exception:\n\njava.lang.Exception: javax.jcr.InvalidSerializedDataException: failed to\nparse XML stream: illegal jcr:mixinTypes value: s1NT:comment\ns1NT:authored: illegal jcr:mixinTypes value: s1NT:comment s1NT:authored\n       at\nat.systemone.wiki.webservice.ImportControllerImpl.importDocumentView(ImportControllerImpl.java:30)\n       at\nat.systemone.wiki.webservice.ImportControllerTest.testImport(ImportControllerTest.java:12)\n       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n       at\nsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n       at\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n       at java.lang.reflect.Method.invoke(Method.java:585)\n       at junit.framework.TestCase.runTest(TestCase.java:154)\n       at junit.framework.TestCase.runBare(TestCase.java:127)\n       at junit.framework.TestResult$1.protect(TestResult.java:106)\n       at junit.framework.TestResult.runProtected(TestResult.java:124)\n       at junit.framework.TestResult.run(TestResult.java:109)\n       at junit.framework.TestCase.run(TestCase.java:118)\n       at junit.framework.TestSuite.runTest(TestSuite.java:208)\n       at junit.framework.TestSuite.run(TestSuite.java:203)\n       at\norg.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)\n       at\norg.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)\n       at\norg.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\nCaused by: javax.jcr.InvalidSerializedDataException: failed to parse XML\nstream: illegal jcr:mixinTypes value: s1NT:comment s1NT:authored:\nillegal jcr:mixinTypes value: s1NT:comment s1NT:authored\n       at\norg.apache.jackrabbit.core.WorkspaceImpl.importXML(WorkspaceImpl.java:718)\n       at\nat.systemone.wiki.webservice.ImportControllerImpl.importDocumentView(ImportControllerImpl.java:27)\n       ... 16 more\nCaused by: org.apache.jackrabbit.name.IllegalNameException:\n's1NT:comment s1NT:authored' is not a valid name\n       at\norg.apache.jackrabbit.core.xml.DocViewImportHandler.startElement(DocViewImportHandler.java:217)\n       at\norg.apache.jackrabbit.core.xml.ImportHandler.startElement(ImportHandler.java:234)\n       at org.apache.xerces.parsers.AbstractSAXParser.startElement(Unknown Source)\n       at\norg.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown\nSource)\n       at\norg.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown\nSource)\n       at\norg.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown\nSource)\n       at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n       at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n       at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)\n       at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)\n       at\norg.apache.jackrabbit.core.WorkspaceImpl.importXML(WorkspaceImpl.java:709)\n       ... 17 more\n\nI think the importer chokes on this node (it is the first node with\nthese two mixin types in the XML file):\n\n<s1:comment jcr:primaryType=\"s1NT:page\" jcr:mixinTypes=\"s1NT:comment\ns1NT:authored\" jcr:uuid=\"3ff1022b-3e21-4e44-9a2e-ae3b67e833e5\"\njcr:isCheckedOut=\"true\"\njcr:versionHistory=\"17186f20-dab2-42d8-8f66-0895472debea\"\njcr:frozenMixinTypes=\"s1NT:comment s1NT:authored\"\njcr:frozenUuid=\"3ff1022b-3e21-4e44-9a2e-ae3b67e833e5\"\ns1:author=\"8db75ec7-eee8-44d8-aeb2-fbd116ea7e01\" s1:title=\"\"\njcr:predecessors=\"fb9eefb2-e2f8-414c-be94-185111a89be9\"\ns1:creationDate=\"2005-09-07T17:59:12.589Z\"\ns1:editor=\"7b778c51-d8d8-474b-a621-f5759fc24cd0\" s1:orphanedPage=\"false\"\ns1:modificationDate=\"2006-03-18T17:55:49.838Z\" s1:lowercaseTitle=\"\"\njcr:baseVersion=\"fb9eefb2-e2f8-414c-be94-185111a89be9\"\ns1:currentEditor=\"8db75ec7-eee8-44d8-aeb2-fbd116ea7e01\"\njcr:frozenPrimaryType=\"s1NT:page\">\n\n----\n\nThis issue is related to JCR-325, but there should be a lot easier fix for this special case.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-805",
        "summary": "Introduce a temprary cache for intermediate query results",
        "description": "Sometimes queries execute the same sub query multiple times.\n\ne.g. //element(*, nt:resource)[@jcr:mimeType != 'text/plain' and @jcr:mimeType != 'text/html']\n\nwill result in two internal MatchAllQuery on jcr:mimeType. The query should re-use the previously calculated results when possible.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2862",
        "summary": "Jackrabbit logs a NullPointerException on shutdown if the version manager wasn't initialized",
        "description": "If opening the repository fails, and the version manager was not initialized, then the shutdown method logs a NullPointerException when trying to close the version manager. This is a nuisance.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2119",
        "summary": "Method to create default RepositoryConfig from just the repository directory",
        "description": "It would be useful to have a static method like RepositoryConfig.create(File) that would take the repository directory and expect to find the repository configuration in a \"repository.xml\" file inside that directory.\n\nIf the directory does not exist, it would be created. And if the repository configuration file does not exist, then it would be created from the default configuration included in Jackrabbit.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3247",
        "summary": "SQL2 ISDESCENDANTNODE BooleanQuery#TooManyClauses returns",
        "description": "The initial fix is not generic enough. It still fails after adding twice the max clauses count.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2900",
        "summary": "DbClusterTest failure due to network configuration",
        "description": "As reported by Serge, the DbClusterTest case fails when run with certain network configuration.\n\nThomas already suggested a fix:\n\n### Eclipse Workspace Patch 1.0\n#P jackrabbit-core\nIndex: src/test/java/org/apache/jackrabbit/core/cluster/DbClusterTest.java\n===================================================================\n--- \nsrc/test/java/org/apache/jackrabbit/core/cluster/DbClusterTest.java (revisi\non 1067983)\n+++ \nsrc/test/java/org/apache/jackrabbit/core/cluster/DbClusterTest.java (workin\ng copy)\n@@ -37,9 +37,9 @@\n     public void setUp() throws Exception {\n         deleteAll();\n         server1 = Server.createTcpServer(\"-tcpPort\", \"9001\", \"-baseDir\",\n-                \"./target/dbClusterTest/db1\").start();\n+                \"./target/dbClusterTest/db1\", \"-tcpAllowOthers\").start();\n         server2 = Server.createTcpServer(\"-tcpPort\", \"9002\", \"-baseDir\",\n-                \"./target/dbClusterTest/db2\").start();\n+                \"./target/dbClusterTest/db2\", \"-tcpAllowOthers\").start();\n         FileUtils.copyFile(\n                 new\nFile(\"./src/test/resources/org/apache/jackrabbit/core/cluster/repository-h2\n.xml\"),\n                 new File(\"./target/dbClusterTest/node1/repository.xml\"));\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-622",
        "summary": "Auto Reconnect for RMI Repository",
        "description": "If i bind the RepositoryAccessServlet to a RMI Repository and then reboot the Repository i get a\nNullpointerException. \nStack :\njava.lang.NullPointerException\n\tat org.apache.jackrabbit.webdav.jcr.JcrDavException.<init>(JcrDavException.java:111)\n\tat org.apache.jackrabbit.webdav.simple.DavSessionProviderImpl.attachSession(DavSessionProviderImpl.java:99)\n\tat org.apache.jackrabbit.server.AbstractWebdavServlet.service(AbstractWebdavServlet.java:181)\n\nIf i deploy jackrabbit in a Model 3 Environment this Situation can happen very often.\nthanks\nclaus",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-528",
        "summary": "TCK: GetPersistentQueryPathTest and SaveTest require nt:query",
        "description": "GetPersistentQueryPathTest and SaveTest require implementation to support nt:query node type.  This is an optional node type.\n\nProposal: throw NotExecutableException if nt:query not in node type registry\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-3259",
        "summary": "augment logging information around CachingEntryCollector",
        "description": "add more logging information for the purpose of debugging CachingEntryCollector bottlenecks",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": ""
    },
    {
        "key": "JCR-1178",
        "summary": "Rethrow exception with cause in BundleDbPersistenceManager",
        "description": "An exception forwarded from SQL should have a cause for better diagnosis.\n\nIndex: jackrabbit-core/src/main/java/org/apache/jackrabbit/core/persistence/bundle/BundleDbPersistenceManager.java\n===================================================================\n--- jackrabbit-core/src/main/java/org/apache/jackrabbit/core/persistence/bundle/BundleDbPersistenceManager.java (revision 585555)\n+++ jackrabbit-core/src/main/java/org/apache/jackrabbit/core/persistence/bundle/BundleDbPersistenceManager.java (working copy)\n@@ -604,7 +604,7 @@\n             }\n             return nameIndex;\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Unable to create nsIndex: \" + e);\n+            throw new IllegalStateException(\"Unable to create nsIndex\", e);\n         }\n     }\n ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3054",
        "summary": "Deprecate RepositoryService.getPropertyInfo method",
        "description": "I would like to deprecate and ultimately remove the RepositoryService.getPropertyInfo method and extend RepositoryService.getItemInfos to take over that functionality. getItemInfos would thus change to\n\n    /**\n     * Method used to 'batch-read' from the persistent storage. It returns the\n     * <code>ItemInfo</code> for the given <code>ItemId</code> as the first\n     * element in the <code>Iterator</code>. In addition the iterator may contain\n     * arbitrary <code>ItemInfo</code>s.\n     */\n    public Iterator<? extends ItemInfo> getItemInfos(SessionInfo sessionInfo, ItemId itemId) throws ItemNotFoundException, RepositoryException;\n\n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2408",
        "summary": "Mixin removal exception",
        "description": "When trying to remove a mixin from a non nt:unstructured node (in my case nt:resource), you get the following exception:\n\nUnable to alter mixin types: javax.jcr.nodetype.ConstraintViolationException: no matching property definition found for {http://www.day.com/jcr/cq/1.0}lastRolledout\n\nlastRolledout property is defined by the mixin cq:LiveRelationship that I am trying to remove.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-314",
        "summary": "Fine grained locking in SharedItemStateManager",
        "description": "The SharedItemStateManager (SISM) currently uses a simple read-write lock to ensure data consistency. Store operations to the PersistenceManager (PM) are effectively serialized.\n\nWe should think about more sophisticated locking to allow concurrent writes on the PM.\n\nOne possible approach:\n\nIf a transaction is currently storing data in a PM a second transaction may check if the set of changes does not intersect with the first transaction. If that is the case it can safely store its data in the PM.\n\nThis fine grained locking must also be respected when reading from the SISM. A read request for an item that is currently being stored must be blocked until the store is finished.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-975",
        "summary": "NodeImpl.checkin() calls save() three times",
        "description": "The version related properties on a versionable node that is checked in are saved individually. There is no need to save them individually because such a node must not have pending changes and save() can be called safely on the node itself.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2578",
        "summary": "Deprecate XASession",
        "description": "The XASession interface in jackrabbit-api extends Session with a single getXAResource() method. The idea is that a transactional client (or a transaction manager) will test whether a session implements XASession and can then get the XAResource instance that can be used to bind the session to a distributed transaction. The essential code is:\n\n    if (session instanceof XASession) {\n        return ((XASession) session).getXAResource();\n    }\n\nThis works fine except for the extra dependency to jackrabbit-api that it introduces in code that otherwise would only need the JCR API. Since the link between a transaction-enabled session and the related XAResource instance is always one-to-one, we could avoid this dependency by making the session directly implement XAResource, leading to code like this:\n\n    if (session instanceof XAResource) {\n        return (XAResource) session;\n    }\n\nThis is essentially what jackrabbit-jcr-rmi did in 2.0.0 to avoid the jackrabbit-api dependency while maintaining XA transaction support, and I'd like to extend this solution also to other parts of Jackrabbit.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-842",
        "summary": "support stores where binary properties are mandatory (such as in nt:resource)",
        "description": "SetValueBinaryTest tries to remove binary properties by setting them to null. However, some stores only support binary properties in the case of jcr:content/jcr:data, in which case the property can not be removed directly.\n\nSuggestion: check for mandatory/protected, and throw NotExecutableException in that case.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1650",
        "summary": "XPathQueryBuilder may not handle multiple jcr:deref correctly",
        "description": "If you have the following tree (inspired from DerefTest) :\n+ people\n   + carl (worksfor -> company/microsoft)\n   + frank (worksfor -> company/microsoft)\n+ company\n    + microsoft (eotm -> carl)\n\nThe following queries will be translated to :\n\ntestroot/people/frank/jcr:deref(@worksfor, '*')/jcr:deref(@eotm, '*')\n+ Root node\n+ Select properties: *\n  + PathQueryNode\n    + LocationStepQueryNode:  NodeTest={}testroot Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}people Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}frank Descendants=false Index=NONE\n    + DerefQueryNode:  NodeTest=* Descendants=false Index=NONE\n    + DerefQueryNode:  NodeTest=* Descendants=false Index=NONE\n=> Matching carl node\n\ntestroot/people/frank/jcr:deref(@worksfor, '*')/jcr:deref(@eotm, '*')[@jcr:uuid]\n+ Root node\n+ Select properties: *\n  + PathQueryNode\n    + LocationStepQueryNode:  NodeTest={}testroot Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}people Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}frank Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest=* Descendants=false Index=NONE\n    + DerefQueryNode:  NodeTest=* Descendants=false Index=NONE\n      + RelationQueryNode: Op: NOT NULL Prop=@{http://www.jcp.org/jcr/1.0}uuid\n=> Not matching carl node\n\ntestroot/people/frank/jcr:deref(@worksfor, '*')[@jcr:uuid]/jcr:deref(@eotm, '*')[@jcr:uuid]\n+ Root node\n+ Select properties: *\n  + PathQueryNode\n    + LocationStepQueryNode:  NodeTest={}testroot Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}people Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}frank Descendants=false Index=NONE\n    + DerefQueryNode:  NodeTest=* Descendants=false Index=NONE\n      + RelationQueryNode: Op: NOT NULL Prop=@{http://www.jcp.org/jcr/1.0}uuid\n    + DerefQueryNode:  NodeTest=* Descendants=false Index=NONE\n      + RelationQueryNode: Op: NOT NULL Prop=@{http://www.jcp.org/jcr/1.0}uuid\n=> Matching carl node\n\ntestroot/people/frank/jcr:deref(@worksfor, '*')[@jcr:uuid]/jcr:deref(@eotm, '*')\n+ Root node\n+ Select properties: *\n  + PathQueryNode\n    + LocationStepQueryNode:  NodeTest={}testroot Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}people Descendants=false Index=NONE\n    + LocationStepQueryNode:  NodeTest={}frank Descendants=false Index=NONE\n    + DerefQueryNode:  NodeTest=* Descendants=false Index=NONE\n      + RelationQueryNode: Op: NOT NULL Prop=@{http://www.jcp.org/jcr/1.0}uuid\n    + DerefQueryNode:  NodeTest=* Descendants=false Index=NONE\n=> Matching carl node\n\nThis is because XPathQueryBuilder calls NAryQueryNode#removeOperand(QueryNode)\nin order to replace current LocationStepQueryNode with a DerefQueryNode.\n\nNAryQueryNode#removeOperand(QueryNode) uses internally a List and thus\nrelies on Object#equals(Object) for retrieving the object to remove.\n\nBut the equals method is redefined for every QueryNode with a different semantic.\n\nThen, the call to NAryQueryNode#removeOperand(QueryNode) will not remove the\nwanted operand but the first operand returning true after calling equals in\nArrayList#remove(Object).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-138",
        "summary": "Typo in log output",
        "description": "jackrabbit/src/java/org/apache/jackrabbit/core/fs/local/LocalFileSystem.java:\n133c133\n<         log.info(\"LocaaFileSystem initialized on \" + root.getPath());\n---\n>         log.info(\"LocalFileSystem initialized on \" + root.getPath());\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2875",
        "summary": "Exclude the netcdf dependency",
        "description": "As discussed on the mailing list, the netcdf dependency we get through Tika since version 0.8 is only used in very rare cases and thus does not justify the added size overhead. We should thus exclude it from default installations.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1475",
        "summary": "Inconsistency when version with a label is removed",
        "description": "While executing random operations on the version storage I came across a situation where a version is removed that has a version label.\n\nThe current behaviour in jackrabbit is IMO not correct because the version node gets removed, but the version label is still present in the version history. This means there is a referenceable property that points to nowhere.\n\nSo I guess either:\n\n- the version label property must be removed as well when the version is removed\nor\n- the remove version operation should fail because the version is still referenced\n\nI wasn't able to find a relevant section in the spec, though I must admit that I don't know the versioning section that well.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3189",
        "summary": "JCARepositoryManager.createNonTransientRepository throws NPE with no JCAManagedConnectionFactory.CONFIGFILE_KEY",
        "description": "JCARepositoryManager.createNonTransientRepository fails if\n\nString configFile = parameters.get(JCAManagedConnectionFactory.CONFIGFILE_KEY);\n\nis null, because\n\nconfig = RepositoryConfig.create(configFile, homeDir);\n\nwill always throw an NPE, perhaps the call should just be\n\nconfig = RepositoryConfig.create(homeDir);\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2886",
        "summary": "Add SessionImpl#isAdminOrSystem",
        "description": "we have several places in jackrabbit-core where we need to find out if the executing session is either a SystemSession or corresponds to the admin user.\ncurrently the same code (analysing the sessions subject) is copied throughout jackrabbit-core. i would like to replace that by a helper method on SessionImpl.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2413",
        "summary": "AlreadyClosedException on initial index creation",
        "description": "Happens when the indexing queue is checked while creating an initial index. This is probably a regression caused by JCR-2035.\n\nCaused by: org.apache.lucene.store.AlreadyClosedException: this Directory is closed\n        at org.apache.lucene.store.Directory.ensureOpen(Directory.java:220)\n        at org.apache.lucene.store.FSDirectory.getFile(FSDirectory.java:533)\n        at org.apache.jackrabbit.core.query.lucene.directory.FSDirectoryManager$FSDir.list(FSDirectoryManager.java:149)\n        at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:533)\n        at org.apache.lucene.index.DirectoryIndexReader.open(DirectoryIndexReader.java:115)\n        at org.apache.lucene.index.IndexReader.open(IndexReader.java:316)\n        at org.apache.lucene.index.IndexReader.open(IndexReader.java:263)\n        at org.apache.jackrabbit.core.query.lucene.AbstractIndex.getIndexReader(AbstractIndex.java:245)\n        at org.apache.jackrabbit.core.query.lucene.AbstractIndex.removeDocument(AbstractIndex.java:225)\n        at org.apache.jackrabbit.core.query.lucene.PersistentIndex.removeDocument(PersistentIndex.java:90)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex$DeleteNode.execute(MultiIndex.java:1952)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.executeAndLog(MultiIndex.java:1085)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.checkIndexingQueue(MultiIndex.java:1308)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1177)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1191)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1191)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1191)\n[...]\n\nI assume there is an index merge happening at the same time that closes index segments.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1709",
        "summary": "Remove Serializable on ItemState classes",
        "description": "ItemStates are never directly serialized, which means they don't have to implement Serializable anymore.\n\nSee also: http://markmail.org/message/wsqnih2lembkcrdf",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1597",
        "summary": "JCARepositoryHandle.login(...) methods never throw NoSuchWorkspaceException",
        "description": "Call sequence:\n  JCARepositoryHandle.login(Credentials, String)      // (here non-existent workspace is specified for login)\n    JCARepositoryHandle.login(JCAConnectionRequestInfo)\n      ConnectionManager.allocateConnection(ManagedConnectionFactory, ConnectionRequestInfo)\n        ...\n          JCAManagedConnection.openSession(JCAConnectionRequestInfo)\n            Repository.login(Credentials, String)        // here NoSuchWorkspaceException is thrown, catched by JCAManagedConnection.openSession(JCAConnectionRequestInfo), _set as linkedException_ to ResourceException, which is thrown\n        ...\n     Here (in JCARepositoryHandle.login(JCAConnectionRequestInfo)) ResourceException is caught, its _cause_ is retreived, and, if cause is NoSuchWorkspaceException, it's thrown, else another exception is thrown.\n\nNote, that when exception occures on lower level, it's wrapped in ResourceException using setLinkedException(), but on upper level it's unwrapped using getCause(). But cause is not set by anyone, it's null, so NoSuchWorkspaceException is never thrown here.\n\nSuggested fix is to use same mechanism on both ends: either change wrapping mechanism to exception chaining (new ResourceException(msg, cause)), or unwrap using ResourceException.getLinkedException().",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-420",
        "summary": "NullPointerException when deleting a property of type REFERENCE",
        "description": "In method org.apache.jackrabbit.rmi.value.SerialValueFactory#createValue a NPE is thrown when parameter value is null.\n\nSolution:\n\nChange:\n\n   public final Value createValue(Node value) throws RepositoryException {\n        return createValue(value.getUUID(), PropertyType.REFERENCE);\n    }\n\nto\n\n   public final Value createValue(Node value) throws RepositoryException {\n        if (value == null) {\n           return null;\n        }\n        \n        return createValue(value.getUUID(), PropertyType.REFERENCE);\n    }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-808",
        "summary": "Better error message for non-trivial nodetype changes",
        "description": "Currently Jackrabbit only throws a RepositoryException with the message \"Not yet implemented\". This says almost nothing to newcomers and is very time consuming to debug even if you know what is means. It would be better to use the information already availble through NodeTypeDefDiff to provide a more descriptive error message.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1442",
        "summary": "FSImport.java link on wiki is dead",
        "description": "The link for FSImport.java \n\nhttp://svn.apache.org/repos/asf/jackrabbit/trunk/contrib/examples/src/java/org/apache/jackrabbit/examples/FSImport.java\n\nfrom wiki page\n\n\nhttp://wiki.apache.org/jackrabbit/ExamplesPage\n\nis dead, could it be updated please?\n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "TASK"
    },
    {
        "key": "JCR-177",
        "summary": "Commit volatile index to disc after some configurable idle time",
        "description": "The query handler keeps the most recent part of the index in memory (volatile index). That index is committed to disc when a certain amount of nodes (config param: minMergeDocs) has been added. Most of the times the volatile index will contain some nodes, causing a redo.log that needs to be applied when the jackrabbit process is killed.\n\nIn addition to the size threshold (minMergeDocs) of the volatile index, an idle time limit should force a commit to disc. The volatile index would be written to disc after some configurable idle time. This will result in an persistent index (on dic) which is most of the time in sync with the data, but still minimizes the disc IO during heavy modification activity on the workspace.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1420",
        "summary": "Add test for Node.restore() may throw InvalidStateException",
        "description": "Add a unit test for JCR-1399 in the 1.3 branch.\n\nA test for the original feature in the trunk/1.4 (JCR-1197) needs a separate issue. ",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-1302",
        "summary": "ArrayHits does not end properly when skipTo doesn't find document",
        "description": "If skipTo(target) does not find a document that that has a higher value than the target, it falls out of the loop and calls next() possibly returning a previously found document. The patch makes sure that -1 is returned in this case, otherwise confusing results might occur.\n\nIndex: src/main/java/org/apache/jackrabbit/core/query/lucene/hits/ArrayHits.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/core/query/lucene/hits/ArrayHits.java\t(revision 608900)\n+++ src/main/java/org/apache/jackrabbit/core/query/lucene/hits/ArrayHits.java\t(working copy)\n@@ -87,9 +87,9 @@\n             int nextDocValue = hits[i];\n             if (nextDocValue >= target) {\n                 index = i;\n-                break;\n+                return next();\n             }\n         }\n-        return next();\n+        return -1;\n     }\n }\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2703",
        "summary": "UserManagement: Add Membership Cache",
        "description": "due to weakreference nature of the group members, retrieving the groups a given authorizable is member is expensive as the corresponding\nAPI call (Node#getWeakReferences) executes a query [fallback if search is disabled: traversing the complete group tree, which isn't for free either].\n\ni would therefore suggest to add a cache (authorizable nodeId -> group nodeids) that is gets cleared upon any modification to group membership or\ngroup removal and doesn't need any extra observation. this cache may potentially obsolete the principal-based cache in DefaultPrincipalProvider... ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1719",
        "summary": "Make the extraction of Session UserIDs from Subjects configurable",
        "description": "The SessionImpl class must extract a string name from the Prinicpals in a Subject to use as the Session userID.  In 1.4 the SessionImpl class directly selects the first available Principal.  In 1.5, this is delegated to the SecurityManager, which chooses the first  non-group principal.\n\nIt would be useful to be able to configure specific selection criteria for the Principal used for the Session userID.  A simple mechanism would involve specifying a Principal implementation classname in the configuration, and the first instance of that class found in the Subject would be used for the userID.  One way to implement this in 1.4 would be to extend AuthContext to include a method getSessionPrincipal() which encapsulates the selection logic, and adding an option the LoginModuleConfig to specify the class name of the Principal to select.\n\nA particular use case is using the LDAP LoginModule from Sun JDK 6 with the repository.  The first Principal LdapLoginModule populates into the Subject is an instance of LdapPrincipal, which renders the userID as the full DN of the user.  The LoginModule also adds an instance of UserPrincipal, whose name is the simple username/uid attribute, which would be more appropriate as the Session userId since it corresponds to the username provided by the user to application authentication mechanisms (the provided username is expanded into the full DN prior to authentication by the login module).  If the above configuration mechanism were available, one could configure the LdapLoginModule, and specify that the userID be extracted from the first instance of com.sun.security.auth.UserPrincipal.  Since rewriting LoginModules is not always possible or desirable, this change would enable the stable integration of 3rd-party login modules that may populate the Subject with several principals.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-111",
        "summary": "org.apache.lucene.search.BooleanQuery$TooManyClauses when using '>' operator",
        "description": "when using a query with a '>' operator, the query engine does not scale with number of matching properties and a org.apache.lucene.search.BooleanQuery$TooManyClauses exception is thrown",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-959",
        "summary": "Remove @author tags in jackrabbit-jcr-rmi",
        "description": "It is a recommendation within Apache not to use @author tags or other means to identify source code with individual developers.  The @author tags in jackrabbit-jcr-rmi should therefore be removed.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-746",
        "summary": "TCK: check for wrong repository descriptor. should be versioning instead of locking",
        "description": "... at least according to the comment.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-171",
        "summary": "QueryManager.createQuery() exception handling",
        "description": "Query q = this.superuser.getWorkspace().getQueryManager()\n                .createQuery(\"SELECT * FROM nt:base\", Query.XPATH);\n\nproduces:\norg.apache.jackrabbit.core.query.xpath.TokenMgrError: Lexical error at line 1, column 28.  Encountered: \"b\" (98), after : \":\"\n\tat org.apache.jackrabbit.core.query.xpath.XPathTokenManager.getNextToken(XPathTokenManager.java:14546)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.jj_ntk(XPath.java:9187)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.PredicateList(XPath.java:5195)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.AxisStep(XPath.java:4707)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.StepExpr(XPath.java:4597)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.RelativePathExpr(XPath.java:4511)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.PathExpr(XPath.java:4482)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.ValueExpr(XPath.java:4125)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.UnaryExpr(XPath.java:4032)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.CastExpr(XPath.java:3935)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.CastableExpr(XPath.java:3898)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.TreatExpr(XPath.java:3861)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.InstanceofExpr(XPath.java:3824)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.IntersectExceptExpr(XPath.java:3748)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.UnionExpr(XPath.java:3672)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.MultiplicativeExpr(XPath.java:3622)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.AdditiveExpr(XPath.java:3510)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.RangeExpr(XPath.java:3451)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.ComparisonExpr(XPath.java:3353)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.AndExpr(XPath.java:3290)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.OrExpr(XPath.java:3227)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.ExprSingle(XPath.java:2214)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.ForClause(XPath.java:2337)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.FLWORExpr(XPath.java:2233)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.ExprSingle(XPath.java:2133)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.Expr(XPath.java:2094)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.QueryBody(XPath.java:2066)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.MainModule(XPath.java:512)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.Module(XPath.java:387)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.QueryList(XPath.java:151)\n\tat org.apache.jackrabbit.core.query.xpath.XPath.XPath2(XPath.java:118)\n\tat org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder.<init>(XPathQueryBuilder.java:224)\n\tat org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder.createQuery(XPathQueryBuilder.java:255)\n\tat org.apache.jackrabbit.core.query.QueryParser.parse(QueryParser.java:57)\n\tat org.apache.jackrabbit.core.query.lucene.QueryImpl.<init>(QueryImpl.java:119)\n\tat org.apache.jackrabbit.core.query.lucene.SearchIndex.createExecutableQuery(SearchIndex.java:158)\n\tat org.apache.jackrabbit.core.query.QueryImpl.<init>(QueryImpl.java:90)\n\tat org.apache.jackrabbit.core.SearchManager.createQuery(SearchManager.java:192)\n\tat org.apache.jackrabbit.core.query.QueryManagerImpl.createQuery(QueryManagerImpl.java:87)\n\tat org.apache.jackrabbit.test.api.query.IllegalXPathTest.testIllegalStatement(IllegalXPathTest.java:45)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat org.apache.jackrabbit.test.AbstractJCRTest.run(AbstractJCRTest.java:401)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:474)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:342)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:194)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2227",
        "summary": "NodeTypeDefinitionFactory does not set PropertyDefinition#isQueryOrderable",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1350",
        "summary": "Add a serializing content handler",
        "description": "Both JCR-1310 and JCR-1343 need XML serialization functionality and we've also previously (JCR-367, JCR-1086) implemented something similar.\n\nIt would be good to centralize such code, and so I'd like to use the already referenced code from Cocoon [1] as the basis for a SerializingContentHandler class in jackrabbit-jcr-commons.\n\n[1] https://svn.apache.org/repos/asf/cocoon/trunk/core/cocoon-pipeline/cocoon-pipeline-impl/src/main/java/org/apache/cocoon/serialization/AbstractTextSerializer.java",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-13",
        "summary": "Disable SearchManager",
        "description": "In previous versions (e.g. SVN tag 0.1-spec0.14) it was possible to disable the SearchManagers by not configuring a search index path. In the current revision, a NullPointerException is thrown, if the search index configuration is missing, tough the rest of the system would support missing search index configuration as before.\n\nI suggest to extend search index configuration interpretation in WorkspaceCfg.init as follows:\n\n        Element srchConfig = wspElem.getChild(SEARCH_INDEX_ELEMENT);\n        if (srchConfig != null) {\n            String pathAttr = srchConfig.getAttributeValue(PATH_ATTRIB);\n            if (pathAttr != null && pathAttr.length() > 0) {\n                searchIndexDir = replaceVars(pathAttr, vars);\n            }\n        }\n\nThis only reads search index configuration if available.\n\nThe reason to switch of the SearchManager is, that in my use case enabling the SearchManager yields a performance degradation of a factor of 10 ! Instead of taking around 500ms (which is still too long :-) to save 3 nodes and 15 properties, it would take around 5 seconds to save the same amount of data. And I do not need the SearchManager in my use case.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1220",
        "summary": "WebApp: Ease first access for new users looking for a WebDAV server",
        "description": "suggestion posted by mike oliver in the user list:\n\n> I know that JackRabbit isn't the same as Jakarta Slide and not expecting it to be, but one thing we did right on \n> that project was create a runnable war file that doesn't require any learning curve to get started.  Install the war file, \n> create the network place and login as the root:root user and start creating content folders and documents. \n> If JackRabbit did that, then I think more people would try it and use it and then spend the time to learn how to make \n> it all it can be.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3170",
        "summary": "Precompile JavaCC parsers in jackrabbit-spi-commons",
        "description": "The JavaCC-generated Java source files in jackrabbit-spi-commons require special configuration when importing Jackrabbit sources to an IDE like Eclipse. To make IDE integration smoother it would be nice if precompiled copies of the Java files existed the src/main/java folder.\n\nPrecompiling the sources would also allow us to avoid the JavaCC processing step during each Jackrabbit build. Instead we could have a separate profile for explicitly recompiling the JavaCC sources when they have been modified. In the past three years that has happened only once (JCR-952), so I think a bit of extra complexity there is justified by the simplification we can achieve in normal builds and IDE integration.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3282",
        "summary": "Optimize usage of norms",
        "description": "There is a very significant potential for optimizing the size of the search index.\n\nWe have seen a case where there were multiple segments with about the same number of nodes (roughly 10 million), but the size on disk was very different.\nOne segment was 19 GB while all others where around 3 GB. The major difference was the number of fields indexed. The large segment had significantly more fields, which resulted in a large norms file.\n\nWe should go through our implementation and see where norms are really necessary and disable tracking of norms wherever possible.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1491",
        "summary": "UUID check in BundleFsPersistenceManager.getListRecursive() leads to endless loop",
        "description": "The UUID comparison in getListRecursive() is wrong and leads to an endless loop when the test PersistenceManagerIteratorTest.getAllNodeIds() is run on a workspace using BundleFsPersistenceManager.\n\nI'm not sure this always happens, but for sure in a workspace with no content (just root and jcr:system nodes).\n\nThere's also an problem with the test case. In batch mode the after NodeId is set to the last id returned by the previous get all nodes fetch. This means batch retrieval is never actually tested, because there is no NodeId after the last one.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2743",
        "summary": "ClassCastException in GroupImpl.isCyclicMembership",
        "description": "Given three groups and one user with the following membership relation\n\ngroup1 > group2 > group3\ngroup2 > user\n\nwhere x > y means x contains y.\n\ngroup3.addMember(group1) throws a ClassCastException.\n\nThe reason is that the search type (i.e. UserManager.SEARCH_TYPE_GROUP) is not honored correctly when constructing the transitive membership relation. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1820",
        "summary": "Ensure queries are not blocked during large updates",
        "description": "The index currently guarantees that long running queries do not block updates. In addition a query *may* run during an update, but there is not guarantee because it depends on the availability of an index reader being available when the update starts. The index reader is invalidated at the end of the update, which will force the creation of a new index reader when the next query is executed.\n\nConsider the following scenario:\n\n1) update index -> transaction id T1\n2) potential index reader is invalidated\n3) execute query -> creates index reader R1, which includes changes up to T1\n4) update index -> transaction id T2\n5) index reader R1 is invalidated\n6) update index (large transaction) -> transaction id T3\n7) while previous update is running execute query -> thread is blocked because no reader is available\n\n\nThe improvement should detect the large transaction and prepare an index reader for potential queries during the update. That is, 6) should be split into:\n\n6a) detect large transaction and prepare index reader R2, which includes changes up to T2\n6b) update index -> transaction id T3\n\nWhile the update is running a query will use index reader R2.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3159",
        "summary": "LOWER operand with nested LOCALNAME operand not work with SQL2",
        "description": "Below query was running successful using Query.SQL languange:\nSELECT * FROM nt:file WHERE (CONTAINS(*, 'Jon') OR  LOWER(fn:name()) LIKE '%jon%') AND jcr:path LIKE '/Resources/%' ORDER BY jcr:score()\n\nBut equivalent next query in Query.JCR_SQL2 will fail with exception UnsupportedRepositoryOperationException():\nSELECT * FROM [nt:file] WHERE (CONTAINS([nt:file].*, 'Jon') OR  LOWER(LOCALNAME()) LIKE '%jon%') AND ISDESCENDANTNODE('/Resources') ORDER BY SCORE()\n\nFrom my investigation seems LOWER function will not work with nested function LOCALNAME. According to section \"6.7.32 LowerCase\" JCR 2.0 Specs, LOWER operand able to work on DynamicOperand argument.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3209",
        "summary": "lock token validity",
        "description": "There are several minor issues in the mapping between JCR lock tokens and WebDAV lock tokens:\n\n1) WebDAV lock tokens are supposed to use URI syntax (such as opaquelocktoken: or urn:uuid:)\n\n2) The server currently computes lock tokens for session-scoped locks based on the node id; these are not valid JCR lock tokens though and cause exceptions when they are re-added when they appear in a Lock-Token header or an If header. This will likely cause requests to fail that use both types of locks (yes, maybe academic but should be fixed anyway)\n\nProposal:\n\na) Map lock tokens to oqaquelocktoken URIs, using a constant UUID plus a postfix encoding the original lock token\nb) Use a syntax that allows to distinguish between tokens for open-scoped locks or session-scoped locks, so that we do not try to add the latter type to the Session (alternatively, handle exceptions doing so gracefully)",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-335",
        "summary": "Deadlock caused by versioning operations within transaction",
        "description": "Deadlock occurs, while running a very simple test, which is just trying\nto checkout/checkin node within transaction concurrently from 2 threads.\n\nFind enclosed thread dump, log and simple Java program.\nI'm using UserTransaction implementation from jackrabbit test suite.\n\nRegards\nPrzemo Pakulski\nwww.cognifide.com\n\n\nFull thread dump Java HotSpot(TM) Client VM (1.4.2_08-b03 mixed mode):\n\n\"Thread-5\" prio=5 tid=0x03054c48 nid=0x180c in Object.wait() [355f000..355fd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x1148ef20> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)\n       at java.lang.Object.wait(Object.java:429)\n       at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source)\n       - locked <0x1148ef20> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireWriteLock(SharedItemStateManager.java:1137)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.access$200(SharedItemStateManager.java:110)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:456)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:651)\n       at org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:150)\n       at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:128)\n       - locked <0x11565ac8> (a org.apache.jackrabbit.core.TransactionContext)\n       at org.apache.jackrabbit.core.XASessionImpl.prepare(XASessionImpl.java:300)\n       at com.oyster.mom.contentserver.jcr.transaction.JackrabbitUserTransaction.commit(JackrabbitUserTransaction.java:102)\n       at com.oyster.mom.contentserver.jcr.transaction.JrTestDeadlock.run(JrTestDeadlock.java:97)\n\n\"Thread-4\" prio=5 tid=0x0303b348 nid=0x9d0 in Object.wait() [351f000..351fd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x1148ef20> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)\n       at java.lang.Object.wait(Object.java:429)\n       at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source)\n       - locked <0x1148ef20> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireWriteLock(SharedItemStateManager.java:1137)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.access$200(SharedItemStateManager.java:110)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:456)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:651)\n       at org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:150)\n       at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:128)\n       - locked <0x1156f558> (a org.apache.jackrabbit.core.TransactionContext)\n       at org.apache.jackrabbit.core.XASessionImpl.prepare(XASessionImpl.java:300)\n       at com.oyster.mom.contentserver.jcr.transaction.JackrabbitUserTransaction.commit(JackrabbitUserTransaction.java:102)\n       at com.oyster.mom.contentserver.jcr.transaction.JrTestDeadlock.run(JrTestDeadlock.java:97)\n\n\"IndexMerger\" daemon prio=5 tid=0x030388b8 nid=0x1858 in Object.wait() [34df000..34dfd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x114fd280> (a org.apache.commons.collections.buffer.BlockingBuffer)\n       at java.lang.Object.wait(Object.java:429)\n       at org.apache.commons.collections.buffer.BlockingBuffer.remove(BlockingBuffer.java:107)\n       - locked <0x114fd280> (a org.apache.commons.collections.buffer.BlockingBuffer)\n       at org.apache.jackrabbit.core.query.lucene.IndexMerger.run(IndexMerger.java:235)\n\n\"Thread-2\" daemon prio=5 tid=0x0303a230 nid=0xe4c in Object.wait() [349f000..349fd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x114fd2e0> (a java.util.TaskQueue)\n       at java.util.TimerThread.mainLoop(Timer.java:429)\n       - locked <0x114fd2e0> (a java.util.TaskQueue)\n       at java.util.TimerThread.run(Timer.java:382)\n\n\"Thread-1\" daemon prio=5 tid=0x0301b7a0 nid=0x1a00 in Object.wait() [345f000..345fd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x114f9058> (a java.util.TaskQueue)\n       at java.lang.Object.wait(Object.java:429)\n       at java.util.TimerThread.mainLoop(Timer.java:403)\n       - locked <0x114f9058> (a java.util.TaskQueue)\n       at java.util.TimerThread.run(Timer.java:382)\n\n\"ObservationManager\" daemon prio=5 tid=0x02ef6c50 nid=0x10d8 in Object.wait() [341f000..341fd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x114f38e0> (a org.apache.commons.collections.buffer.BlockingBuffer)\n       at java.lang.Object.wait(Object.java:429)\n       at org.apache.commons.collections.buffer.BlockingBuffer.remove(BlockingBuffer.java:107)\n       - locked <0x114f38e0> (a org.apache.commons.collections.buffer.BlockingBuffer)\n       at org.apache.jackrabbit.core.observation.ObservationManagerFactory.run(ObservationManagerFactory.java:155)\n       at java.lang.Thread.run(Thread.java:534)\n\n\"Signal Dispatcher\" daemon prio=10 tid=0x00a05590 nid=0x1914 waiting on condition [0..0]\n\n\"Finalizer\" daemon prio=9 tid=0x00a027f8 nid=0x17a4 in Object.wait() [2c9f000..2c9fd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x113db118> (a java.lang.ref.ReferenceQueue$Lock)\n       at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:111)\n       - locked <0x113db118> (a java.lang.ref.ReferenceQueue$Lock)\n       at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:127)\n       at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)\n\n\"Reference Handler\" daemon prio=10 tid=0x00a01478 nid=0x16d4 in Object.wait() [2c5f000..2c5fd8c]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x113db180> (a java.lang.ref.Reference$Lock)\n       at java.lang.Object.wait(Object.java:429)\n       at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:115)\n       - locked <0x113db180> (a java.lang.ref.Reference$Lock)\n\n\"main\" prio=5 tid=0x0003e6f0 nid=0x1470 in Object.wait() [7f000..7fc38]\n       at java.lang.Object.wait(Native Method)\n       - waiting on <0x11524f10> (a com.oyster.mom.contentserver.jcr.transaction.JrTestDeadlock)\n       at java.lang.Thread.join(Thread.java:1001)\n       - locked <0x11524f10> (a com.oyster.mom.contentserver.jcr.transaction.JrTestDeadlock)\n       at java.lang.Thread.join(Thread.java:1054)\n       at com.oyster.mom.contentserver.jcr.transaction.JrTestDeadlock.main(JrTestDeadlock.java:33)\n\n\"VM Thread\" prio=5 tid=0x00a42730 nid=0x17d0 runnable\n\n\"VM Periodic Task Thread\" prio=10 tid=0x00a45540 nid=0x1928 waiting on condition\n\"Suspend Checker Thread\" prio=10 tid=0x00a04af8 nid=0x17ac runnable\n\nimport javax.jcr.Node;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.SimpleCredentials;\n\nimport org.apache.jackrabbit.core.RepositoryImpl;\nimport org.apache.jackrabbit.core.config.RepositoryConfig;\n\npublic class JrTestDeadlock extends Thread {\n\n   private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(JrTestDeadlock.class);\n\n   public static String REPOSITORY_HOME = \"d:/repo/jackrabbit/\";\n\n   public static String REPOSITORY_CONFIG = REPOSITORY_HOME + \"repository.xml\";\n\n   public static void main(String[] args) throws Exception {\n\n       JrTestDeadlock test = new JrTestDeadlock(-1);\n       test.startup();\n\n       JrTestDeadlock tests[] = new JrTestDeadlock[2];\n\n       for (int i = 0; i < tests.length; i++) {\n           JrTestDeadlock x = new JrTestDeadlock(i);\n           x.start();\n           tests[i] = x;\n       }\n\n       for (int i = 0; i < tests.length; i++) {\n           tests[i].join();\n       }\n\n       test.shutdown();\n   }\n\n   private static RepositoryImpl repository;\n\n   private int id;\n\n   public JrTestDeadlock(int i) {\n       this.id = i;\n   }\n\n   public void startup() throws Exception {\n       System.setProperty(\"java.security.auth.login.config\", \"c:/jaas.config\");\n\n       RepositoryConfig config = RepositoryConfig.create(REPOSITORY_CONFIG, REPOSITORY_HOME);\n       repository = RepositoryImpl.create(config);\n\n       Session session = repository.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray()));\n       Node rootNode = session.getRootNode();\n       if (!rootNode.hasNode(\"folder\")) {\n           Node folder = rootNode.addNode(\"folder\");\n           folder.addMixin(\"mix:versionable\");\n           folder.addMixin(\"mix:lockable\");\n           rootNode.save();\n       }\n       session.logout();\n   }\n\n   public void shutdown() throws RepositoryException {\n       repository.shutdown();\n   }\n\n   public Node getFolder(Session session) throws RepositoryException {\n       return session.getRootNode().getNode(\"folder\");\n   }\n\n   public void run() {\n       try {\n           Session session = repository.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray()));\n           for (int i = 0; i < 100; i++) {\n               log.error(\"START id:\" + id + \", i=\" + i);\n\n               boolean success = false;\n\n               JackrabbitUserTransaction ut = new JackrabbitUserTransaction(session);\n               try {\n                   ut.begin();\n\n                   Node folder = getFolder(session);\n                   folder.checkout();\n                   folder.checkin();\n\n                   success = true;\n                   log.info(\"SUCCESS id:\" + id + \", i=\" + i);\n               }\n               catch (Exception e) {\n                   log.warn(\"FAIL:\" + id + \", i=\" + i, e);\n               }\n               finally {\n                   try {\n                       if (success) {\n                           ut.commit();\n                       }\n                       else {\n                           ut.rollback();\n                       }\n                   }\n                   catch (Exception e) {\n                       log.fatal(e);\n                   }\n               }\n           }\n           session.logout();\n       }\n       catch (RepositoryException e) {\n           e.printStackTrace();\n       }\n   }\n}\n\n\n13:46 ERROR JrTestDeadlock.run(JrTestDeadlock.java:76) - START id:0, i=0\n13:46 ERROR JrTestDeadlock.run(JrTestDeadlock.java:76) - START id:1, i=0\n13:46 INFO  JrTestDeadlock.run(JrTestDeadlock.java:89) - SUCCESS id:0, i=0\n13:46 INFO  JrTestDeadlock.run(JrTestDeadlock.java:89) - SUCCESS id:1, i=0\n13:46 ERROR org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:156) - org.apache.jackrabbit.core.state.StaleItemStateException: 233e656f-79f8-414d-9e37-3fce865b492d/{http://www.jcp.org/jcr/1.0}isCheckedOut has been modified externally\n13:46 FATAL JrTestDeadlock.run(JrTestDeadlock.java:104) - javax.transaction.RollbackException: Transaction rolled back: XA_ERR=104\n13:46 ERROR JrTestDeadlock.run(JrTestDeadlock.java:76) - START id:1, i=1\n13:46 WARN  JrTestDeadlock.run(JrTestDeadlock.java:92) - FAIL:1, i=1\nax.jcr.InvalidItemStateException: f83a830b-abbf-4ab2-8625-b9e2c4802316: the item does not exist anymore\n    at org.apache.jackrabbit.core.version.XAVersion.sanityCheck(XAVersion.java:81)\n    at org.apache.jackrabbit.core.version.XAVersion.getInternalVersion(XAVersion.java:70)\n    at org.apache.jackrabbit.core.version.AbstractVersion.getUUID(AbstractVersion.java:107)\n    at org.apache.jackrabbit.core.NodeImpl.checkout(NodeImpl.java:2759)\n    at JrTestDeadlock.run(JrTestDeadlock.java:85)\n13:46 ERROR JrTestDeadlock.run(JrTestDeadlock.java:76) - START id:1, i=2\n13:46 INFO  JrTestDeadlock.run(JrTestDeadlock.java:89) - SUCCESS id:1, i=2\n13:51 WARN  org.apache.jackrabbit.core.TransactionContext.run(TransactionContext.java:239) - Transaction rolled back because timeout expired.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-649",
        "summary": "Like expression does not match line terminator in String",
        "description": "If a string property contains a line terminator a like pattern with a % or _ does not match the line terminator. This is because the implementation uses the java.util.regexp.Pattern class without the DOTALL option.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-173",
        "summary": "jUnit test-cases: success of some DocumentViewImportTest tests depends on Xerxes version being used",
        "description": "if e.g. xerxes v. 2.4.0 is used instead of v. 2.6.2 as specified in project.xml certain tests in DocumentViewImportTest fail.\n\ne.g. \n\nTestcase: testWorkspaceImportXml(org.apache.jackrabbit.test.api.DocumentViewImportTest):\tFAILED\nXml text is not correctly stored. expected:<......> but was:<...\n       ...>\njunit.framework.ComparisonFailure: Xml text is not correctly stored. expected:<......> but was:<...\n       ...>\n\tat org.apache.jackrabbit.test.api.DocumentViewImportTest.checkXmlTextNode(DocumentViewImportTest.java:240)\n\tat org.apache.jackrabbit.test.api.DocumentViewImportTest.checkImportSimpleXMLTree(DocumentViewImportTest.java:174)\n\tat org.apache.jackrabbit.test.api.DocumentViewImportTest.performTests(DocumentViewImportTest.java:143)\n\tat org.apache.jackrabbit.test.api.DocumentViewImportTest.doTestImportXML(DocumentViewImportTest.java:115)\n\tat org.apache.jackrabbit.test.api.DocumentViewImportTest.testWorkspaceImportXml(DocumentViewImportTest.java:73)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat org.apache.jackrabbit.test.AbstractJCRTest.run(AbstractJCRTest.java:401)\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-37",
        "summary": "select query fails on 'like xxx322' statement",
        "description": "In class org.apache.jackrabbit.core.search.lucene.WildcardTermEnum, there's a condition around line 77 like\n\n...\nif (Character.isLetter(likePattern.charAt(i))) {\n...\n\nwhich fails on query like\nSELECT * FROM my:type LOCATION /news// WHERE my:text LIKE \"asd2\"\n\nit should be changed to \n\nif (Character.isLetter(likePattern.charAt(i)) || Character.isDigit(likePattern.charAt(i))) {\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-518",
        "summary": "TCK: XPath order by test uses non-standard column specifier mechanism",
        "description": "org.apache.jackrabbit.test.api.QueryXPathOrderByTest generates a queries of the following form: /jcr:root/*[@proname]/@propname order by @propname\n\nThis syntax for column specifiers is not mandated by the JCR specification and will fail on any implementation that does not support it.\n\nInstead the tests should use the following query: /jcr:root/*[@proname] order by @propname and then read the results using QueryResults.getNodes and not QueryResults.getRows.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1812",
        "summary": "WorkspaceUpdateChannel.updateCommitted logs too much",
        "description": "On each cluster record update, an info message is logged.\n\nI think this is too much and logging should be reduced to the DEBUG level.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2813",
        "summary": "\"overwriting cached entry\" warnings",
        "description": "when using multiple concurrent sessions you'll find *lots* of log entries like:\n\n    03.11.2010 21:17:03 *WARN * ItemStateReferenceCache: overwriting cached entry ad79ca57-5eb1-4b7d-a439-a9fd73cc8c5a (ItemStateReferenceCache.java, line 176)\n\nthose are actually legitimate warnings since there's a siginificant risk of data loss/inconsistency involved.\n\nthis is apparently a regression of changes introduced by JCR-2699, specifically svn r1004223",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2375",
        "summary": "Create ScoreNode on demand in SortedLuceneQueryHits",
        "description": "ScoreNodes are current created for the full result fetch. Instead, the ScoreNodes should be created on demand when requested in nextScoreNode().",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2386",
        "summary": "wrong eval order of access control entries within a single node (node-based ac)",
        "description": "it seems to me that with the node-based access control the ac entries within a given node are currently collected in the wrong order.\nif i remember correctly this worked before and i removed at some point (for reasons i don't recall exactly but have the vague idea that it\nwas related to the allow-only for groups).\n\nanyway:\nwhile playing around with the permission in our CRX recently i found, that the evaluation of the following setup didn't work as I would\nhave expected:\n\n- user A is member of group B and C\n- for both groups an ACE exists on a given node /a/b/c\n- the acl looks like  { deny for B, allow for C }\n\nI would have expected that the allow for C would have reverted the previous deny for B since - in the GUI - I read the ace eval order from first entry to last entry... in the order I added them.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-226",
        "summary": "Lock.refresh(): throws if lock is alive",
        "description": "The spec says:\n\nLock.refresh():\nIf this lock's time-to-live is governed by a timer, this method resets that timer so that the lock does not timeout and expire. If this lock's time-to-live is not governed by a timer, then this method has no effect.A LockException is thrown if this Session does not hold the correct lock token for this lock.A RepositoryException is thrown if another error occurs.\n\n\nThe jackrabbit impl does:\n\n/**\n     * {@inheritDoc}\n     */\n    public void refresh() throws LockException, RepositoryException {\n        if (isLive()) {\n            throw new LockException(\"Lock still alive.\");\n        }\n        [...]\n    }\n\n\nIsn't this a leftover from a very old version of the spec?\nThere was ones a misunderstanding about the refresh (bringing locks back to live) that has been discussed (mail by david to g. clemm, tobi, peeter and myself, 25.4.2005). as far is i know everybody agreed that this does not make sense and the spec has been adjusted accordingly.\n\nThe usage of the refresh is to prevent the lock from being timeouted. That was the original meaning of the refresh, when i suggested it for the JCR locking. If the lock is still alive and there is no timeout to reset, then the method should simply not do anything.\n\nam i missing something? \n\nregards\nangela\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1462",
        "summary": "repository.xml: throw an exception on error",
        "description": "Currently, unsupported parameters in repository.xml and workspace.xml are ignored.\nTo find problems earlier, such problems should result in an exception,\nand starting such a repository should not be possible.\nThe same should happen for unsupported values.\n\nFor currently unavailable options\n(such as text extraction filter classes if the class is not in the classpath),\nat least a warning should be written to the error log, or an error should be thrown.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3040",
        "summary": "JMX Stats for the Session",
        "description": "I've named them Core stats. This will include:\n - number of sessions currently opened\n - session read / write operations per second\n\nThe stats refresh once a minute.\nThis is disabled by default, so it will not affect performance.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-3107",
        "summary": "Speed up hierarchy cache initialization",
        "description": "Initializing a workspace can take quite a long time if there is a big number of nodes and some search indexes involved. The reason is that the setup of the CachingIndexReader is processed using chunks of a certain size (actually 400K) in order to reduce the memory footprint. As soon as the number of documents exceeds this limit some operations (actually traversing complete indexes) are performed again and again.\n\nIt seems that the current algorithm \"initializeParents\" in the CachingIndexReader class can't be optimized without increasing the memory consumption. Therefore it should be a promising approach to persist the \"state\" of this class (actually it's main member array and map) and reload it on startup.\n\nThe \"load\" of the state can be done implicitly in the initializing phase of the cache. This is obvious. The correct point of time to call the \"save\" operation isn't obvious at all. I tried the \"doClose\" method of the class and it seems sufficient.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2325",
        "summary": "rep:similar in xpath does not work",
        "description": "This query //*[rep:similar(., '/content/en')] produces an exception:\n\n24.09.2009 16:56:48.156 *ERROR* [0:0:0:0:0:0:0:1%0 [1253804208093] GET /libs/cq/search/content/querydebug.html HTTP/1.1] org.apache.sling.engine.impl.SlingMainServlet service: Uncaught SlingException java.lang.ArrayIndexOutOfBoundsException: -1\n\tat org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder.visit(LuceneQueryBuilder.java:612)\n\tat org.apache.jackrabbit.spi.commons.query.RelationQueryNode.accept(RelationQueryNode.java:115)\n\tat org.apache.jackrabbit.spi.commons.query.NAryQueryNode.acceptOperands(NAryQueryNode.java:143)\n\tat org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder.visit(LuceneQueryBuilder.java:489)\n\tat org.apache.jackrabbit.spi.commons.query.LocationStepQueryNode.accept(LocationStepQueryNode.java:166)\n\tat org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder.visit(LuceneQueryBuilder.java:468)\n\tat org.apache.jackrabbit.spi.commons.query.PathQueryNode.accept(PathQueryNode.java:74)\n\tat org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder.visit(LuceneQueryBuilder.java:257)\n\tat org.apache.jackrabbit.spi.commons.query.QueryRootNode.accept(QueryRootNode.java:115)\n\tat org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder.createLuceneQuery(LuceneQueryBuilder.java:247)\n\tat org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder.createQuery(LuceneQueryBuilder.java:227)\n\tat org.apache.jackrabbit.core.query.lucene.QueryImpl.execute(QueryImpl.java:111)\n\tat org.apache.jackrabbit.core.query.QueryImpl.execute(QueryImpl.java:127)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2531",
        "summary": "JCR-RMI problem with large binary values",
        "description": "As reported on the mailing list, a JCR-RMI connection will hang when given a binary value that's larger than the default 64kB buffer size.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3268",
        "summary": "Re-index fails on corrupt bundle",
        "description": "The re-indexing process should be more resilient, log an error and simply continue with the next node. It doesn't seem useful to refuse repository startup in this case.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2956",
        "summary": "SQL2: Implement LIKE support for node names",
        "description": "Doing a LIKE constraint on the local name of a node that throws javax.jcr.UnsupportedRepositoryOperationException.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-110",
        "summary": "Rename package core.search to core.query",
        "description": "The package org.apache.jackrabbit.core.search should be renamed to org.apache.jackrabbit.core.query for consistency with the JCR api. All other packages in Jackrabbit already use the package names as suggested by the JCR api (javax.jcr.<subpackage>).\n\nIf there are other implementations than the Jackrabbit one of the org.apache.jackrabbit.core.search.QueryHandler interface they need to be adapted to use the new package name!",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "TASK"
    },
    {
        "key": "JCR-2883",
        "summary": "Node.orderBefore and JackrabbitNode.rename should check for ability to modify children-collection on parent node",
        "description": "currently the implementation of Node.orderBefore and JackrabbitNode.rename perform the same validation that is executed\nfor a move operation which includes removal of the original node. however, the methods mentioned above only include\na manipulation on the child-node-collection of the parent (subset of the current check). therefore the permission check should be \nadjusted accordingly.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-692",
        "summary": "XMLPersistenceManager fails after creating too many directories on linux",
        "description": "When using the  XMLPersistenceManager it creates a bunch of directories in jackrabbit/home/version/data. Eventually I reach 32000 directories in the data directory and subsequent writes fail.\n\nI believe this is caused by XMLPersistenceManager.buildNodeFolderPath() method where it does \n   if (cnt == 4 || cnt == 8) {\n      sb.append('/');\n   }\n\nThis causes the subdirectories to be 4 characters, 0-f i.e. 16^4 which is 65536, if what I'm seeing is correct, on linux ext3, it's limited to 32000 entries. If the XMLPersistence manager used 2 or 3 characters this should fix the problem, or if it were configurable it would also solve this (I think).\n\nan \n   ls jackrabbit/home/version/data | wc -l\nreturns \n   32001\n\nA stack trace for when this happens is as follows :\nCaused by: javax.jcr.RepositoryException: failed to write node state: da2cd5d1-9776-4dbe-a42b-842b0134dbfb: failed to write node state: da2cd5d1-9776-4dbe-a42b-842b0134dbfb\n        at org.apache.jackrabbit.core.version.AbstractVersionManager.createVersionHistory(AbstractVersionManager.java:181)\n        at org.apache.jackrabbit.core.version.VersionManagerImpl$1.run(VersionManagerImpl.java:194)\n        at org.apache.jackrabbit.core.version.VersionManagerImpl$DynamicESCFactory.doSourced(VersionManagerImpl.java:526)\n        at org.apache.jackrabbit.core.version.VersionManagerImpl.createVersionHistory(VersionManagerImpl.java:191)\n        at org.apache.jackrabbit.core.version.XAVersionManager.createVersionHistory(XAVersionManager.java:140)\n        at org.apache.jackrabbit.core.ItemImpl.initVersionHistories(ItemImpl.java:754)\n        at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1166)\n        at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:805)\n        ... 166 more\nCaused by: org.apache.jackrabbit.core.state.ItemStateException: failed to write node state: da2cd5d1-9776-4dbe-a42b-842b0134dbfb\n        at org.apache.jackrabbit.core.state.xml.XMLPersistenceManager.store(XMLPersistenceManager.java:579)\n        at org.apache.jackrabbit.core.state.AbstractPersistenceManager.store(AbstractPersistenceManager.java:66)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:574)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:697)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:315)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:291)\n        at org.apache.jackrabbit.core.version.AbstractVersionManager.createVersionHistory(AbstractVersionManager.java:174)\n        ... 173 more\nCaused by: org.apache.jackrabbit.core.fs.FileSystemException: failed to create folder /home/cms/pepsiaccess/jackrabbit/home/version/data/da2c/d5d1/97764dbea42b842b0134dbfb\n        at org.apache.jackrabbit.core.fs.local.LocalFileSystem.createFolder(LocalFileSystem.java:208)\n        at org.apache.jackrabbit.core.fs.BasedFileSystem.createFolder(BasedFileSystem.java:99)\n        at org.apache.jackrabbit.core.fs.FileSystemResource.makeParentDirs(FileSystemResource.java:100)\n        at org.apache.jackrabbit.core.state.xml.XMLPersistenceManager.store(XMLPersistenceManager.java:517)\n        ... 179 more",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2415",
        "summary": "Update Lucene to 3.0",
        "description": "Lucene 3.0 was released on 2009/11/25. They migrated to Java 1.5 as Jackrabbit is doing with 2.0. Also they added some new optimizations. It would be nice if Jackrabbit could switch to the new lucene version too.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-477",
        "summary": "Deployment of webdav servlet on Jboss problem - logging",
        "description": "Tested two different installs of JBoss to verify problem is not related to a specific version. There is a problem with the jackrabbit-server.war when deploying on jboss.  Here are the details during deployment:\n\n=======================\n13:20:48,654 INFO  [TomcatDeployer] deploy, ctxPath=/jackrabbit-server, warUrl=.../deploy/jackrabbit-server.war/\n13:20:48,857 INFO  [STDOUT] log4j:ERROR A \"org.jboss.logging.util.OnlyOnceErrorHandler\" object is not assignable to a \"o rg.apache.log4j.spi.ErrorHandler\" variable.\n13:20:48,857 INFO  [STDOUT] log4j:ERROR The class \"org.apache.log4j.spi.ErrorHandler\" was loaded by\n13:20:48,857 INFO  [STDOUT] log4j:ERROR [WebappClassLoader\n  delegate: false\n  repositories:\n    /WEB-INF/classes/\n----------> Parent Classloader:\njava.net.FactoryURLClassLoader@19d277e\n] whereas object of type\n13:20:48,857 INFO  [STDOUT] log4j:ERROR \"org.jboss.logging.util.OnlyOnceErrorHandler\" was loaded by [org.jboss.system.se rver.NoAnnotationURLClassLoader@ab95e6].\n13:20:48,904 INFO  [STDOUT] log4j:ERROR Could not create an Appender. Reported error follows.\n13:20:48,904 INFO  [STDOUT] java.lang.ClassCastException: org.jboss.logging.appender.DailyRollingFileAppender\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.parseAppender(DOMConfigurator.java:165)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.findAppenderByName(DOMConfigurator.java:140)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.findAppenderByReference(DOMConfigurator.java:153\n)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.parseChildrenOfLoggerElement(DOMConfigurator.jav\na:415)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.parseRoot(DOMConfigurator.java:384)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.parse(DOMConfigurator.java:783)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.doConfigure(DOMConfigurator.java:666)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.doConfigure(DOMConfigurator.java:616)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.doConfigure(DOMConfigurator.java:602)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.helpers.OptionConverter.selectAndConfigure(OptionConverter.java:460)\n\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.LogManager.<clinit>(LogManager.java:113)\n13:20:48,904 INFO  [STDOUT]     at org.apache.log4j.xml.DOMConfigurator.configure(DOMConfigurator.java:543)\n13:20:48,904 INFO  [STDOUT]     at org.apache.jackrabbit.j2ee.LoggingServlet.configureXML(LoggingServlet.java:148)\n13:20:48,904 INFO  [STDOUT]     at org.apache.jackrabbit.j2ee.LoggingServlet.configure(LoggingServlet.java:115)\n13:20:48,904 INFO  [STDOUT]     at org.apache.jackrabbit.j2ee.LoggingServlet.init(LoggingServlet.java:86)\n======================\n \nUnlike most logging problems, this is having an impact during runtime - when trying to do DASL searches, will return a 500 error as the server was unable to log correctly.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-3109",
        "summary": "Move PersistenceManagerTest from o.a.j.core to o.a.j.core.persistence",
        "description": "The subject pretty much sums it up. The PMTest should be placed together with the other PM related tests in o.a.j.core.persistence.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2786",
        "summary": "Cluster sync not always done when calling session.refresh(..)",
        "description": "Session.refresh(..) is supposed to synchronize cluster changes, but this doesn't always happen, specially if the syncDelay is low. The reason is a wrong assumption in ClusterNode.sync: The code there to avoid duplicate sync calls doesn't always work as expected. The following algorithm is used:\n\n        int count = syncCount;\n        syncLock.acquire();\n        if (count == syncCount) {\n            journalSync();\n            syncCount++;\n        }\n        syncLock.release();\n\nThe problem is that the background thread might be at the line \"syncCount++\" when Session.refresh(..) is called, so that the main thread believes journalSync was already called and thus doesn't call it.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3044",
        "summary": "Remove ImportContextImpl#getDetector",
        "description": "the method ImportContextImpl#getDetector refers an interface method on ImportContext that does not exist.\naccording to jukka that is a leftover. since the method is not used at all i would therefore suggest to remove it altogether, remove the instance field and deprecate the constructor taking the detector param.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2456",
        "summary": "Repository is corrupt after concurrent changes with the same session",
        "description": "After concurrent write operations using the same session, the repository can get corrupt, meaning a ItemNotFoundException is thrown when trying to remove a node.\n\nConcurrent write operations are not supported, however I believe the persistent state of the repository should not be get corrupt.\n\nOne way to solve this problem is to synchronize on the session internally.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2825",
        "summary": "FALSE predicate always returns true",
        "description": "org.apache.jackrabbit.spi.commons.iterator.Predicates..FALSE always returns true instead of false.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1657",
        "summary": "Cluster revision entries should be retrieved in order",
        "description": "The selectRevisionStmtSQL (DatabaseJournal#buildSqlStatements) returns a result set which may not be ordered by REVISION_ID. This has the effect that cluster instances that want to synchronize to the latest revision do not update their local revision appropriately since they assume that the revision result set is ordered (see code in AbstractJournal#doSync). This might cause a lot of unnecessary CPU cycles on these machines with degraded performance as a result. Furthermore, it causes functional issues as well as events may be fired multiple times and in the wrong order.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1366",
        "summary": "DbDataStore: tablePrefix not accomodated during init test for existing DATASTORE table",
        "description": "we are providing a test db deployment with prepopulated data, including jackrabbit DataStore. I tried specifying the tablePrefix when creating the initial repository, and tables are created properly.\n\nHowever, when a clean installation is run with a fresh database that has an existing DataStore (stored at JACKRABBIT_DS_DATASTORE table), the startup fails, because during init, the meta data only checks for tables name matching the tableSQL property:\nResultSet rs = meta.getTables(null, null, tableSQL, null);\n\nbut the tableSQL property is never modified based on the tablePrefix property (other uses of tableSQL modify queries based on the prefix).\n\nI think the init method should modify the tested table name based on the tablePrefix.\n\nNote: I assume different JDBC drivers may handle this differently (we are using SQL Server 2007 and jTDS driver), since the DatabaseMetaData is API is unclear on the parameter to getTables being a \"tableNamePattern\" - should wildcards work? Or should a specific table be specified? \n\nMy DataStore config is below:\n\n    <DataStore class=\"org.apache.jackrabbit.core.data.db.DbDataStore\">\n      <param name=\"className\" value=\"org.apache.jackrabbit.core.data.db.DbDataStore\"/>\n      <param name=\"url\" value=\"jdbc:jtds:SQLServer://localhost:1433/nga_admin;prepareSQL=2;responseBuffering=adaptive\"/>\n      <param name=\"user\" value=\"sa\"/>\n      <param name=\"password\" value=\"\"/>\n      <param name=\"databaseType\" value=\"sqlserver\"/>\n      <param name=\"driver\" value=\"net.sourceforge.jtds.jdbc.Driver\"/>\n      <!-- a bug in jackrabbit makes tablePrefix not work -->\n      <param name=\"tablePrefix\" value=\"JACKRABBIT_DS_\">\n      <param name=\"minRecordLength\" value=\"1\"/>\n      <param name=\"maxConnections\" value=\"2\"/>\n      <param name=\"copyWhenReading\" value=\"true\"/>         \n    </DataStore>\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "RFE"
    },
    {
        "key": "JCR-89",
        "summary": "Calling PropertyDef.getDefaultValue() via RMI results in Exception",
        "description": "hi jukka\n\n30.03.2005 15:28:23 *MARK * servletengine: Servlet threw exception: \norg.apache.jackrabbit.rmi.client.RemoteRuntimeException: java.rmi.UnmarshalException: error unmarshalling return; nested exception is: \n\tjava.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: javax.jcr.BooleanValue\n\tat org.apache.jackrabbit.rmi.client.ClientPropertyDef.getDefaultValues(ClientPropertyDef.java:76)\n\n[...]\n\nregards\nangela",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2699",
        "summary": "Improve read/write concurrency",
        "description": "I'd like to set up a few performance tests to help identify our worst bottlenecks for various kinds of concurrent read-only and read-write access patterns.\n\nOnce identified, I'm hoping to fix at least some of those bottlenecks.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2670",
        "summary": "Optimize ReadOnlyIndexReader.read(int[] docs, int[] freqs)",
        "description": "This method is currently implemented trivially using next(), doc() and freq(). It should read in blocks and filter out deleted docs.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-187",
        "summary": "it is not possible to register an event listener which listens to mixin nodetypes",
        "description": "it would be a nice enhancement if one could as well define mixin nodetypes to be listened:\n...\nom.addEventListener(this,\n                        Event.PROPERTY_ADDED | Event.PROPERTY_CHANGED | Event.PROPERTY_REMOVED,\n                        \"/\",\n                        true,\n                        null,\n                        new String[]{\"mix:Custom\"},\n                        false);\n...",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1206",
        "summary": "UUID generation: SecureRandom should be used by default",
        "description": "Currently, the UUID generation used the regular java.util.Random implementation to generate random UUIDs. The seed value of Random is initialized using System.currentTimeMillis(); for Windows, the resolution is about 15 milliseconds. That means two computer that start creating UUIDs with Jackrabbit within the same 15 millisecond interval will generate the same UUIDs. In a clustered environment the nodes could be started automatically at the same time (for example after a backup).\n\nAlso, the Random class uses a 48-bit seed, which is much less than the number of random bits in UUID (122). This is not secure. See also:\n\nhttp://en.wikipedia.org/wiki/UUID\nRandom UUID probability of duplicates\n\"The probability [of duplicates] also depends on the quality of the random number generator. A cryptographically secure pseudorandom number generator must be used to generate the values, otherwise the probability of duplicates may be significantly higher.\"\n\nTherefore, I suggest to change VersionFourGenerator to use the SecureRandom implementation in by default.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1361",
        "summary": "Lock test assumes that changes in one session are immediately visible in different session",
        "description": "LockTest.testLogout() assumes that a change in one session (logging out, removing a session-scoped lock) is immediately visible in another session.\n\nProposal: insert a \n\n n1.getSession().refresh(true);\n\ncall before checking\n\n assertFalse(\"node must not be locked\", n1.isLocked());",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1157",
        "summary": "Expose namespace registry via workspace instead via session in spi2jcr",
        "description": "spi2jcr/SessionInfoImpl.getNamespaceResolver() returns the namespace registry through the current session of the wrapped repository. Since session scoped namespace remapping is not visible to the SPI I think the method should return the namespace registry through the current workspace. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2015",
        "summary": "CachingIndexReader: NullPointerException initializing parents cache",
        "description": "Using the jackrabbit-core-1.4.9 (after upgrading from jackrabbot-core-1.4.6), the following exception is logged. The code where the exception happens was introduced in JCR-1884 and is first included in the 1.4.9 core release.\n\n10.03.2009 18:56:25 *WARN * CachingIndexReader: Error initializing parents cache. (CachingIndexReader.java, line 310)\njava.lang.NullPointerException\n    at org.apache.jackrabbit.core.query.lucene.CachingIndexReader$CacheInitializer$2.collect(CachingIndexReader.java:362)\n    at org.apache.jackrabbit.core.query.lucene.CachingIndexReader$CacheInitializer.collectTermDocs(CachingIndexReader.java:426)\n    at org.apache.jackrabbit.core.query.lucene.CachingIndexReader$CacheInitializer.initializeParents(CachingIndexReader.java:356)\n    at org.apache.jackrabbit.core.query.lucene.CachingIndexReader$CacheInitializer.run(CachingIndexReader.java:306)\n    at org.apache.jackrabbit.core.query.lucene.CachingIndexReader.<init>(CachingIndexReader.java:109)\n    at org.apache.jackrabbit.core.query.lucene.AbstractIndex.getReadOnlyIndexReader(AbstractIndex.java:276)\n    at org.apache.jackrabbit.core.query.lucene.MultiIndex.getIndexReader(MultiIndex.java:731)\n    at org.apache.jackrabbit.core.query.lucene.MultiIndex.<init>(MultiIndex.java:303)\n    at org.apache.jackrabbit.core.query.lucene.SearchIndex.doInit(SearchIndex.java:454)\n    at com.day.crx.query.lucene.LuceneHandler.doInit(LuceneHandler.java:93)\n    at org.apache.jackrabbit.core.query.AbstractQueryHandler.init(AbstractQueryHandler.java:53)\n    at org.apache.jackrabbit.core.SearchManager.initializeQueryHandler(SearchManager.java:583)\n    at org.apache.jackrabbit.core.SearchManager.<init>(SearchManager.java:265)\n    at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getSearchManager(RepositoryImpl.java:1600)\n    at org.apache.jackrabbit.core.RepositoryImpl.initWorkspace(RepositoryImpl.java:606)\n    at org.apache.jackrabbit.core.RepositoryImpl.getWorkspaceInfo(RepositoryImpl.java:718)\n    at com.day.crx.core.CRXRepositoryImpl.login(CRXRepositoryImpl.java:964)\n    at org.apache.sling.jcr.base.internal.SessionPool.acquireSession(SessionPool.java:268)\n    at org.apache.sling.jcr.base.internal.SessionPoolManager.login(SessionPoolManager.java:99)\n    at org.apache.sling.jcr.base.AbstractSlingRepository.login(AbstractSlingRepository.java:240)\n    at org.apache.sling.jcr.base.AbstractSlingRepository.loginAdministrative(AbstractSlingRepository.java:206)\n    at org.apache.sling.jcr.base.AbstractSlingRepository.pingAndCheck(AbstractSlingRepository.java:506)\n    at org.apache.sling.jcr.base.AbstractSlingRepository.startRepository(AbstractSlingRepository.java:810)\n    at org.apache.sling.jcr.base.AbstractSlingRepository.activate(AbstractSlingRepository.java:629)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.apache.felix.scr.impl.ImmediateComponentManager.createImplementationObject(ImmediateComponentManager.java:226)\n    at org.apache.felix.scr.impl.ImmediateComponentManager.createComponent(ImmediateComponentManager.java:133)\n    at org.apache.felix.scr.impl.AbstractComponentManager.activateInternal(AbstractComponentManager.java:476)\n    at org.apache.felix.scr.impl.AbstractComponentManager.enableInternal(AbstractComponentManager.java:398)\n    at org.apache.felix.scr.impl.AbstractComponentManager.access$000(AbstractComponentManager.java:36)\n    at org.apache.felix.scr.impl.AbstractComponentManager$1.run(AbstractComponentManager.java:99)\n    at org.apache.felix.scr.impl.ComponentActorThread.run(ComponentActorThread.java:85)\n10.03.2009 18:56:31 *INFO * SearchIndex: Index initialized: /u01/media/u01/crxlocal/workspaces/dailymail-prod/index Version: 2 (SearchIndex.java, line 492)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2111",
        "summary": "JSR 283 Node Identifier",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2248",
        "summary": "QValueFactoryImpl$BinaryQValue must not return 'this' on getBinary",
        "description": "This is basically the same as JCR-2238, but for the spi-commons module. BinaryQValue returns 'this' on getBinary(), which will lead to a file not found exception because Binary.dispose() will delete the the underlying temp file.\n\nThe issue is partially hidden by the presence of a bug in BinaryQValue.read(): the RandomAccessFile is not closed after reading, which might prevent deleting of the temp file.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2652",
        "summary": "Can no longer set a Date property using a Long value",
        "description": "Attempting to set a Date property with a Long value throws a javax.jcr.nodetype.ConstraintViolationException. This worked in Jackrabbit 1.6.2.\n\nTo reproduce:\n  Node node = session.getItem(\"/\");\n  node = node.addNode(\"dummy\", \"nt:resource\");\n  ValueFactory vf = session.getValueFactory();\n  Value = vf.createValue(\"1234\", 3); // Create a LongValue\n  node.setProperty(\"jcr:lastModified\", value);\n  System.out.println(node.getProperty(\"jcr:lastModified\"));\n\nExpected result:\n- A date around 1970 is printed to System.out\n\nActual result:\n  javax.jcr.nodetype.ConstraintViolationException: no matching property definition found for {http://www.jcp.org/jcr/1.0}lastModified\n       at org.apache.jackrabbit.core.nodetype.EffectiveNodeType.getApplicablePropertyDef(EffectiveNodeType.java:770)\n       at org.apache.jackrabbit.core.NodeImpl.getApplicablePropertyDefinition(NodeImpl.java:911)\n       at org.apache.jackrabbit.core.ItemManager.getDefinition(ItemManager.java:224)\n       at org.apache.jackrabbit.core.ItemData.getDefinition(ItemData.java:97)\n       at org.apache.jackrabbit.core.PropertyData.getPropertyDefinition(PropertyData.java:53)\n       at org.apache.jackrabbit.core.PropertyImpl.getDefinition(PropertyImpl.java:729)\n       at org.apache.jackrabbit.core.NodeImpl.setProperty(NodeImpl.java:2512)\n\nAccording to Jukka Zitting [1], this might be a side-effect of JCR-2170.\n\n[1] Mail thread from dev@jackrabbit.apache.org: http://markmail.org/message/hn3snufsogjvldad",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3140",
        "summary": "Add configurable hook for password validation",
        "description": "it's a common use case that applications would like to enforce additional logic associated with \nchanging a user password. currently this can only be achieved by using a derived user implementation.\nby extending the functionality added with JCR-3118 it was fairly trivial to provide a hook for those\ncustom password validation checks, writing password expiration date etc.etc. \n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3077",
        "summary": "WeightedHighlighter does not encode XML markup characters",
        "description": "See JCR-2611; the same problem applies to WeightedHighlighter.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2287",
        "summary": "Mandatory jcr:activities node missing after upgrade",
        "description": "The mandatory node is only created when the repository is initially empty. The node is missing when an existing repository instance is upgraded. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2629",
        "summary": "LoginModuleConfig should allow to specify principalProvider-name in addition to the class",
        "description": "Gilles Metz reported this issue regarding login module configuration with Day's CRX based on Jackrabbit, which in\nprevious versions allowed to specify multiple prinicpal providers of the same class but with different configurations.\nWith JR 2.0 and 2.1 this is not supported as the pp class name is used as key in the registry and does not allow\nto specify a separate key/name.\n\n\n\n\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2360",
        "summary": "JcrUtils.getRepository(...) for simple repository access",
        "description": "As discussed on the mailing list, it would be nice to have a trivially simple way (one line of code) to connect to a repository. The RepositoryFactory interface in JCR 2.0 defines a way for clients to get a repository reference without a direct implementation dependency, but a client still needs extra code to handle the Service Provider lookup and the iteration through all the available repository factories.\n\nTo simplify client code I'd like to introduce a JcrUtils.getRepository(Map<String, String>) method that takes care of the tasks mentioned above:\n\n    Map<String, String> parameters = ...; // repository settings\n    Repository repository = JcrUtils.getRepository(parameters);\n\nAs a further simplification, I'd also like to introduce a JcrUtils.getRepository(String) method that builds the parameter map based on a given \"repository URI\".\n\n    Repository repository = JcrUtils.getRepository(\"file:///path/to/repository\");\n\n    Repository repository = JcrUtils.getRepository(\"http://localhost:8080/server\");\n\nThe set of supported URI types is still to be defined.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2585",
        "summary": "spi2davex: unspecific BadRequest error instead of error code matching the RepositoryException",
        "description": "the JsonDiffHandler#NodeHandler in the server part of the jcr remoting may only throw IOException\nif an error occurs. this results in unspecific BadRequest responses even if the problem source was\nsomething very specific such as e.g. a locked node.\n\nafter having a first glance at this i think that making DiffException a subclass of IOException would\nallow to generate much more specific responses codes that even include the original exception\ndetails.\n\ni will attach a patch as i didn't had time to carefully test it.  [the conformance tests passed].",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1890",
        "summary": "spi2dav: create RepositoryFactory implementation",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2595",
        "summary": "SessionImpl.createSession uses same Subject/LoginContext",
        "description": "SessionImpl.createSession(String) uses the same loginctx/subject to create a new session.\nthis will cause problems if Session.logout() is called on the original instance.\n\ni suggest to fix that by creating a new subject for the new session instance.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2097",
        "summary": "Broke lock tests in jcr2spi after the JCR 2.0 upgrade",
        "description": "My changes during the JCR 2.0 upgrade have broken the following tests in spi2jcr:\n\n    org.apache.jackrabbit.test.api.lock.LockTest\n    org.apache.jackrabbit.jcr2spi.lock.SessionScopedLockTest\n\nI'll mark them as known issues for now to get the Hudson build back up again, but will continue looking at what I did to cause this breakage.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2496",
        "summary": "Internal error in WorkspaceItemStateFactory#createDeepNodeState ",
        "description": "When WorkspaceItemStateFactory#createDeepNodeState receives the current entry as argument for anyParent, it throws RepositoryException with the message \"Internal error while getting deep itemState\". This is incorrect (probably a leftover from JCR-1797) since any entry is valid as argument for anyParent. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2726",
        "summary": "Make collecting group membership information lazy",
        "description": "JCR-2710 added a more scalable content model for storing group membership information. To further leverage the new model it would be preferable when group membership collecting where lazy. (i.e. Group#getDeclaredMembers() and Group#getMembers() should not construct the list of all members up front). \n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-508",
        "summary": "TCK: NodeTest#testAddNodeItemExistsException fails if validation deferred until save",
        "description": "The test expects addNode to fail if a same-name sibling already exists.  JSR-170 allows this validation to be deferred until save.\n\nProposal: call save in the \"try\" block.\n\n--- NodeTest.java       (revision 422074)\n+++ NodeTest.java       (working copy)\n@@ -380,6 +391,7 @@\n         try {\n             // try to add a node with same name again\n             defaultTestNode.addNode(nodeName3, testNodeType);\n+            defaultRootNode.save();\n             fail(\"Adding a node to a location where same name siblings are not allowed, but a node with same name\" +\n                     \" already exists should throw ItemExistsException \");\n         } catch (ItemExistsException e) {\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1888",
        "summary": "Add customizable filtering to GQL",
        "description": "Currently GQL is not very flexible because it does not have any hooks that  allows you to modify the query that gets generated from the GQL syntax. As a first step I'd like to introduce a filtering mechanism that can be used to post process the result set and exclude certain rows. This is useful when you cannot express an application constraint in GQL.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1300",
        "summary": "spi2dav Improve performance for large binary properties",
        "description": "Sending large binary properties over spi2dav is slow and requires a lot of heap space in both client and server.\nOne problematic part is base64 conversion of the property value.\n\nOn the contrary, using 'normal' webdav interface (/repository/default/ instead of /server) for uploading a file (through traditional webdav client) it is pretty fast and don't have such impact on heap space.\n\nSome suggestions from the previous discussion:\n - avoid temporary copies of the data, and persist large objects as early as possible. \n - transfer large objects in blocks from the Jackrabbit SPI client to the server (and back).\n - make usage of the global data store (JCR-926). \n - straight forward PUT for single-valued properties\n\nLink to discussion: http://www.mail-archive.com/dev@jackrabbit.apache.org/msg09481.html\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2770",
        "summary": "Initial size of ConcurrentCache depends on number of segments (available processors)",
        "description": "This causes a build failure on my machine. Tests run into an OOME because the initial memory footprint of a ConcurrentCache on my machine is 8k. Many of the tests keep references to some kind of repository objects (node, session, x-manager), which means ConcurrentCache instances  cannot be garbage collected immediately after a test run.\n\nI think the overall initial size of the cache should be independent of the number of segments. See proposed patch.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-2304",
        "summary": "jackrabbit-jcr-client tests fail (and are disabled in pom)",
        "description": "I suggest to enable the tests and fix the issues causing them to fail. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2873",
        "summary": "Add a way to locate full text extraction problems",
        "description": "Full text indexing of a binary document can fail for various reasons. Currently we just log a generic error message in such cases, which makes it difficult for the user to locate such problems for review and reindexing. We should improve this by making the logs more informative or by adding some other mechanism for locating troublesome documents.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1668",
        "summary": "After RepositoryImpl instance has been created and shut down, some classes cannot be unloaded",
        "description": "I've built a simple web-application, which contains one servlet loaded at start-up. In its init() method an instance of RepositoryImpl() is created, in its destroy() method this instance is stopped (using shutdown()).\nFrom the servlet code, only classes in jackrabbit-core, JCR API and Servlet API are referenced.\njackrabbit-core version is 1.4.5, and jackrabbit-jcr-commons version is 1.4.2. Other jackrabbit libs are all of 1.4 version.\n\nEven if servlet's doGet() method never gets called, when the web-application is redeployed, all its classes still hang in memory, which produces a memory leak.\n\ninit() method is \n\n    public void init() throws ServletException {\n        super.init();\n        try {\n            RepositoryConfig repoConfig = RepositoryConfig.create(getClass().getResourceAsStream(\"repository.xml\"), \".\");\n            repo = RepositoryImpl.create(repoConfig);\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n\nwhile destroy() method is\n\n    public void destroy() {\n        repo.shutdown();\n        super.destroy();\n    }\n\nEven when I applied patches from JCR-1636 and added TransientFileFactory.shutdown() call to destroy() method, nothing has changed.\nTested this in Jetty 6.1.9 and Tomcat 6.0.14.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1724",
        "summary": "Jackrabbit utilities",
        "description": "Attached are two utilities for Jackrabbit:\n\nThe first one is a DataStore implementation that uses Amazon S3 for storage.\nThis is fairly straightforward. It is configured by adding a DataStore\nsection to the repository.xml file, e.g.:\n   <DataStore class=\"org.jcrutil.S3DataStore\">\n       <param name=\"awsAccessKey\" value=\"\" />\n       <param name=\"awsSecretKey\" value=\"\" />\n       <param name=\"bucketName\" value=\"\" />\n       <param name=\"minModifiedDate\" value=\"0\" />\n       <param name=\"minRecordLength\" value=\"0\" />\n   </DataStore>\n\nThe second utility is a JCR based Commons VFS filesystem provider. This\nallows you to access a JCR repository (nt:file and nt:folder nodes) using\nthe Commons VFS API. I've also used this with MINA FTP Server and Dctm VFS\n(http://dctmvfs.sourceforge.net/) to provide FTP access to a Jackrabbit\nrepository.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2466",
        "summary": "jcr2spi: versionmanager#checkout(NodeState) should not forward to checkout(NodeState, NodeId)",
        "description": "VersionManager#checkout(NodeState nodeState) is called if activity is not supported and thus should call the\ncorresponding SPI method instead of checkout(NodeState, NodeId activityId)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-997",
        "summary": "ValueFactory is not extensible",
        "description": "The Jackrabbit ValueFactory implementation should have a generic base class in jackrabbit-jcr-commons. This base class could be reused in SPI.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1868",
        "summary": "Inconsistent state when removing mix:lockable from a locked Node",
        "description": "when the lock holder removes mix:lockable from a locked node, the lock related properties get removed.\nhowever, the lock still is live and present on the node.\n\ni would have expected that either\n\n- removing mix:lockable was not allowed or\n- the lock was automatically released\n\ntest code:\n\n    public void testRemoveMixLockableFromLockedNode() throws RepositoryException {\n\n        Node n = testRootNode.addNode(nodeName1);\n        n.addMixin(mixLockable);\n        testRootNode.save();\n\n        Lock l = n.lock(true, true);\n        n.removeMixin(mixLockable);\n        n.save();\n\n        assertFalse(n.isNodeType(mixLockable));                                <===== ok\n        assertFalse(l.isLive());                                                                    <===== lock is still live\n        assertFalse(n.isLocked());                                                            <=====  node is still locked\n        List tokens = Arrays.asList(superuser.getLockTokens());\n        assertFalse(tokens.contains(l.getLockToken()));                    <=====  session contains the token\n\n        assertFalse(n.hasProperty(jcrLockOwner));                             <=====  ok. prop got removed.\n        assertFalse(n.hasProperty(jcrlockIsDeep));                             <=====  ok. prop got removed.\n        n.unlock();                                                                                         <===== LockException (node not lockable)\n    }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2067",
        "summary": "FileDataStore: only open a stream when really necessary",
        "description": "Currently, PropertyImpl.getValue() opens a FileInputStream if the FileDataStore is used.\nIf the application doesn't use the value, this stream is never closed.\n\nPropertyImpl.getValue():\n  return internalGetValue().toJCRValue(session);\nInternalValue.toJCRValue(..):\n  case PropertyType.BINARY:\n    return new BinaryValue(((BLOBFileValue) val).getStream());\nBLOBInDataStore.getStream():\n  return getDataRecord().getStream();\nFileDataRecord.getStream():\n  return new FileInputStream(file);\n\nOne solution is to return a 'lazy' file input stream that only opens the file when reading from the stream (and closing the file when the last byte was read). Maybe there is already a class (in Apache Commons maybe?) that can do that.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-188",
        "summary": "Item states cached in UpdatableItemStateManager not discarded on logout",
        "description": "The SessionItemStateManager disposes only the TransientItemStateManager but not the UpdatableItemStateManager. The latter doesn't release the resources and the cached items keep listening the overlayed state events until the ReferenceMap do its magic. According to my tests in certain circumstances it slows down jackrabbit very much. \n\nIn the charts you can see the time it takes to jackrabbit to save each child node. The first test uses a single session and the second creates a new session for each added node.\n\nThe patch I attach makes both tests take the same time. Opinions?\n\n05-08-16-one session.GIF\n/ login\n  / loop\n    / add node\n    / save\n/ logout\n\n\n05-08-16-one session per save.GIF\n/ loop\n  / login\n  / add node\n  / save\n  / logout\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1335",
        "summary": "bad assumptions on QueryResult.getIterator() semantics in QueryResultNodeIteratorTest.testSkip()",
        "description": "testSkip() assumes that calling getIterator() a second time will return a new iterator of the same size. JSR-170 is silent on this. Forcing a server to implement this essantially means that the query result must be cached until there's no reference to QueryResult anymore.\n\nAs this is a test of skip(), not getIterator(), the test should really refetch a new QueryResult in order to obtain a new iterator.\n\n(Note: The issue of the semantics of QueryResult.getIterator should be discussed by the JCR EG.)\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-385",
        "summary": "ClassCastExeption when executing union queries",
        "description": "The XPathQueryBuilder throws a ClassCastException on line 322 in release 0.9 when executing syntactically valid union queries. An example query would be \"//element(*, nt:file) or //element(*, mix:lockable)\". It appears that in the invocation of the visit method the SimpleNode id indicates a type of JJTROOTDESCENDANTS at a certain point but the data is actually an OrQueryNode and hence the cast to a PathQueryNode fails.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-913",
        "summary": "DatabaseJournal.checkSchema generates \"Cannot call commit when autocommit=true\" Exception",
        "description": "When I tried to activate clustering with adding the following XML to repository.xml, \n\n    <Cluster id=\"node_1\" syncDelay=\"5\">\n\t\t<Journal class=\"org.apache.jackrabbit.core.journal.DatabaseJournal\">\n\t\t\t<param name=\"revision\" value=\"${rep.home}/revision\"/>\n\t\t\t<param name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n\t\t\t<param name=\"url\" value=\"jdbc:mysql://localhost/jcr\"/>\n\t\t\t<param name=\"user\" value=\"userX\"/>\n\t\t\t<param name=\"password\" value=\"passWordC\"/>\n\t\t\t<param name=\"schema\" value=\"mysql\"/>\n\t\t\t<param name=\"schemaObjectPrefix\" value=\"J_C_\"/>\n\t\t</Journal>\n    </Cluster>\n\nDatabse Journal threw the following exception:\n\n....\nCaused by: javax.jcr.RepositoryException: Unable to initialize connection.: Unable to initialize connection.\n        at org.apache.jackrabbit.core.RepositoryImpl.createClusterNode(RepositoryImpl.java:677)\n        at org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:276)\n        at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:584)\n        at org.apache.jackrabbit.core.TransientRepository$2.getRepository(TransientRepository.java:245)\n        at org.apache.jackrabbit.core.TransientRepository.startRepository(TransientRepository.java:265)\n        at org.apache.jackrabbit.core.TransientRepository.login(TransientRepository.java:333)\n        at com.liferay.portal.jcr.jackrabbit.JCRFactoryImpl.createSession(JCRFactoryImpl.java:71)\n        at com.liferay.portal.jcr.JCRFactoryUtil.createSession(JCRFactoryUtil.java:53)\n        at com.liferay.portal.jcr.JCRFactoryUtil.createSession(JCRFactoryUtil.java:57)\n        at com.liferay.documentlibrary.util.IndexerImpl.reIndex(IndexerImpl.java:258)\n        ... 17 more\nCaused by: org.apache.jackrabbit.core.cluster.ClusterException: Unable to initialize connection.\n        at org.apache.jackrabbit.core.cluster.ClusterNode.init(ClusterNode.java:218)\n        at org.apache.jackrabbit.core.cluster.ClusterNode.init(ClusterNode.java:189)\n        at org.apache.jackrabbit.core.RepositoryImpl.createClusterNode(RepositoryImpl.java:674)\n        ... 26 more\nCaused by: java.sql.SQLException: Can't call commit when autocommit=true\n        at com.mysql.jdbc.Connection.commit(Connection.java:2161)\n        at org.apache.jackrabbit.core.journal.DatabaseJournal.checkSchema(DatabaseJournal.java:437)\n        at org.apache.jackrabbit.core.journal.DatabaseJournal.init(DatabaseJournal.java:168)\n        at org.apache.jackrabbit.core.cluster.ClusterNode.init(ClusterNode.java:213)\n        ... 28 more\n\nWhen I examined the source code of the release jackrabbit 1.3, I saw that the init() method for DatabaseJournal class is:\n\n\t\t\t...\n\t\t\tClass.forName(driver);\n\t\t\tcon = DriverManager.getConnection(url, user, password);\n\t\t\tcon.setAutoCommit(true);\n\n\t\t\tcheckSchema();\n\t\t\tprepareStatements();\n\t\t\t...\n\nand just before checkSchema() method's finally block:\n\n\t\t\t...\n\t\t\t// commit the changes\n\t\t\tcon.commit();\n\t\t\t...\n\nSo, it seemed normal to see the mentioned exception. I just commented out the commit expression and continued my development. Am I missing something?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3202",
        "summary": "AuthorizableImpl#memberOf and #declaredMemberOf should return RangeIterator",
        "description": "it would be favorable if the iterator returned by Authorizable#memberOf and #declaredMemberOf\nwould return a RangeIterator in order to all the caller to determine the size without having to\niterate.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-632",
        "summary": "VersionManager lock not released in some circumstances",
        "description": "In some circumstances it is possible that lock is not released in VersionManager.checkin method.\n\nThere is following block of code in checkin nethod :\n\n        aquireReadLock();\n        try {\n              .....\n        } catch (IllegalStateException e) {\n            releaseReadLock();\n            throw new RepositoryException(\"Unable to start edit operation.\");\n        }\n\nLock release should be in finally block to make sure that lock is released when unexpected exception is thrown.\nIn our environment we are getting NPE in mentioned block of code, it results in persisten lock. \nNo versioning operation is possible and our application server is running ot of threads (all threads are locked).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1318",
        "summary": "Repository Home locked not released despite RepositoryException being thrown.",
        "description": "When an exception is thrown when calling RepositoryImpl.create(...) a .lock file is created in the repository home directory and not removed despite there no longer being an active connection.  If the user attempts to create the repository again (e.g recover from the exception because the url of the repository was temporarily unavailable) a RepositoryException is thrown again indicating that the repository home is locked by another process because there is a .lock file.  If a Repository is not successfully created then the repository home should not be locked.\n\nThe lock is only released when the repository is shutdown but in this case the Repository object is never created successfully for that method to be called.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2080",
        "summary": "DataStore: garbage collection can fail when using workspace maxIdleTime",
        "description": "The GarbageCollectorTest fails because some workspaces have an idle timeout. The data store garbage collector should prevent workspace close-on-idle.\n\nProposed solution: instead of using the 'regular' system sessions in the garbage collector, use special 'registered system sessions'. The sessions get garbage collected when no longer used, that means this patch requires that JCR-1216 \"Unreferenced sessions should get garbage collected\" is applied. So for each workspace, the code is:\n\n// this will initialize the workspace if required\nwspInfo.getSystemSession();\n\nSessionImpl session = SystemSession.create(rep, wspInfo.getConfig());\n// mark this session as 'active' for so the workspace does\n// not get disposed by workspace-janitor until the garbage collector is done\nrep.onSessionCreated(session);            \n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3199",
        "summary": "workspace-wide default for lock timeout",
        "description": "There should be a way to define a workspace-wide default for JCR lock timeouts (in case the code creating the lock did not specify one).",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1985",
        "summary": "NullPointerException in GarbageCollector.scan() if no DataStore configured",
        "description": "\nI am running the garbage collector in a separate thread every 5 minutes.\n\n            GarbageCollector gc = ((SessionImpl)mSession).createDataStoreGarbageCollector();\n            gc.scan();\n            gc.stopScan();\n            int du = gc.deleteUnused();\n\nWhen using Jackrabbit v1.5.2 I get sometimes a null pointer exception;\n\njava.lang.NullPointerException\n        at org.apache.jackrabbit.core.data.GarbageCollector.scan(GarbageCollector.java:153)\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1428",
        "summary": "Add API for selective bundle consistency check (Jackrabbit-specific)",
        "description": "Add a jackrabbit-specific API for doing a selective consistencyCheck, ie. on single nodes. The current entire-workspace check can be very slow if there workspace is large enough. Also it should be easy to write a tool to invoke that feature programmatically rather than by configuration + restart (see below).\n\nExisting Implementation:\nThe current bundle consistencyCheck feature is enabled by setting a bundle PM parameter and restarting Jackrabbit, it will then run upon startup (see JCR-972 for the only issue regarding bundle consistency check). This check looks for broken parent-child relationships, ie. it will remove any child node entries that reference non-existing parent nodes. For non-existing parent UUIDs and other problems in bundles it will log those.\n\nOutlook:\nAn advanced consistencyCheck could also check for non-existing version nodes and vice-versa (see JCR-630), but this is not the focus of this issue and could be a later addition to the API.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3135",
        "summary": "Upgrade to Logback 1.0",
        "description": "Logback 1.0 was just released (see http://mailman.qos.ch/pipermail/announce/2011/000093.html). There are no big new features or other major changes, but the bump to 1.0 is still a good point for us to upgrade to get all the latest bug fixes and other improvements.\n\nAt the same time we should upgrade our SLF4J depedency to the latest 1.6.4 version.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2978",
        "summary": "Add accessor for parent to NodeInfoBuilder/PropertyInfoBuilder",
        "description": "NodeInfoBuilder and PropertyInfoBuilder should allow access to its respective parents. I suggest to add a getParent() method to both classes. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-125",
        "summary": "Repository holds onto Session instance after logout",
        "description": "\nAfter a call to Session.logout the Repository instance's activeSession map still holds a reference to the session. This causes a problem when trying to unlock nodes locked by another session, the addLockToken method rejects the lock token.\n\nLooking at the code in Session.logout, it tries to notify SessionListeners about the logout but Repository, which implements the SessionListener interface and will remove a session on logout, doesn't register with the Session to receive the logout notification.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2449",
        "summary": "Slow performance due to JCR-2138 (Prevent persistence of faulty back-references)",
        "description": "In revision 782898, the following code was introduced:\n\nupdateReferences() {\n    for (Iterator i = local.addedStates(); i.hasNext();) {\n        ...\n        if (hasItemState(state.getId())) {\n            ...\n        }\n    }\n}\n\nThis will try to fetch inexistent nodes from the persistence manager.\nDepending on the persistence manager implementation, this is very slow.\nI hope there is a way to avoid this call, or if not, speed it up.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2070",
        "summary": "jcr-server should respect child node definition of jcr:content",
        "description": "When creating a new file, jcr:content defaults to nt:unstructured. This causes file creation to fail when the underlying persistent store (i.e. SPI implementation) does not support nt:unstructured for jcr:content. \n\nI suggest to check whether the underlying implementation provides its own node type for jcr:content and use that one. If not, default to nt:unstructured.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-72",
        "summary": "Session.impersonate non-functional",
        "description": "Currently SessionImpl.impersonate simply calls Repository.login with the given credentials and the workspace name of the session. If the credentials are incomplete in that the password is missing, the method throws a \"LoginException: Failed to authenticate userID\", which is actually a misleading text, as the reason is not failure to authenticate userID but at best that the session has not enough access rights to impersonate as userID.\n\nFor my application, it is crucial, that Session.impersonate is implemented in the sense that this method allows creation of a session with password-less credentials. I accept this method to fail, but it should fail with a correct message.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1555",
        "summary": "Add support for boolean values to QValue",
        "description": "I suggest to add support for reading and writing boolean values to QValue and QValueFactory. I find it strange that there is such support for the other data types but booleans must be constructed via strings. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1585",
        "summary": "Remove calls to System.out in tests",
        "description": "Two tests write to System.out: QueryTest and HierarchyNodeTest",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-727",
        "summary": "NamespaceRegistryTest uses an invalid URI as namespace URI",
        "description": "The test cases use \"www.apache.org/...\" as a namespace URI, but this is not a URI.\n\nSuggest to fix by using a proper URI, such as by prefixing with \"http://\".\n\nA related question is what our expectation is for JCR implementations. Are they allowed to reject something that doesn't parse as a URI according to RFC3986?\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-69",
        "summary": "removing source parent node after session move throws on save",
        "description": "the following code fragment illustrates the problem:\n\n        /**\n         * create the following node tree:\n         *     \n         *       + A\n         *         + B\n         *            + C\n         *         + D\n         */\n        Node A;\n        if (root.hasNode(\"A\")) {\n            A = root.getNode(\"A\");\n        } else {\n            A = root.addNode(\"A\");\n        }\n        Node B = A.addNode(\"B\");\n        Node C = B.addNode(\"C\");\n        Node D = A.addNode(\"D\");\n        root.save();\n\n        // move C under D\n        session.move(\"/A/B/C\", \"/A/D/C\");\n        // remove B\n        A.getNode(\"B\").remove();\n        /**\n         * the expected resulting node tree:\n         *     \n         *       + A\n         *         + D\n         *            + C\n         */\n        A.save();\n\n\n==> the last save() will throw \njavax.jcr.RepositoryException: inconsistency: failed to retrieve transient state for ...\n ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1515",
        "summary": "CompactNodeTypeDefWriter uses bad format for residual properties ",
        "description": "CompactNodeTypeDefWriter writes {}* instead of * for residual properties. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1303",
        "summary": "Missing derby dependency",
        "description": "the derby dependency is missing in the OCM subproject. So, the unit tests cannot be executed. ",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-1092",
        "summary": "Bundle persistence managers node id key store/load is not symertric on MySql causing NoSuchItemState Exceptions ",
        "description": "It looks like the binary values read back from MySql where the UUID contains 0's is not the same as that generated from the UUID getRawBytes() call. As result, you can store a node with the UUID that has 0's but its never found when read back. This therefore causes corruption in random places when certain UUIDs are generated.\n\nTest Case: \n\nI've attached 2 files. One causes node corruption when imported, the other does not.\nThe only difference is that I removed any 0 values from the problem UUID in the file that causes corruption.\n\nAs Stefan pointed out, I had manipulated the test case to use standard nt types when in fact I should have provided the following info (sorry Stefan) e.g. the test folder types are referencable hence the jcr:uuid allocation\n\n[acme:Folder] > nt:folder, mix:referenceable\n\nIf I import causes_corruption.xml and then attempt to \"ls\" AclObjectIdentities then loadBundle() returns null for the UUID \n\na55f3f6b-a909-4e8d-b65a-93002ced0920 which in bytes is [-91, 95, 63, 107, -87, 9, 78, -115, -74, 90, -109, 0, 44, -19, 9, 32]\n\nIf I import works.xml then \"ls\" works fine for the same node as I've manually changed the UUID to replace 0s with 1s in the last section.\n\na55f3f6b-a909-4e8d-b65a-93112ced1921 [-91, 95, 63, 107, -87, 9, 78, -115, -74, 90, -109, 17, 44, -19, 25, 33]\n\n\nTesting shows this issue highlights a problem with the Bundle persistence manager and MySqls method of handling BINARY columns.\nThe solution looks to be to replace BINARY(16) with VARBINARY(16). Quoting from http://dev.mysql.com/doc/refman/5.0/en/binary-varbinary.html...\n\"If the value retrieved must be the same as the value specified for storage with no padding, it might be preferable to use VARBINARY or one of the BLOB data types instead.\"\nA review of our logs shows that all of the corruption we've seen has related to nodes with UUIDs including 0's.\n\n* Shall I log a JIRA ticket for this?\n* Anyone see any issues with this fix?\n\n\nIn the following example you can see I'm showing all bundles in the \"test1\" workspace.\n\nmysql> select hex(node_id) from test1_bundle;\n+----------------------------------+\n| hex(node_id)                     |\n+----------------------------------+\n| 28126C3E36A0471D9CDC5AC423BAC9C5 |\n| A55F3F6BA9094E8DB65A93002CED0920 |\n| CAFEBABECAFEBABECAFEBABECAFEBABE |\n| D638EACCDEB641FD8868804C8ECEFFFD |\n| DEADBEEFCAFEBABECAFEBABECAFEBABE |\n+----------------------------------+\n5 rows in set (0.00 sec)\n\n...but a select using the same UUID hex value returns no rows.\n\nmysql>  select node_id from test1_bundle where \nmysql> unhex('A55F3F6BA9094E8DB65A93002CED0920') = node_id;\nEmpty set (0.00 sec)\n\nI've then created a new \"test3\" workspace which I modified to use varbinary instead of binary with:\n\nalter table test3_bundle modify NODE_ID varbinary(16); alter table test3_refs modify NODE_ID varbinary(16);\n\nMy import test case now no longer fails and the following query proves that query operations, after a store, return rows as expected.\n\nmysql>  select node_id from test3_bundle where \nmysql> unhex('A55F3F6BA9094E8DB65A93002CED0920') = node_id;\n+------------------+\n| node_id          |\n+--------\u00b6Z ,\u00ed--  |\n+------------------+\n1 row in set (0.00 sec)\n\nmysql> desc test3_bundle;\nERROR 2006 (HY000): MySQL server has gone away No connection. Trying to reconnect...\nConnection id:    7116\nCurrent database: mmptest\n\n+-------------+---------------+------+-----+---------+-------+\n| Field       | Type          | Null | Key | Default | Extra |\n+-------------+---------------+------+-----+---------+-------+\n| NODE_ID     | varbinary(16) | YES  | UNI | NULL    |       |\n| BUNDLE_DATA | longblob      | NO   |     |         |       |\n+-------------+---------------+------+-----+---------+-------+\n2 rows in set (0.00 sec)\n\n\nmysql>  alter table test3_bundle modify NODE_ID varbinary(16);\nQuery OK, 2 rows affected (0.00 sec)\nRecords: 2  Duplicates: 0  Warnings: 0\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-476",
        "summary": "Remove recently added getJCRPath()/getQPath() from NamespaceResolver",
        "description": "issue JCR-473 added 2 new methods to NamespaceResolver: \n\n    public Path getQPath(String jcrPath) throws MalformedPathException;\n    public String getJCRPath(Path qPath) throws NoPrefixDeclaredException;\n\nwhich do not belong here, since the NamespaceResolver has nothing to do with paths. suggest to remove them.\n\nfurther is the naming of the QName related methods a bit vague. suggest to rename them to:\n\n   QName parseName(String jcrName)\n   String formatName(QName qName)\n\n(although they do not belong here either, but helps to leverage evt. caching namespace resolvers).\n\n",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-813",
        "summary": "TCK: testSaveMovedRefNode",
        "description": "NodeUUIDTest.testSaveMovedRefNode\nSessionUUIDTest.testSaveMovedRefNode\n\nmakes the assumption, that moving a referenceable node with session A is visible as 'move' operation within session B as well.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-3001",
        "summary": "DescendantSelfAxisQuery may fail with IOException when session has limited access",
        "description": "The DescendantSelfAxisQuery uses the current session to look up nodes by id. When the session does not have access to a node the exception is incorrectly re-thrown an IOException. Instead, any ItemNotFoundException should be caught and ignored. This is probably a regression caused by JCR-1365 introduced with Jackrabbit 1.5.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2810",
        "summary": "Error creating DB2 table for Journaling",
        "description": "Hi guys,\n\nFirst of all, congratulations for the fantastic job.\n\nI'm deploying a Jackrattbit-JCA resource adapter to a clustered Websphere environment and using a DB2 for storing data and realized some missing code to add DB2 support.\n\nHere is:\n\nJACKRABBIT-CORE, @ org.apache.jackrabbit.core.util.db, method guessValidationQuery (the last one), I adjusted as follows to add a DB2 validation query:\n\n----------------------------------------------------------------------------------------------------------\n    private String guessValidationQuery(String url) {\n        if (url.contains(\"derby\")) {\n            return \"values(1)\";\n        } else if (url.contains(\"mysql\")) {\n            return \"select 1\";\n        } else if (url.contains(\"sqlserver\") || url.contains(\"jtds\")) {\n            return \"select 1\";\n        } else if (url.contains(\"oracle\")) {\n            return \"select 'validationQuery' from dual\";\n        } else if (url.contains(\"h2\")) {\n            return \"select 1\";\n        } else if (url.contains(\"db2\")) {\n        \treturn \"values(1)\";\n        }\n        log.warn(\"Failed to guess validation query for URL \" + url);\n        return null;\n----------------------------------------------------------------------------------------------------------\n\nAnd as a final touch, a DDL to build the tables:\n\nJACKRABBIT-CORE, @ src/main/resources/org/apache/jackrabbit/core/journal, added a file named db2.dll as follows (actually I copied this from derby.dll)\n\n----------------------------------------------------------------------------------------------------------\n#  Licensed to the Apache Software Foundation (ASF) under one or more\n#  contributor license agreements.  See the NOTICE file distributed with\n#  this work for additional information regarding copyright ownership.\n#  The ASF licenses this file to You under the Apache License, Version 2.0\n#  (the \"License\"); you may not use this file except in compliance with\n#  the License.  You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\ncreate table ${schemaObjectPrefix}JOURNAL (REVISION_ID BIGINT NOT NULL, JOURNAL_ID varchar(255), PRODUCER_ID varchar(255), REVISION_DATA blob)\ncreate unique index ${schemaObjectPrefix}JOURNAL_IDX on ${schemaObjectPrefix}JOURNAL (REVISION_ID)\ncreate table ${schemaObjectPrefix}GLOBAL_REVISION (REVISION_ID BIGINT NOT NULL)\ncreate unique index ${schemaObjectPrefix}GLOBAL_REVISION_IDX on ${schemaObjectPrefix}GLOBAL_REVISION (REVISION_ID)\ncreate table ${schemaObjectPrefix}LOCAL_REVISIONS (JOURNAL_ID varchar(255) NOT NULL, REVISION_ID BIGINT NOT NULL)\n\n# Inserting the one and only revision counter record now helps avoiding race conditions\ninsert into ${schemaObjectPrefix}GLOBAL_REVISION VALUES(0)\n----------------------------------------------------------------------------------------------------------\n\n\nBest regards,\n\n\nJ Marcos",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1572",
        "summary": "DbDataStore connection does not always reconnect",
        "description": "If a DbDataStore connection is closed due to an error all subsequent addRecord calls will fail with 'connection has been closed and autoReconnect == false'\n after getRecord is called and the connection is reconnected addRecord will succeed.\n\nthe connection should be validated before setting autoReconnect = false or on retrieval from the pool.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1592",
        "summary": "JSR 283: Activities",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2135",
        "summary": "UserManagement: make membership a weakreferences",
        "description": "the 2.0 user management code still contains a TODO asking for changing group-membership from reference to weakreference. \n\nnow that weakreferences are implemented in jackrabbit-core i'd like to make that change both in the node type definitions and the code.\n\ni'm opening this issue in order to give us the chance to keep track of node type change that may cause troubles....",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2423",
        "summary": "Make Jackrabbit repository DTD easier to extend",
        "description": "It would be nice if a downstream project could easily extend the Jackrabbit repository configuration format by adding new configuration elements under the <Repository> root. Currently that can only be done by customizing a copy of the entire DTD. It would be better if the relevant parts of the DTD could simply be included via an external parameter entity into a downstream DTD.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-489",
        "summary": "TCK: Incorrect check of namespace mappings in System View XML export",
        "description": "org.apache.jackrabbit.test.api.SysViewContentHandler. In endDocument(), two issues:\n\n1. line 351: tries to go through a table of prefixes but uses a fixed index inside the loop;\n2. The mapping for the 'xml' prefix should be skipped (it must be registered in the Session but must not be registered during export since this is a built-in XML mapping.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-634",
        "summary": "Log / trace wrapper for the JCR API",
        "description": "I have implemented the log / trace mechanism for the JCR API. A short summary:\n\n- A wrapper for a Repository. All other objects that where created directly or indirectly (Session, Node and so on) are wrapped as well. \n- The wrappers log all JCR method calls to a file and call the underlying methods. \n- Return values and calling method / line number can be logged as well (optional). \n- The log file itself is mainly Java source code and can be compiled and run.\n- Included is a player to re-play log files (for example, if the log file is too big to be compiled).\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-766",
        "summary": "Remove Maven 1 files",
        "description": "Now that we have a working Maven 2 build environment (JCR-332) we should remove the old Maven 1\nproject files to avoid confusion and misunderstandings. The old Maven 1 build environment doesn't even\nwork anymore.\n\nUnless anyone objects, I'll proceed to remove the project.xml, maven.xml, and project.properties files in a few days.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-437",
        "summary": "Restoring a node which has OPV=Version children fails if they are not versionable",
        "description": "when a node has a OPV=Version childnode which is not versionable itself, restoring of the node fails,\nwhen it tries to read the versionhistory of that childnode.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2393",
        "summary": "Index migration fails for property names that are prefixes of others",
        "description": "The automatic index migration (JCR-1363) introduced in Jackrabbit version 1.5.0 replaces the separator char for named term text in PROPERTIES field. Util 1.4.x '\\uFFFF' was used and after migration '[' is used. This changes the overall order of  PROPERTIES terms and leads to assertion failures. See attached test.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3176",
        "summary": "JCARepositoryManager does not close InputStream",
        "description": "JCR-3129 opened a already closed issue [JCR-1667]",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-374",
        "summary": "Missing 'node removed' event when removing a version",
        "description": "When a version is removed only one 'node removed' event is triggered for the version node. Even though the frozen node under that version also gets removed there is no event for the frozen node.\n\nSee failing test cases:\norg.apache.jackrabbit.core.observation.VersionEventsTest#testRemoveVersion()\norg.apache.jackrabbit.core.observation.VersionEventsTest#testXARemoveVersion()\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2320",
        "summary": "Real In-memory Repository",
        "description": "For unit tests it is desirable to have an in-memory repository which holds its whole data(even PropertyType.BINARY) in memory.\nThe actual implementation of org.apache.jackrabbit.core.persistence.mem.InMemPersistenceManager uses the FileSystemBLOBStore along with LocalFileSystem.\nThe binary properties are serialized to the OS-Filesystem.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2245",
        "summary": "Make QValueFactoryImpl extensible",
        "description": "The class is currently final and other modules therefore copied code. This kind of duplication it hard to maintain and should be avoided.\n\nIf QValueFactoryImpl would be designed to be extensible then other classes could reuse much of the code.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2171",
        "summary": "Deadlock in SharedItemStateManager on session.move and node.save",
        "description": "I have multiple threads in a test case for performing action on different workflow instances stored inside a Jackrabbit repository.\nMost of the time the test case hangs because of the following deadlock:\n\n\"ActionTrigger38\" daemon prio=10 tid=0x9060ec00 nid=0x2f7e in Object.wait() [0x8f505000..0x8f505f20]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0xb3ef0208> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)\n        at java.lang.Object.wait(Object.java:485)\n        at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock.acquire(Unknown Source)\n        - locked <0xb3ef0208> (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)\n        at org.apache.jackrabbit.core.state.DefaultISMLocking$ReadLockImpl.<init>(DefaultISMLocking.java:84)\n        at org.apache.jackrabbit.core.state.DefaultISMLocking$ReadLockImpl.<init>(DefaultISMLocking.java:78)\n        at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireReadLock(DefaultISMLocking.java:44)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireReadLock(SharedItemStateManager.java:1409)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.hasItemState(SharedItemStateManager.java:286)\n        at org.apache.jackrabbit.core.state.XAItemStateManager.hasItemState(XAItemStateManager.java:295)\n        at org.apache.jackrabbit.core.state.SessionItemStateManager.hasItemState(SessionItemStateManager.java:206)\n        at org.apache.jackrabbit.core.HierarchyManagerImpl.hasItemState(HierarchyManagerImpl.java:164)\n        at org.apache.jackrabbit.core.CachingHierarchyManager.nodeAdded(CachingHierarchyManager.java:674)\n        at org.apache.jackrabbit.core.CachingHierarchyManager.nodeAdded(CachingHierarchyManager.java:366)\n        - locked <0xb4020630> (a java.lang.Object)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyNodeAdded(StateChangeDispatcher.java:159)\n        at org.apache.jackrabbit.core.state.SessionItemStateManager.nodeAdded(SessionItemStateManager.java:905)\n        at org.apache.jackrabbit.core.state.NodeState.notifyNodeAdded(NodeState.java:852)\n        at org.apache.jackrabbit.core.state.NodeState.renameChildNodeEntry(NodeState.java:370)\n        - locked <0xb26df780> (a org.apache.jackrabbit.core.state.NodeState)\n        at org.apache.jackrabbit.core.NodeImpl.renameChildNode(NodeImpl.java:559)\n        at org.apache.jackrabbit.core.SessionImpl.move(SessionImpl.java:1034)\n        at org.ametys.plugins.repository.DefaultSessionFactory$SessionWrapper.move(DefaultSessionFactory.java:398)\n        at org.ametys.plugins.workflow.store.JackrabbitWorkflowStore.moveToHistory(JackrabbitWorkflowStore.java:797)\n        at com.opensymphony.workflow.AbstractWorkflow.createNewCurrentStep(AbstractWorkflow.java:1474)\n        at com.opensymphony.workflow.AbstractWorkflow.transitionWorkflow(AbstractWorkflow.java:1256)\n        at com.opensymphony.workflow.AbstractWorkflow.doAction(AbstractWorkflow.java:567)\n        at org.ametys.plugins.workflow.Workflow.doAction(Workflow.java:227)\n        at org.ametys.plugins.workflow.WorkflowTestCase$ActionTrigger.run(WorkflowTestCase.java:195)\n\n\"ActionTrigger12\" daemon prio=10 tid=0x904dd000 nid=0x2f64 waiting for monitor entry [0x8fd3f000..0x8fd40020]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.jackrabbit.core.CachingHierarchyManager.nodeModified(CachingHierarchyManager.java:306)\n        - waiting to lock <0xb4020630> (a java.lang.Object)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyNodeModified(StateChangeDispatcher.java:189)\n        at org.apache.jackrabbit.core.state.SessionItemStateManager.nodeModified(SessionItemStateManager.java:929)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyNodeModified(StateChangeDispatcher.java:189)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.stateModified(LocalItemStateManager.java:446)\n        at org.apache.jackrabbit.core.state.XAItemStateManager.stateModified(XAItemStateManager.java:595)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyStateModified(StateChangeDispatcher.java:111)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.stateModified(SharedItemStateManager.java:400)\n        at org.apache.jackrabbit.core.state.ItemState.notifyStateUpdated(ItemState.java:244)\n        at org.apache.jackrabbit.core.state.ChangeLog.persisted(ChangeLog.java:285)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:735)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:1092)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:337)\n        at org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:347)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:312)\n        at org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:313)\n        at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1103)\n        - locked <0xb4004650> (a org.apache.jackrabbit.core.XASessionImpl)\n        at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:858)\n        at org.ametys.plugins.repository.DefaultSessionFactory$SessionWrapper.save(DefaultSessionFactory.java:414)\n        at org.ametys.plugins.workflow.store.JackrabbitWorkflowStore.markFinished(JackrabbitWorkflowStore.java:757)\n        at com.opensymphony.workflow.AbstractWorkflow.createNewCurrentStep(AbstractWorkflow.java:1473)\n        at com.opensymphony.workflow.AbstractWorkflow.transitionWorkflow(AbstractWorkflow.java:1256)\n        at com.opensymphony.workflow.AbstractWorkflow.doAction(AbstractWorkflow.java:567)\n        at org.ametys.plugins.workflow.Workflow.doAction(Workflow.java:227)\n        at org.ametys.plugins.workflow.WorkflowTestCase$ActionTrigger.run(WorkflowTestCase.java:203)\n\nDifferent session instances (not XA) are used in both threads.\nThe nodes modified are different:\n- ActionTrigger38 is moving a node and the session has not been saved yet.\n- ActionTrigger12 has updated another node and is saving it.\n\nI try to reproduce this behavior in a Jackrabbit test case without success.\nIf you need more information or a test case, let me know i will give it a second try.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1013",
        "summary": "Connection.setAutoCommit(...) fails if connection is managed for JNDIDatabasePersistenceManager",
        "description": "Invoking setAutoCommit() on a db connection fails if the connection is managed.\n\nI propose as a workaround to check if the auto commit must be set previous to setting it (a trivial patch will be provided).\n\nThis can happen eg. if you use JNDI (eg JNDIDatabasePersistenceManager) to fetch the connection on JBoss, and the persistent manager tries to reconnect (see stack trace below).\n\n05 Jul 09:54:24 ERROR sePersistenceManager| failed to re-establish connection\njava.sql.SQLException: You cannot set autocommit during a managed transaction!\n        at org.jboss.resource.adapter.jdbc.BaseWrapperManagedConnection.setJdbcAutoCommit(BaseWrapperManagedConnection.java:482)\n        at org.jboss.resource.adapter.jdbc.WrappedConnection.setAutoCommit(WrappedConnection.java:322)\n        at org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.initConnection(DatabasePersistenceManager.java:731)\n        at org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.reestablishConnection(DatabasePersistenceManager.java:806)\n        at org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.executeStmt(DatabasePersistenceManager.java:852)\n        at org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.exists(DatabasePersistenceManager.java:647)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.hasNonVirtualItemState(SharedItemStateManager.java:1102)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.hasItemState(SharedItemStateManager.java:289)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.hasItemState(LocalItemStateManager.java:180)\n        at org.apache.jackrabbit.core.state.XAItemStateManager.hasItemState(XAItemStateManager.java:252)\n        at org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState(SessionItemStateManager.java:174)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-582",
        "summary": "No support for Oracle schemas",
        "description": "Jackrabbit assumes that the table name (f.e.: prefix + fs_entry) is unique across all schemas  used on one oracle instance. So two Jackrabbit instances using two schemas on the same Oracle instance won't work. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-3156",
        "summary": "Group#getMembers may list inherited members multiple times",
        "description": "i just happen to detect the following regression that seems to be introduces quite a while ago:\n\nGroup#getMembers is defined to return all group members including those inherited by another group being member of that group.\n\nExample:\nUser t\nGroup a : t is declared member\nGroup b : t is declared member\nGroup c : a, b are declared members\n\nThe expected result of Group.getMembers was: a, b and t.\n\nWhat is currently happening is that t is included twice in the returned iterator.\nQuickly testing on jackrabbit 2.0 revealed that this used to work before...\n\nI didn't carefully check when that bug has been introduced but the the refactoring of the membership\ncollections seems to be a possible culprit.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2004",
        "summary": "Update SPI locking to match JCR 2.0",
        "description": "jcr2spi currently uses the JSR 170 way to determine whether a given Session owns the lock by checking of the lock token is null.\nwith JSR 283 a new Lock method has been defined for this, while on the other hand the lock token is always null for session-scoped\nlocks.\n\nIn addition 283-locking allows to specify a timeout hint and hint about the owner info that should be displayed\nfor information purpose.\n\nProposed changes to SPI:\n\n- extend org.apache.jackrabbit.spi.LockInfo to cover the new functionality added with JSR 283\n- add an variant of RepositoryService.lock that allows to specify timeout and owner hint.\n\nProposed changes to JCR2SPI:\n- change jcr2spi to make use of the new functionality and modify the test for session being lock holder.\n  this mainly affects\n  > LockOperation\n  > LockManager impl\n  > Lock impl",
        "label": "NUG",
        "classified": "SPEC",
        "type": ""
    },
    {
        "key": "JCR-1759",
        "summary": "Simplify the usage of OCM annotations",
        "description": "If we are using more reflections during the OCM init phase (class descriptor loading), some OCM annotation settings are not necessary : \n\n@Node(isAbtract=true) : used to specify an abstract classes\n@Node(extend=....) : used to specify the ancestor class\n@Node(isInterface= ...) : used to specify the entity as an interface\n@implement  : used to specify the associated interfaces\n\nIf this refactoring is done, we can set them as deprecated.\n\nThe performances will not suffer because this is done only once during the application startup (when the ObjectContentManager is initialized). ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1356",
        "summary": "Document inheritance of node type attributes such as orderable",
        "description": "Documentation task.\n\nsee http://mail-archives.apache.org/mod_mbox/jackrabbit-users/200801.mbox/browser",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "TASK"
    },
    {
        "key": "JCR-462",
        "summary": "Improve lifecycle management of JCA connector",
        "description": "the shutdown mechanism doesn't work correctly. It shutdowns the repository when the RA (resource adapter) is garbage collected. It causes redeployment to fail because sometimes the new RA is redeployed before the old one is garbage collected.\n\nImplementing the JCA 1.5 interface to manage the lifecycle would be useful.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1313",
        "summary": "Additional excerpt provider implementation",
        "description": "The current DefaultHTMLExcerpt implementation is very simple. It basically picks the first three fragments, regardless of how many matches it contains. There should be an alternative implementation that weights the fragments based on the number of matching terms and the whether phrases have matched.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-903",
        "summary": "Put resource files in java/{main,test}/resources",
        "description": "The Maven standard directory layout (see http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html) suggests that all resource files should be placed in src/main/resources or src/test/resources instead of putting them inside the java subdirectory. Following that guideline would simplify the pom files as we wouldn't need to explicitly configure the resource directories. I'll move the resource files unless anyone argues otherwise.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-116",
        "summary": "JavaCC grammar generation to ${maven.build.dir}/generated-src",
        "description": "Currently the JavaCC grammars in src/grammar/{xpath,sql} are processed into Java source files in src/java/org/apache/jacrabbit/core/query/{xpath,sql} where we also have normal version controlled source files. This leads to the need to maintain special svn:ignore properties and also the more general issue of mixing manually written and automatically generated source files. Because of this the \"maven clean\" command does not (at the moment) truly restore your source tree to a \"fresh checkout\" state.\n\nI'm proposing (as a wish, you are free to disagree) that the JavaCC grammars be generated into Java files within the Maven build directory. The attached patch modifies the javacc maven goals to generate files into ${maven.build.dir}/generated-src. The modified prepare-filesystem goal also adds the generated source path ${maven.build.dir}/generated-src/main/java into the maven compile set so that the generated sources are included in the normal builds.\n\nPS. There are a couple of JavaCC generated files that have been intentionally modified for Jackrabbit. The ant:delete commands at the end of the jacrabbit:generate-*-parser goals specifically remove these generated files. It would however be nicer if custom modifications would not be needed.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": ""
    },
    {
        "key": "JCR-3045",
        "summary": "ResourceConfig: read additional parameters for IOHandler and PropertyHandler that are covered by public setters",
        "description": "the reason for this is that currently default node types used in DefaultHandler cannot be changed using the resource config, which is\na bit cumbersome and leads to useless copies of DefaultIOManager.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1851",
        "summary": "SPI: Helper does not properly retrieve org.apache.jackrabbit.spi.workspacename param.",
        "description": "consequently the Helper always obtains SessionInfo with null workspace name.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2889",
        "summary": "Occasional JCA test failures",
        "description": "As discussed in JCR-2870, the JCA packaging tests are occasionally failing with assertion failures in TransientRepository.startRepository(). We haven't seen this before JCR-2870, but it doesn't look like that change could possibly trigger this failure except perhaps by subtly affecting garbage collection. Thus I'm opening this new issue to track this as a separate problem.\n\nBased on my analysis so far it looks likely that this problem has something to do with the ReferenceMap used by TransientRepository to track open sessions. The fact that the problem occurs only occasionally and on just some systems supports the assumption that this is related to some non-deterministic process like garbage collection.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2987",
        "summary": "New JcrUtils utility methods",
        "description": "I'd like to add the following new utility methods to JcrUtils:\n\n    readFile(Node): returns an InputStream for reading file contents\n    readFile(Node, OutputStream): writes file contents to the given stream\n    getLastModified(Node): returns the jcr:lastModified value\n    setLastModified(Node, Calendar): sets the jcr:lastModified value\n    getPropertyType(String): like PropertyType.valueFromName(String), but case-insensitive\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1144",
        "summary": "Investigate ways to compile the refactored jcr-mapping for Java 1.4",
        "description": "The last refactoring of the jcr-mapping project included the annotation based mapping description into the main code based thus requiring compilation with Java 5 or higher.\n\nThere are still some use cases, which require Java 1.4. The goal is to investigate, whether it would be possible to define a build profile in the pom, which compiles for 1.4 by ignoring the annotation classes.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-584",
        "summary": "Improve handling of concurrent node modifications",
        "description": "consider the following scenario:\n- session1 modifies node /a by adding a child node b\n- session2 modifies node /a by adding a child node c\n- session2 saves its changes \n- session1 tries to save its changes which results in a InvalidItemStateException\n\nthis behavior is in accordance with the spec. the spec however doesn't prevent a \nmore lenient handling of this scenario.\n\nif the concurrent modifications are non-conflicting and trivial the changes could\nbe silently merged in session1's transient state of node /a.\n\nexamples for trivial non-conflicting changes:\n- s1 adds child node a, s2 removes child node b\n- s1 adds child node a, s2 adds child node b\n- s1 adds child node a, s2 adds mixin type\n\nexamples for non-trivial and/or conflicting changes:\n- s1 removes child node a, s2 removes child node a\n- s1 adds child node a, s2 adds child node a\n- s1 adds sns child node a (-> a[3]), s2 adds sns child node a (-> a[3])\n- s1 adds sns child node a (-> a[3]), s2 removes sns child node a[1]\n- s1 removes sns child node a[2], s2 reorders child nodes affecting sns nodes a\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-950",
        "summary": "The move method doesn't remove the source node",
        "description": "Here is a small unit test that demonstrate that the method move doesn't remove the source node. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3126",
        "summary": "The CredentialsWrapper should use a empty String as userId if custom Credentials are used",
        "description": "If custom Credentials are used we get a IllegalArgumentException from the AbstractQValueFactory while executing SessionItemStateManager.computeSystemGeneratedPropertyValues().\nThe 2 Properties jcr:createdBy and jcr:lastModified could not be created.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-846",
        "summary": "support for DB2 in BundleDbPersistenceManager",
        "description": "BundleDbPersistenceManager doesn't work with DB2, db2.ddl file is missing.I've created the database scheme for DB2.",
        "label": "NUG",
        "classified": "TASK",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-59",
        "summary": "NodeType.canSetProperty() does not include type conversion",
        "description": "for example, NodeType.canSetProperty(String propertyName, Value value) must return true if the property requires a StringValue and value is a DateValue (but does not)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-16",
        "summary": "Observation tests fail",
        "description": "Path returned by Event.getPath() is wrong. It always returns the path to the parent node connected to the event. That is, if e.g. a node /foo/bar is created the path /foo is returned instead of /foo/bar.\n\nThis issue had been introduced with changed from api version 0.14 to 0.15.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-920",
        "summary": "rep:excerpt() should also work on properties",
        "description": "Currently the rep:excerpt() function can only be used to create an excerpt with highlight information from a node, the function should also support highlighting of string properties.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1400",
        "summary": "Backport JCR-940: add db connection autoConnect for BundleDbPersistenceManager",
        "description": "Backport issue JCR-940 ( add db connection autoConnect for BundleDbPersistenceManager) to 1.3 branch for 1.3.4 (separate issue to avoid re-opening JCR-940 which was already released with 1.4). ",
        "label": "NUG",
        "classified": "BACKPORT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1003",
        "summary": "Use inheritance rather than delegation for SPI ValueFactoryImpl",
        "description": "The ValueFactoryImpl now has a protected constructor and the SPI variant of the value factory can use it.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1359",
        "summary": "Adding nodes from concurrently running sessions cause exceptions",
        "description": "Exceptions are thrown when trying to add child nodes to one parent node from different sessions running concurrently. One of the following exceptions is always thrown:\n\n * Exception in thread \"Thread-8\" java.lang.RuntimeException: javax.jcr.nodetype.ConstraintViolationException: /A/7 needs to be saved as well.\n * Exception in thread \"Thread-8\" java.lang.RuntimeException: javax.jcr.RepositoryException: /A: unable to update item.: Unable to\nresolve path for item: 016b885a-64aa-45b9-a990-05cbabb4586f/{http://www.jcp.org/jcr/1.0}primaryType: Unable to resolve path for item: 016b885a-64aa-45b9-a990-05cbabb4586f/{http://www.jcp.org/jcr/1.0}primaryType\n\nAccording to JCR-584 \"Improve handling of concurrent node modifications\" the following scenario \"session 1 adds or removes child node 'x', session 2 adds or removes child node 'y'\" should run gracefully, but the following test constantly fails:\n\npublic void testSync() throws Exception\n{\n       Node rootNode = getSession ().getRootNode ();\n       rootNode.addNode (\"A\");\n       rootNode.save();\n\n       final Session session1 = getRepository().login (new SimpleCredentials (\"userName\", \"password\".toCharArray()));\n       final Session session2 = getRepository().login (new SimpleCredentials (\"userName\", \"password\".toCharArray()));\n\n       Thread thread1 = new Thread (new Runnable()\n       {\n               public void run()\n               {\n                       try\n                       {\n                               addNodes (\"A\", session1, 0);\n                       }\n                       catch (RepositoryException ex)\n                       {\n                               throw new RuntimeException (ex);\n                       }\n               }\n       });\n\n       Thread thread2 = new Thread (new Runnable()\n       {\n               public void run()\n               {\n                       try\n                       {\n                               addNodes (\"A\", session2, 1001);\n                       }\n                       catch (RepositoryException ex)\n                       {\n                               throw new RuntimeException (ex);\n                       }\n               }\n       });\n\n       thread1.start();\n       thread2.start();\n\n       thread1.join();\n       thread2.join();\n}\n\nprivate void addNodes (String parentName, Session session, int startIndex)\n       throws RepositoryException\n{\n       Node parentNode = session.getRootNode().getNode (parentName);\n       for (int i = startIndex; i < startIndex + 100; i++)\n       {\n               String name = Integer.toString (i);\n               parentNode.addNode (name);\n               parentNode.save();\n       }\n}\n\nBTW: exceptions were also thrown when I tried to add nodes from one thread and remove some of them from another one. Each thread used it's own session, each node had unique name.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1587",
        "summary": "When trying to reuse version label in transaction, exception is thrown",
        "description": "Following sequence causes failure:\n1. first transaction:\n  1.1 create versionable node\n  1.2 create version 1 of this node\n2. second transaction:\n  2.1 create version 2 of this node\n  2.2 assign a label to version 2\n3. third transaction:\n  3.1 restore a node to version 1\n  3.2 remove version 2\n  3.3 make version 3 of  same node\n  3.4 assign same label (which was assigned to version 2) to version 3 -> fails\n\nSame sequence which does not use transactions at all works fine.\nGoing to attach a test case.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2856",
        "summary": "Upgrade to latest SLF4J and Logback",
        "description": "While fixing JCR-2836 I ran into LBCLASSIC-183 [1] that's fixed in a recent Logback release. To get this and other fixes we should upgrade Logback and SLF4J in Jackrabbit 2.3.\n\n[1] http://jira.qos.ch/browse/LBCLASSIC-183",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1425",
        "summary": "[PATCH] reduce duplicate conversions from OffsetCharSequence to (lower/upper) strings",
        "description": "code repetitively converts OffsetCharSequence to strings, and then repetitively converts to lower/upper case, when generating search terms.\n\nPatch fixes this.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-539",
        "summary": "Concurrent Repository.login() throws IllegalStateException",
        "description": "See test case: org.apache.jackrabbit.test.core.ConcurrentLoginTest\n\njava.lang.IllegalStateException: workspace 'default' not initialized\n\tat org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getItemStateProvider(RepositoryImpl.java:1448)\n\tat org.apache.jackrabbit.core.RepositoryImpl.getWorkspaceStateManager(RepositoryImpl.java:712)\n\tat org.apache.jackrabbit.core.SessionImpl.<init>(SessionImpl.java:247)\n\tat org.apache.jackrabbit.core.SessionImpl.<init>(SessionImpl.java:214)\n\tat org.apache.jackrabbit.core.XASessionImpl.<init>(XASessionImpl.java:98)\n\tat org.apache.jackrabbit.core.RepositoryImpl.createSessionInstance(RepositoryImpl.java:1233)\n\tat org.apache.jackrabbit.core.RepositoryImpl.createSession(RepositoryImpl.java:800)\n\tat org.apache.jackrabbit.core.RepositoryImpl.login(RepositoryImpl.java:1119)\n\tat org.apache.jackrabbit.core.RepositoryImpl.login(RepositoryImpl.java:1146)\n\tat org.apache.jackrabbit.core.jndi.BindableRepository.login(BindableRepository.java:181)\n\tat org.apache.jackrabbit.core.ConcurrentLoginTest$1.run(ConcurrentLoginTest.java:56)\n\tat java.lang.Thread.run(Thread.java:534)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-317",
        "summary": "replace UUID strings by UUID classes in NodeId, etc..",
        "description": "Currently the UUIDs of the nodes are stored as Strings in the ItemIds and ItemStates and cause alot of overhead throughout jackrabbit. they should be replaced by a fast implementation of a UUID class.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3214",
        "summary": "[Lock] weird number for \"infinite\"",
        "description": "(this is a follow-up of JCR-3205)\n\ni am surprised by the davex reply to a lock request with infinite timeout (before and after the fix from JCR-3205):\n\n\n<D:timeout>Second-2147483</D:timeout>\n\nthis number is\n2^21+50331\n\nwhich seems pretty random to me. coincidally, this number is exactly 2^31 - 1 (2147483647) without the last 3 digits. can it be that there are some weird string operations happening on server side?\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-136",
        "summary": "Cached Item could be lost in cache",
        "description": "since items and itemstate are cache in week/soft reference maps, they can disappear from the caches after a GC cycle, and code like this:\n\nif (isCached(id)) {\n  return retrieveItem(id);\n}\n\nhas potential to fail. log entries like:\n\nfailed to build path of c2eeecbe-6126-45a2-a38a-002361095107: 3334d748-2790-4004-8bfa-09463624c7c4 has no child entry for 4897c961-f36f-4d46-87bd-f24f152138a4\n\nare the result.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-152",
        "summary": "FAQ document",
        "description": "Collect the frequently discussed issues from the mailing list and the wiki into an FAQ document.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1494",
        "summary": "[PATCH] XPathQueryBuilder reports misleading column numbers for faulty queries",
        "description": "XPathQueryBuilder returns an error string with the column offset where a parsing error occurred. Unfortunately this value is difficult to correlate to the users query string, as XPathQueryBuilder embellishes the query by doing\n\nstatement = \"for $v in \" + statement + \" return $v\";\n\nThis patch appends the modified statement to the query message so that the user can get the real position of the error.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1783",
        "summary": "JCR2SPI: incomplete changelog when combining move with removal of new destination parent",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2697",
        "summary": "Add support for encrpted db password in repository.xml",
        "description": "Basically this is same to the issue https://issues.apache.org/jira/browse/JCR-2673. I can not reopen JCR-2673, so I filed a new one instead. \n\nThe reason for this jira is because for a lot of companies it is not allowed to store password in a clear text. \n\nSorry, I dont know how this can be implemented yet. But I hope at least the requirement is clear. \n\nThanks.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1169",
        "summary": "Distribution of commons classes",
        "description": "jukka started a discussion regarding distribution of commons classes a while ago:\n\nhttp://www.mail-archive.com/dev@jackrabbit.apache.org/msg06698.html\n\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2329",
        "summary": "Build fails on system without X",
        "description": "The failing test is: testFileContains(org.apache.jackrabbit.core.query.FulltextQueryTest)\n\ncaused by:\n\njava.lang.InternalError: Can't connect to X11 window server using ':0.0' as the value of the DISPLAY variable.\n\tat sun.awt.X11GraphicsEnvironment.initDisplay(Native Method)\n\tat sun.awt.X11GraphicsEnvironment.access$000(X11GraphicsEnvironment.java:53)\n\tat sun.awt.X11GraphicsEnvironment$1.run(X11GraphicsEnvironment.java:142)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.awt.X11GraphicsEnvironment.<clinit>(X11GraphicsEnvironment.java:131)\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:164)\n\tat java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment(GraphicsEnvironment.java:68)\n\tat sun.awt.X11.XToolkit.<clinit>(XToolkit.java:96)\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:164)\n\tat java.awt.Toolkit$2.run(Toolkit.java:821)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.awt.Toolkit.getDefaultToolkit(Toolkit.java:804)\n\tat java.awt.Toolkit.getEventQueue(Toolkit.java:1592)\n\tat java.awt.EventQueue.isDispatchThread(EventQueue.java:666)\n\tat javax.swing.SwingUtilities.isEventDispatchThread(SwingUtilities.java:1270)\n\tat javax.swing.text.StyleContext.reclaim(StyleContext.java:437)\n\tat javax.swing.text.StyleContext.addAttribute(StyleContext.java:294)\n\tat javax.swing.text.StyleContext$NamedStyle.addAttribute(StyleContext.java:1486)\n\tat javax.swing.text.StyleContext$NamedStyle.setName(StyleContext.java:1296)\n\tat javax.swing.text.StyleContext$NamedStyle.<init>(StyleContext.java:1244)\n\tat javax.swing.text.StyleContext.addStyle(StyleContext.java:90)\n\tat javax.swing.text.StyleContext.<init>(StyleContext.java:70)\n\tat javax.swing.text.DefaultStyledDocument.<init>(DefaultStyledDocument.java:88)\n\tat org.apache.tika.parser.rtf.RTFParser.parse(RTFParser.java:42)\n",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-931",
        "summary": "cluster synchronization NPE",
        "description": "we have a 4 machines setup and encountered the following NPE in one of the nodes. After restarting tomcat, the problem seems to go away. But it would be nice to find out why.\n\n\njava.lang.NullPointerException\n        at org.apache.jackrabbit.core.query.lucene.NodeIndexer.createDoc(NodeInd\nexer.java:146)\n        at org.apache.jackrabbit.core.query.lucene.SearchIndex.createDocument(Se\narchIndex.java:566)\n        at org.apache.jackrabbit.core.query.lucene.SearchIndex$2.next(SearchInde\nx.java:368)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.update(MultiIndex.\njava:354)\n        at org.apache.jackrabbit.core.query.lucene.SearchIndex.updateNodes(Searc\nhIndex.java:356)\n        at org.apache.jackrabbit.core.SearchManager.onEvent(SearchManager.java:4\n23)\n        at org.apache.jackrabbit.core.observation.EventConsumer.consumeEvents(Ev\nentConsumer.java:231)\n        at org.apache.jackrabbit.core.observation.ObservationDispatcher.dispatch\nEvents(ObservationDispatcher.java:201)\n        at org.apache.jackrabbit.core.observation.EventStateCollection.dispatch(\nEventStateCollection.java:424)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.externalUpdat\ne(SharedItemStateManager.java:882)\n        at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.externalUpdat\ne(RepositoryImpl.java:1957)\n        at org.apache.jackrabbit.core.cluster.ClusterNode.end(ClusterNode.java:8\n34)\n        at org.apache.jackrabbit.core.cluster.ClusterNode.consume(ClusterNode.ja\nva:929)\n        at org.apache.jackrabbit.core.journal.AbstractJournal.doSync(AbstractJou\nrnal.java:191)\n        at org.apache.jackrabbit.core.journal.AbstractJournal.sync(AbstractJourn\nal.java:166)\n        at org.apache.jackrabbit.core.cluster.ClusterNode.sync(ClusterNode.java:\n283)\n        at org.apache.jackrabbit.core.cluster.ClusterNode.start(ClusterNode.java\n:229)\n        at org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:\n308)\n        at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:\n584)\n        at org.apache.jackrabbit.core.jndi.BindableRepository.createRepository(B\nindableRepository.java:174)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2155",
        "summary": "SQL2 parser: identifiers should be case sensitive",
        "description": "Currently the SQL2 parser converts the query to uppercase before parsing. However the identifiers should be kept case sensitive.\n\nInstead of converting the query to uppercase, String.equalsIgnoreCase should be used to compare against keywords.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2374",
        "summary": "Use FieldSelector in Sorted/LuceneQueryHits when reading UUID",
        "description": "LuceneQueryHits currently reads the complete lucene document. This also prevents usage of an underlying UUID cache.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2041",
        "summary": "Create Jcr-Client Module",
        "description": "task copied from JCR-1877:\n\ni think it would be wise to create a new module that mainly consists of a RepositoryFactory and combines jackrabbit-jcr2spi with the known (and also any other) spi implementations.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1576",
        "summary": "Remove RepositoryService exists()",
        "description": "RepositoryService exists() is not used anywhere. I suggest to remove it. ",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2157",
        "summary": "SQL2 parser: Support CAST",
        "description": "Some CAST(...) data conversions are not yet implemented, for example String to Decimal.",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-3004",
        "summary": "Check if a DAV-Request has a Label in the header, before checking if it's version-controlled",
        "description": "When looking at our MySQL logs, I realized that jackrabbit on each DAV Request calls the VERSION table every time I get a new node (which is not cached yet), even if I only do a simple getNode. \nAs a versioning table can get pretty large, this may have a performance impact.\n\nI found out, that DavResourceFactoryImpl checks, if a node is versioned to decide, if we have to check for the Label header to later check out another version for the GET request. I re-ordered those checks now so that it first checks, if there's an http Label-header and only then checks, if the node is versioned. The check for a Label header should be much faster than checking a DB, if it's versioned (and scale much better, too)\n\n\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-410",
        "summary": "JCR-Server Code depends on Log4J directly",
        "description": "The code is written against the Log4J APIs, which forces all users of Jackarabbit to pick up log4J dependency and to juggle with JDK logging and Log4J configuration if other components of the project uses JDK 1.4 logging.\nIf the code is move to depend on Apache commons-logging this issue will be resolved. Also this should be a minor fix. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-689",
        "summary": "Minimize calls to PersistenceManager",
        "description": "In some situations the PersistenceManager is called even though it is not necessary.\n\nE.g. when new items are created the method NodeImpl.getOrCreateProperty() will always check if there is an already existing property state. If the node is new the call will always go down the full item state stack and ask the PersistenceManager if it knows the property id. This is unnessessary because there will never exist properties in the persistence manager for a new node that has not been saved yet.\n\nI propose to add a check to the method to see if  the node is new and does not yet have a property with the given name. In that case the property can be created without further checks.\n\nWith the patch applied the time to transiently create 1000 nodes with 4 properties each drops from 1485 ms to 422 ms.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1453",
        "summary": "Allow access to journal inside ClusterNode",
        "description": "JCR-757 added support multiple consumers/producers to be attached to the same journal. In order to access this journal, however, o.a.j.core.cluster.ClusterNode has to allow access to the journal it has created.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "BUG"
    },
    {
        "key": "JCR-155",
        "summary": "renaming a node with Session.move() or Workspace.move() is not visible from other concurrent sessions",
        "description": "this is a CachingHierarchyManager issue.\n\nto reproduce:\n\nNode n1 = session1.getRootNode().getNode(\"foo\");\nString path = n1.getPath();   // returns \"/foo\"\n\nNode n2 = session2.getRootNode().getNode(\"foo\");\npath = n2.getPath();   // returns \"/foo\"\n\nsession1.move(\"/foo\", \"/bar\");\nsession1.save();\n\npath = n1.getPath();   // returns \"/bar\"\npath = n2.getPath();   // should return \"/bar\" but still returns \"/foo\"\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2204",
        "summary": "GQLTest fails occasionally",
        "description": "This is again the text extraction, which may hit a time out.",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-592",
        "summary": "Use only the standard Maven repository for dependencies",
        "description": "The JCR API jars are now available in the standard Maven repository, see http://jira.codehaus.org/browse/MAVENUPLOAD-1050. We could thus remove the dependency on the Day repository, as requested in http://jira.codehaus.org/browse/MEV-453.\n",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-230",
        "summary": "persistent locks persist even after removing the locked node",
        "description": "I read my post to the mailing list and I realized it wasn't clear at all :( . So I decided to upload the code to reproduce the error.\n\n        RepositoryConfig conf = RepositoryConfig.create(\"/temp/repository/repository.xml\", \"/temp/repository/repository\");\n        Repository repo = RepositoryImpl.create(conf);\n        \n        // Session 1 creates a locked node\n        Session s1 = repo.login(new SimpleCredentials(\"user1\", \"pwd1\".toCharArray()));\n        Node root1 = s1.getRootNode() ;\n        Node test1 = root1.addNode(\"test\") ;\n        test1.addMixin(\"mix:lockable\");\n        s1.save() ;\n        test1.lock(false, false);\n        s1.logout() ;\n        \n        // Session 2 deletes the node and create a new one\n        // with the same path\n        Session s2 = repo.login(new SimpleCredentials(\"user2\", \"pwd2\".toCharArray()));\n        s2.getRootNode().getNode(\"test\").remove();\n        Node test2 = s2.getRootNode().addNode(\"test\");\n        s2.save() ;\n        // the next line returns true :(\n        System.out.println(test2.isLocked()) ;\n        // the next line will throw an exception \n        test2.addMixin(\"mix:lockable\") ;\n\njavax.jcr.lock.LockException: Node locked.\n\tat org.apache.jackrabbit.core.lock.LockManagerImpl.checkLock(LockManagerImpl.java:449)\n\tat org.apache.jackrabbit.core.lock.LockManagerImpl.checkLock(LockManagerImpl.java:435)\n\tat org.apache.jackrabbit.core.NodeImpl.checkLock(NodeImpl.java:3847)\n\tat org.apache.jackrabbit.core.NodeImpl.addMixin(NodeImpl.java:964)\n\tat org.apache.jackrabbit.core.NodeImpl.addMixin(NodeImpl.java:2420)\n\tat org.apache.jackrabbit.core.LockTest.main(LockTest.java:55)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1915",
        "summary": "Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt",
        "description": "NodeImpl.setPrimaryNodeType changes the primary node type of an node and resets the definition of child items if required. Currently all child items that are not part of the effective node type of the new primary type get their definition reset or are removed in case not matching definition is found.\nFrom my point of view this doesn't properly cope with mixin types present on the node: child items defined by any of the mixin node types present should probably not be touched (or removed).\n\nI run into this while testing the latest 283 security changes and will try to provide a fix along with those changes.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-33",
        "summary": "sysview import does not resolve references",
        "description": "when importing a sysview with references, those are not resolved against the new uuids of the mix:referenceable nodes",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1912",
        "summary": "RMI reference not automatically bound by the standalone server",
        "description": "The RMI servlet in the 1.5.0 standalone server is only initialized (and the remote reference bound to the RMI registry) when the http://.../rmi URL is first accessed. The RMI binding should be made as soon as the standalone server starts.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-121",
        "summary": "JCRTest.java (First Steps example code) creates a StringValue with \"new\"",
        "description": "The JCRTest.java file described in the First Steps document (http://incubator.apache.org/jackrabbit/firststeps.html) on the jackrabbit incubator website contains a line that attempts to create a StringValue using new, rather than using the ValueFactory interface. This causes the code to fail to compile - perhaps an initiative test, but could be off-putting...\n\nSimple fix is to swap the line:\n\n n.setProperty(\"testprop\", new StringValue(\"Hello, World.\"));\n\nto \n\nn.setProperty(\"testprop\", session.getValueFactory().createValue(\"Hello, World.\"));\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2355",
        "summary": "Support easy pre-authenticated login",
        "description": "Some applications authenticate users themselves and just need to access the repository on behalf of these pre-authenticated users.\n\nExamples of such pre-authentications include SSO solutions or web applications using a web-based authentication protocol not easily implementable in a JAAS LoginModule, for example OpenID or similar.\n\nIn such situations a password may not be provided in SimpleCredentials and thus regular login with user name and password is not possible.\n\nTherefore I propose the enhancement of the AbstractLoginModule to allow for setting a specific attribute in the SimpleCredentials attribute map. If this attribute is set, authentication and login succeeds and a session for the user named in the SimpleCredentials is created.\n\nAs a starter we might just check for the presence of the attribute.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-818",
        "summary": "test granularity for calendar (date) properties",
        "description": "There are repositories out there that do support properties of type Date, but not Calendar (the main difference being that Calendar also captures the time zone). Also, some repositories may not be able to store timestamps with millisecond resolution.\n\nAlthough both these restrictions make a repository non-compliant, it would be useful for the tests to test these aspects as separate issues. Thus I propose to simplify the existing tests so that they just compare timestamps (factoring out the time zone), and do not require resolution finer than 1s. These two aspects then should be tested in a separate test case (thinking of it, they currently may not test sub-second resolution, in which case I propose to leave things as they are with respect to this).\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2194",
        "summary": "EventImpl should implement toString",
        "description": "This would simplify logging and debugging.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-328",
        "summary": "TransientRepository with LocalFileSystem eventually causes Repository data to be stored at path '/'",
        "description": "I'm using a TransitoryRepository for my unit testing, with the repository's file system specified as:\n\n    <FileSystem class=\"org.apache.jackrabbit.core.fs.local.LocalFileSystem\">\n        <param name=\"path\" value=\"${rep.home}/repository\"/>\n    </FileSystem>\n\nI noticed today that when I run my unit tests Jackrabbit is creating four directories at the root of my hard drive: \"meta\", \"namespaces\", \"nodetypes\", and \"data\". I tracked the problem the fact that when a LocalFileSystem is closed, it sets the \"root\" to null - an invalid state. But when using a TransitoryRepository, the invalid state is never discovered because the LocalFileSystem object itself is not released, or re-initialized. It is simply used to create BasedFileSystem objects in RepositoryImpl. Calls to BasedFileSystem defer to the LocalFileSystem object that now has a null root. Inside the LocalFileSystem, all the calls to Java's io.File constructor have a \"null\" parent parameter, causing File to fall back to its single argument constructor which sees the path \"/meta\" and happily creates files at the root of the disk.\n\nI'm not sure what the best solution is, but some thoughts I've had are:\n- don't set the \"root\" property to null when closing a LocalFileSystem\n- make RepositoryConfig re-init the FileSystem variable when it is accessed.\n- don't cache the RepositoryConfig in TransitoryRepository (this might also require a new constructor that takes a class-path resource for the repository configuration file)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2010",
        "summary": "Retrieve row path via hierarchy manager instead of node",
        "description": "Jackrabbit currently loads the node associated with a result row to retrieve the path. Loading the node may be prevented by retrieving the path from a caching hierarchy manager.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2125",
        "summary": "serialVersionUID for AuthorizableExistsException",
        "description": "",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3174",
        "summary": "Destination URI should be normalized",
        "description": "WebdavRequestImpl.getHrefLocator tests if the URI passed as parameter starts with the context path, and passes the next segments to the locator factory.\n \nThere is a potential hole if the parameter contains \"..\", because \"http://example.com/dav/../foo\" starts with the context path \"http://example.com/dav\" but represents to \"http://example.com/foo\". Currently, it is up to the locator factory to detect this situation, meaning that every locator factory should implement this check. Additionally, DavLocatorFactory.createResourceLocator cannot throw exceptions, hence it would not fail cleanly (RuntimeException causing a 500 INTERNAL SERVER ERROR response, when a 403 FORBIDDEN status code would have been apropriate)\n\nNote that the Request-URI should have already been normalized by the servlet container, but in COPY/MOVE operations, the Destination-URI is not normalized.\n\nConformant clients MUST NOT use dot-segments (\".\" or \"..\")  [RFC 4918, Section 8.3] in Simple-Ref constructions such as the Destination header [RFC 4918, Section 10.3]), but the server should be able to detect this error.\n\nProposed change in WebdavRequestImpl:193 (in package org.apache.jackrabbit.webdav from webdav/java)\n- ref = uri.getRawPath();\n+ ref = uri.normalize().getRawPath();\n\n(This causes /dav/../foo to be rejected because it doesn't start with the context path, and accepts dav/foo/../bar because it starts with the context path)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1297",
        "summary": "Set svn:eol-style on ddl files",
        "description": "Most of the ddl files in jackrabbit-core/src/main/resources don't have the svn:eol-style property set. It should be set to native.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1486",
        "summary": "Introduce Timer idle time",
        "description": "Currently the Timer stops the internal thread as soon as there are no more tasks scheduled. With a usage pattern that repeatedly schedules tasks and immediately cancels them, one thread per scheduled task is created. There should be some idle time before the background thread is stopped.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-715",
        "summary": "Missing jackrabbit-rmi-service.xml from jackrabbit-jcr-rmi-1.2.1.jar",
        "description": "The file jackrabbit-rmi-service.xml is missing from the jackrabbit-jcr-rmi-1.2.1.jar.\n\nThe cause of the issue appears that the directory structure of the jackrabbit-jcr-rmi sub-project doesn't match the Maven 2 standard.  \n\nTo fix: src/resources should be moved to src/main/resources.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-1379",
        "summary": "AbstractExcerpt uses wrong logger",
        "description": "It uses DefaultXMLExcerpt instead of AbstractExcerpt.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-849",
        "summary": "Bundle persistence name index not case-sensitive in MySQL and MS SQL",
        "description": "As reported by Martijn Hendriks on the dev mailing list (see http://www.nabble.com/Bundle-persistence-managers---db-collation-tf3571522.html), the NAME column of the NAMES table in the bundle persistence manager needs to be case-sensitive.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-340",
        "summary": "Jcr-Server: ValuesProperty missing property type information",
        "description": "JCR specific dav-property ValuesProperty does not reveal the PropertyType of the value, which is therefore lost during (de)serialization. \n\nSolution: \n- Pass type of the JCR-value as attribute to the xml-element containing the value.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3082",
        "summary": "occasional index out of bounds exception while running UserManagerImplTest.testFindAuthorizableByRelativePath",
        "description": "Stack trace:\n\njava.lang.ArrayIndexOutOfBoundsException: 8\n\tat org.apache.jackrabbit.core.query.lucene.MultiScorer.score(MultiScorer.java:89)\n\tat org.apache.lucene.search.ConjunctionScorer.score(ConjunctionScorer.java:133)\n\tat org.apache.lucene.search.BooleanScorer2$2.score(BooleanScorer2.java:182)\n\tat org.apache.lucene.search.BooleanScorer2.score(BooleanScorer2.java:303)\n\tat org.apache.jackrabbit.core.query.lucene.LuceneQueryHits.nextScoreNode(LuceneQueryHits.java:68)\n\tat org.apache.jackrabbit.core.query.lucene.QueryHitsAdapter.nextScoreNodes(QueryHitsAdapter.java:54)\n\tat org.apache.jackrabbit.core.query.lucene.FilterMultiColumnQueryHits.nextScoreNodes(FilterMultiColumnQueryHits.java:63)\n\tat org.apache.jackrabbit.core.query.lucene.QueryResultImpl.collectScoreNodes(QueryResultImpl.java:328)\n\tat org.apache.jackrabbit.core.query.lucene.QueryResultImpl.getResults(QueryResultImpl.java:291)\n\tat org.apache.jackrabbit.core.query.lucene.SingleColumnQueryResult.<init>(SingleColumnQueryResult.java:66)\n\tat org.apache.jackrabbit.core.query.lucene.QueryImpl.execute(QueryImpl.java:134)\n\tat org.apache.jackrabbit.core.query.QueryImpl$1.perform(QueryImpl.java:130)\n\tat org.apache.jackrabbit.core.query.QueryImpl$1.perform(QueryImpl.java:1)\n\tat org.apache.jackrabbit.core.session.SessionState.perform(SessionState.java:200)\n\tat org.apache.jackrabbit.core.query.QueryImpl.execute(QueryImpl.java:126)\n\tat org.apache.jackrabbit.core.security.user.IndexNodeResolver.findNodes(IndexNodeResolver.java:109)\n\tat org.apache.jackrabbit.core.security.user.UserManagerImpl.findAuthorizables(UserManagerImpl.java:498)\n\tat org.apache.jackrabbit.core.security.user.UserManagerImpl.findAuthorizables(UserManagerImpl.java:462)\n\tat org.apache.jackrabbit.core.security.user.UserManagerImplTest.testFindAuthorizableByRelativePath(UserManagerImplTest.java:560)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat org.apache.jackrabbit.test.AbstractJCRTest.run(AbstractJCRTest.java:456)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1630",
        "summary": "Missing third party notices and license info",
        "description": "The components that bundle external libraries (jackrabbit-webapp and jackrabbit-jca) should come with appropriate copyright notices and license information.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-2809",
        "summary": "Lock expires almost immediately",
        "description": "When a timeoutHint other than Long.MAX_VALUE is given to the javax.jcr.lock.LockManager API:\n\n   lock(String absPath, boolean isDeep, boolean isSessionScoped, long timeoutHint, String ownerInfo)\n\na timeoutTime in seconds will be computed as follows (o.a.j.core.lock.LockInfo#updateTimeoutTime):\n\n   long now = (System.currentTimeMillis() + 999) / 1000; // round up\n   this.timeoutTime = now + timeoutHint;\n\nthe TimeoutHandler in o.a.j.core.lock.LockManagerImpl running every second will then check whether the timeout has expired (o.a.j.core.lock.LockInfo#isExpired):\n\n    public boolean isExpired() {\n        return timeoutTime != Long.MAX_VALUE\n            && timeoutTime * 1000 > System.currentTimeMillis();\n    }\n\nObviously, the latter condition is true from the very beginning. Replacing '>' with '<' or '<=' should do the trick.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2681",
        "summary": "XMLPersistanceManager doesn't preserve a property's 'multiValued' attribute",
        "description": "when a multi-valued property is persisted and later read using the XMLPersistenceManager the 'multiValued' attribute is lost, i.e. PropertyState.isMultiValued() returns always false.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1803",
        "summary": "Node.restore() throws java.lang.ClassCastException",
        "description": "I'm trying to upgrade to 1.5 using existing 1.3.x repository. Restore of versionable node throws ClassCastException.\n\nCaused by: java.lang.ClassCastException: org.apache.jackrabbit.uuid.UUID\n\tat org.apache.jackrabbit.core.value.InternalValue.getString(InternalValue.java:436)\n\tat org.apache.jackrabbit.core.version.InternalFrozenNodeImpl.<init>(InternalFrozenNodeImpl.java:113)\n\tat org.apache.jackrabbit.core.version.AbstractVersionManager.createInternalVersionItem(AbstractVersionManager.java:576)\n\tat org.apache.jackrabbit.core.version.VersionManagerImpl.getItem(VersionManagerImpl.java:258)\n\tat org.apache.jackrabbit.core.version.InternalVersionImpl.getFrozenNode(InternalVersionImpl.java:111)\n\tat org.apache.jackrabbit.core.version.VersionImpl.getFrozenNode(VersionImpl.java:120)\n\tat org.apache.jackrabbit.core.NodeImpl.internalRestore(NodeImpl.java:4180)\n\tat org.apache.jackrabbit.core.NodeImpl.internalRestore(NodeImpl.java:4141)\n\tat org.apache.jackrabbit.core.NodeImpl.restore(NodeImpl.java:3429)\n\nIt seems that bug has been introduced already in 1.4 as part of JCR-926 (InternalValue cleanup).\n\nIndex: C:/data/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/version/InternalFrozenNodeImpl.java\n===================================================================\n--- C:/data/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/version/InternalFrozenNodeImpl.java\t(revision 549117)\n+++ C:/data/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/version/InternalFrozenNodeImpl.java\t(working copy)\n@@ -109,10 +109,10 @@\n             PropertyState prop = props[i];\n             if (prop.getName().equals(QName.JCR_FROZENUUID)) {\n                 // special property\n-                frozenUUID = UUID.fromString(node.getPropertyValue(QName.JCR_FROZENUUID).internalValue().toString());\n+                frozenUUID = UUID.fromString(node.getPropertyValue(QName.JCR_FROZENUUID).getString());\n\nProbably one of the assumptions made was wrong :\n- The type of QName.JCR_FROZENUUID is STRING (Object.toString() was used before).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-205",
        "summary": "Version.merge() corrupts repository",
        "description": "Version.merge() corrupts repository. somehow the 'protected' flags of the nt:version nodetype is not properly checked.\nthis happens due to a wrong test case that calls merge on a Version instead of a normal Node.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2999",
        "summary": "Access control evaluation does not properly cope with XA transactions",
        "description": "the following test fails with ItemNotFoundException at the indicated position due to the fact that\nthe parent n2 is EXISTING but still not visible to the system session responsible for the ac\nevaluation.\n\npublic void testTransaction() throws Exception {\n\n        // make sure testUser has all privileges\n        Privilege[] privileges = privilegesFromName(Privilege.JCR_ALL);\n        givePrivileges(path, privileges, getRestrictions(superuser, path));\n\n        // create new node and lock it\n        Session s = getTestSession();\n        UserTransaction utx = new UserTransactionImpl(s);\n        utx.begin();\n\n        // add node and save it\n        Node n = s.getNode(childNPath);\n        if (n.hasNode(nodeName1)) {\n            Node c = n.getNode(nodeName1);\n            c.remove();\n            s.save();\n        }\n\n        Node n2 = n.addNode(nodeName1);\n        s.save();\n            \n        Node n3 = n2.addNode(nodeName2);\n        s.save(); // exception\n\n        // commit\n        utx.commit();\n    }\n\nA possible workaround would be to make sure that ItemSaveOperation.persistTransientItems \nretrieves the parent without having the checkPermission enabled since we can assume that\nthe new item could not be added if the parent was not readable in the first place.... but careful\nevaluation would be required.\n\nNOTE: this is just one example of the AC-evaluation not properly dealing with XA transactions.\nI am convinced that other examples could be find....\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1611",
        "summary": "Registering NodeType from templates throws exception about invalid decl. node type.",
        "description": "when adding PropertyDefinitionTemplates to NodeTypeTemplates, the internal declaredNodeType field is not set and causes the registration fail with:\n\norg.apache.jackrabbit.api.jsr283.nodetype.InvalidNodeTypeDefinitionException: [{}foo#{}test] invalid declaring node type specified\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl.registerNodeTypes(NodeTypeManagerImpl.java:695)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl.registerNodeType(NodeTypeManagerImpl.java:615)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2689",
        "summary": "Improve equals for binary values",
        "description": "The current implementation of spi2dav's equals method for binary values is not symmetric. Moreover it forces the values to be loaded instead of trying to determine equality by examining etag and last-modified headers. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3227",
        "summary": "VolatileIndex not closed properly",
        "description": "The MultiIndex.resetVolatileIndex() method doesn't properly close the existing VolatileIndex instance before creating a new one. This can confuse the DynamicPooledExecutor reference count added in JCR-2836, leading to a background thread leak.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2944",
        "summary": "Remove unnecessary NodeImpl references from LuceneQueryFactory",
        "description": "LuceneQueryFactory casts to NodeImpl just to get the node id. \nThis info is available via the api as well, so the cast seems unnecessary.\nI'll attach a patch for this tiny issue.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-293",
        "summary": "Property.setValue(InputStream) closes stream",
        "description": "Currently the Property.setValue(InputStream) - actually all methods setting a property value from an InputStream - method closes the stream when it has completely been read. While this might be a nice-to-have in some situations, it is IMHO not standard behaviour for stream consumers to close the stream when done.\n\nMy special use case is unpacking the contents of a ZIP file (ZIPInputStream). After streaming the contents of the first ZIP file entry into a property, the ZIPInputStream is closed by Jackrabbit and the rest of the file cannot be read.\n\nWorkaround: Instead of giving the original InputStream to the method, create a FileInputStream wrapper overwriting the close method to do nothing.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2471",
        "summary": "Update LICENSE and NOTICE files to match the updated dependencies",
        "description": "We've made quite a few dependency updates since Jackrabbit 1.6 and need to update the license metadata accordingly.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-470",
        "summary": "XMLIndexFilter should index the attributes",
        "description": "text/xml indexer extracts the elements text but not the attribute values.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3118",
        "summary": "Configurable actions upon authorizable creation and removal",
        "description": "i would like to add the possibility to configure custom actions that are executed upon user (and group) creation before \nthe operation is persisted. this would allow applications to run custom code without the need of subclassing the\nusermanager implementation. e.g.: creating additional mandatory properties, setting up permissions, calculating default \ngroup membership. the same applies for user/group removal.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2402",
        "summary": "Observation: avoid running out of memory",
        "description": "Jackrabbit uses an unbounded observation queue for event listeners (for asynchronous listeners, which are the default). If an observation listener is very slow, the observation queue gets larger and larger, and the JVM will eventually run out of memory.\n\nI suggest to use a maximum queue size of 100'000 by default. Adding new events to the queue will block until the observation listeners removed an item. I'm not sure if we need a way to configure this option; probably a system property is enough as a start (we can still add a better way to configure this setting if it turns out somebody actually needs a different value).\n\nA special case is observation listeners that themselves write to the repository and therefore cause new events. In this case, it doesn't make sense to block adding an event, because that would block the whole system. However a warning should be written to the log file.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-381",
        "summary": "Repository does not start if text filter dependencies are missing",
        "description": "When the search index is configured with a text filter class that requries another jar file and that jar file is missing the repository will not start and log the following misleading error:\n\nCaused by: javax.jcr.RepositoryException\n    at org.apache.jackrabbit.core.SearchManager.initializeQueryHandler(SearchManager.java:536)\n    at org.apache.jackrabbit.core.SearchManager.<init>(SearchManager.java:278)\n    at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getSearchManager(RepositoryImpl.java:1430)\n    at org.apache.jackrabbit.core.RepositoryImpl.initWorkspace(RepositoryImpl.java:538)\n    at org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:245)\n    at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:482)\n    at org.jbpm.jcr.impl.JackrabbitJcrService.start(JackrabbitJcrService.java:119)\n    ... 63 more\nCaused by: java.lang.IllegalArgumentException\n    at org.apache.commons.collections.BeanMap.put(BeanMap.java:374)\n    at org.apache.jackrabbit.core.config.BeanConfig.newInstance(BeanConfig.java:97)\n    at org.apache.jackrabbit.core.SearchManager.initializeQueryHandler(SearchManager.java:530)\n    ... 69 more ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1892",
        "summary": "Unique ID for org.apache.jackrabbit.value.BinaryValue",
        "description": "BinaryValue should have a method get the unique identifier (if one is available). That way an application may not have to read the stream if that value is already processed.\n\nWhen the DataStore is used, a unique identifier is available, so probably this feature is quite simple to implement.\n\nSee also http://www.nabble.com/Workspace.copy()-Question-...-td20435164.html (but please don't reply to this thread from now on - instead add comments to this issue).\n\nAnother feature is getFileName() to get the file name if it is stored in the file system. This method may need a security mechanism, for example getFileName(Session s) so that the system can check it. In any case the file should not be modified, but maybe knowing the file name is already too dangerous in some cases.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2837",
        "summary": "Test failures in jcr-rmi and jcr2dav",
        "description": "Integration testing currently fails for jcr-rmi:\n  testCloneNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceCloneTest)\n  testCopyNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceCopyBetweenWorkspacesTest)\n  testCopyNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceCopyTest)\n  testMoveNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceMoveTest)\n  testImpersonate(org.apache.jackrabbit.test.api.ImpersonateTest)\n  testCheckPermission(org.apache.jackrabbit.test.api.CheckPermissionTest)\n  testRemoveItem4(org.apache.jackrabbit.test.api.SessionRemoveItemTest)\n  testReadOnlyPermission(org.apache.jackrabbit.test.api.HasPermissionTest)\n  testGetPrivileges(org.apache.jackrabbit.test.api.security.RSessionAccessControlDiscoveryTest)\n  testNotHasPrivileges(org.apache.jackrabbit.test.api.security.RSessionAccessControlDiscoveryTest)\n  testGetApplicablePolicies(org.apache.jackrabbit.test.api.security.RSessionAccessControlPolicyTest)\n  testGetPolicy(org.apache.jackrabbit.test.api.security.RSessionAccessControlPolicyTest)\n  testGetEffectivePolicy(org.apache.jackrabbit.test.api.security.RSessionAccessControlPolicyTest)\n  testMoveNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testSetProperty(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testSetValue(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testDeleteNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testDeleteProperty(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testWorkspaceMoveNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testCopyNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n\nand jcr2dav:\n  testCloneNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceCloneTest)\n  testCopyNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceCopyBetweenWorkspacesTest)\n  testCopyNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceCopyTest)\n  testMoveNodesAccessDenied(org.apache.jackrabbit.test.api.WorkspaceMoveTest)\n  testCheckPermission(org.apache.jackrabbit.test.api.CheckPermissionTest)\n  testRemoveItem4(org.apache.jackrabbit.test.api.SessionRemoveItemTest)\n  testReadOnlyPermission(org.apache.jackrabbit.test.api.HasPermissionTest)\n  testMoveNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testSetProperty(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testSetValue(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testDeleteNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testDeleteProperty(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testWorkspaceMoveNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n  testCopyNode(org.apache.jackrabbit.test.api.security.RSessionAccessControlTest)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1624",
        "summary": "Proxies improvement",
        "description": "1) Improvement :\nI need to be able to detect when a bean is an OCM proxy and if it has already been loaded. This kind of functionnality is for example on Hibernate with Hibernate.isInitialized(Object proxy).\nI have developped something similar : I have modified ProxyManagerImpl so it uses an InvocationHandler instead of a LazyLoader. This way, I make my proxies implement a special interface whose methods are intercepted.\n\n2) Bug :\nIf a BeanConverter is specified, ObjectConverterImpl should pass it to the proxy CallBack instead letting BeanLazyLoader use the default ObjectConverter. I think this is a bug, as the behavior is different is bean property is proxified or not.\n\n3) Improvement :\nIf a jcrType mapped on a java type is specified, ObjectConverterImpl should make a proxy of this type, and not use the the bean property type. This is particularly useful when the bean property type is an interface.\n\nSorry for reporting this as a bundle instead of seperate items, but I developped my patch as a whole.  \nLet me know if you need help on the enclosing patch.\n\nSincerely,\n\nSt\u00e9phane Landelle",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1434",
        "summary": "SPI: Description of Path.isDescendantOf(Path) ",
        "description": "Description of Path.isDescendantOf lists different reasons for IllegalArgumentException and RepositoryException than isAncestorOf... this is obviously a mistake.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-179",
        "summary": "PROPPATCH in simple webdav server failing with 403 Forbidden error",
        "description": "\ni've configured the import-collection chain (called via MKCOL) to add nodes with the node type \"dav:collection\", which is defined as such:\n\nNodeTypeName\n  dav:collection\nSuperTypes\n  nt:folder\nIsMixin\n  false\nHasOrderableChildNodes\n  false\nPrimaryItemName\n  null\nPropertyDef\n  Name *\n  RequiredType UNDEFINED\n  DefaultValues null\n  AutoCreate false\n  Mandatory false\n  OnParentVersion COPY\n  Protected false\n  Multiple false\nPropertyDef\n  Name *\n  RequiredType UNDEFINED\n  DefaultValues null\n  AutoCreate false\n  Mandatory false\n  OnParentVersion COPY\n  Protected false\n  Multiple true\n\nthe idea is that i should be able to set arbitrary webdav properties (single- or multi-value) on a webdav collection.\n\nwhen i use cadaver to mkcol a collection (creating a jcr node of type dav:collection) and then try to propset an arbitrary property on that collection (which as i understand it would set a jcr property of the same name on the dav:collection node), i get a 403 Forbidden error:\n\ndav:/home/> mkcol hi\nCreating `hi': succeeded.\n\ndav:/home/> propset hi hi hi\nSetting property on `hi': failed:\n403 Forbidden\n\nit's not clear to me if i'm using cadaver incorrectly, misunderstanding the PROPPATCH implementation, or both :) ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-697",
        "summary": ".war distribution should be configurable, prompting you to setup JNDI with the Repository Home and Config locations.",
        "description": "The Embedded Deployment Model documentation (http://jackrabbit.apache.org/doc/deploy/howto-model1.html) on the jackrabbit page describes how to package up a .war file so that you can use JNDI Resource settings to change the location of the repository home and the repository configuration xml file.\n\nUnfortunately, the .war file that is provided as part of the Jackrabbit distribution doesn't behave like this. Instead, it has an inbuilt repository.xml file and settings in web.xml that act as defaults. These defaults are not useful and force a user to act like a developer and modify the files within the .war file.\n\nThe current situation is that we have a .war that's not going to be useful to anyone without modification. The repository.xml file that is contained within the .war makes the repository home to be the Tomcat/bin/repository directory. This is not a useful default. It's better to have no default setup and a clear error message that JNDI needs to be setup. It would be even better if the web application could recognise when the JNDI wasn't configured and could prompt the user with an instructional webpage, describing how to setup the required JNDI settings on Tomcat, JBoss etc.\n\n----\n\nThe .war distribution for Jackrabbit ignores the JNDI settings that are described in the documentation. I am using this Tomcat config.xml snippet to configure Tomcat 5.5:\n\n{{{\n<?xml version='1.0' encoding='utf-8'?>\n<Context displayName=\"Ark\" docBase=\"c:\\dev\\ark\\jackrabbit-server-1.1.1.war\" path=\"/ark\" \n         useNaming=\"false\" workDir=\"work\\Catalina\\localhost\\ark\" unpackWAR=\"false\">\n\n<Resource name=\"jcr/repository\"\n          auth=\"Container\"\n          type=\"javax.jcr.Repository\"\n          factory=\"org.apache.jackrabbit.core.jndi.BindableRepositoryFactory\"\n          configFilePath=\"c:/dev/ark/src/main/resources/repository.xml\"\n          repHomeDir=\"c:/jackrabbitrepo\"/>\n\n</Context>\n}}}\n\nJackrabbit loads fine. However, the logs show:\n\n{{{\n02.01.2007 10:33:00 *INFO * RepositoryStartupServlet: RepositoryStartupServlet initializing... (RepositoryStartupServlet.java, line 190)\n02.01.2007 10:33:00 *INFO * RepositoryStartupServlet:   repository-home = C:\\Program Files\\Apache Software Foundation\\Tomcat 5.5\\bin\\jackrabbit\\repository (RepositoryStartupServlet.java, line 242)\n\n...\n...\n\n02.01.2007 10:33:00 *INFO * LocalFileSystem: LocalFileSystem initialized at path C:\\Program Files\\Apache Software Foundation\\Tomcat 5.5\\bin\\jackrabbit\\repository\\repository (LocalFileSystem.java, line 166)\n}}}\n\n\n\n\n\n\n----\n\nMy use case is that I want to use Jackrabbit to host a Maven 2 repository within my company. So, ideally I want to:\n   * Download the Jackrabbit .war file and mount it on my Tomcat server as context \"/maven2\".\n   * Configure Tomcat to use LDAP authentication and point it at my company's LDAP server. This is a standard J2EE feature, of course.\n   * Create my own repository.xml file which points to my AccessManager implementation (which goes to my company's SingleSignOn service for authorization). My AccessManager implementation will be placed on the Tomcat shared classpath.\n   * Set the repository home directory, where all the working files will be placed and the location of the repository.xml file. Ideally, this would be done in JNDI.\n\nIf I have to put together my own Jackrabbit .war file, I consider that I have my \"developer\" hat on when I only really want to have my \"Jackrabbit user\" hat on.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2468",
        "summary": "Indexing configuration not refreshed after node type registration",
        "description": "The indexing configuration has internal caches that speed up node type matches. Those caches are not updated on new node type registration and newly registered node types are not properly resolved when index-rules are checked.\n\nSee also test case in attached patch.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3222",
        "summary": "Allow servlet filters to specify custom session providers",
        "description": "In order to integrate the Jackrabbit davex server functionality with their custom authentication logic, the Sling project currently needs to embed and subclass the davex servlet classes. It would be cleaner if such tight coupling wasn't needed.\n\nOne way to achieve something like that would be to allow external components to provide a custom SessionProvider instance as an extra request attribute. This way for example a servlet filter that implements such custom authentication logic could easily make its functionality available to the standard davex servlet in Jackrabbit.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2397",
        "summary": "AccessControlEntries should be orderable",
        "description": "the entries of an AccessControlList should be orderable if the order of the ac-entries matters for the access control evaluation.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1259",
        "summary": "Utility code for filtering and packaging trees",
        "description": "The attached zip contains new utility code for filtering and packaging trees in the repository.\n\nA tree can be traversed by the provided tree walker. During the traversal configurable filters can be applied. The filters have influence on the traversal, like skipping nodes or properties.\nIncluded filters test the node name, node type etc. Custom filters are possible as well.\nA tree walker notifies a tree walker listener (interface) whenever it traverses an item.\n\nThe second utility code is able to package a whole tree (through a description) and export this in some way - the exporter is an interface and could e.g. be an exporter serializing the tree into a zip archiv etc.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2498",
        "summary": "Implement caching mechanism for ItemInfo batches",
        "description": "Currently all ItemInfos returned by RepositoryService#getItemInfos are placed into the hierarchy right away. For big batch sizes this is prohibitively expensive. The overhead is so great (*), that it quickly outweighs the overhead of network round trips. Moreover, SPI implementations usually choose the batch in a way determined by the backing persistence store and not by the requirements of the consuming application on the JCR side. That is, many of the items in the batch might never be actually needed. \n\nI suggest to implement a cache for ItemInfo batches. Conceptually such a cache would live inside jcr2spi right above the SPI API. The actual implementation would be provided by SPI implementations. This approach allows for fine tuning cache/batch sizes to a given persistence store and network environment. This would also better separate different concerns: the purpose of the existing item cache is to optimize for the requirement of the consumer of the JCR API ('the application'). The new ItemInfo cache is to optimize for the specific network environment and backing persistence store. \n\n(*) Numbers follow ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1505",
        "summary": "Improve handling of inherited mixins",
        "description": "If an abstract class is annotated with a mixin type, the annotation must be repeated in concrete classes.\n\nE.g.\n@Node(jcrMixinTypes=\"mix:referenceable\", isAbstract=true)\npublic abstract class Content {\n...\n...}\n\n/**\n* This class will not be referenceable\n**/\n@Node(extend=Content.class)\npublic class Page extends Content {\n...\n...\n}\n\n/**\n* But this one will\n**/\n@Node(extend=Content.class, jcrMixinTypes=\"mix:referenceable\")\npublic class Folder extends Content {\n...\n...\n}\n\nIt would be nice if the annotation was inherited by default.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-183",
        "summary": "DavMethods.POST should be public, not private",
        "description": "DavMethods.POST is declared as a private constant, when it should be public. attached is a patch to fix this.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "BUG"
    },
    {
        "key": "JCR-633",
        "summary": "DerbyPersistenceManager only usable for embedded databases",
        "description": "DerbyPersistenceManager always shuts down the database on exit, which makes it unusable for standalone databases.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1865",
        "summary": "Add the Data Store to the Jackrabbit API",
        "description": "Currently, the garbage collection is not part of the Jackrabbit API. However, the data store garbage collection must be used once in a while if the data store is enabled. I propose to add the required interfaces to the Jackrabbit API. This will also allow to call garbage collection using RMI.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1805",
        "summary": "Trim whitespace from parameter names in configuration files",
        "description": "We've had a couple of issues with extra whitespace in parameter names causing those configuration options being lost. Now with the more strict validation of configuration settings such mistakes can even prevent the repository from starting. On one hand that's a good thing, as the user would then explicitly need to fix such broken configurations, but it would be nice if no user intervention was needed.\n\nSince leading and trailing whitespace is never allowed in parameter names, we can just as well trim it automatically.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-428",
        "summary": "BLOBFileValue() might be discarded to early",
        "description": "Situation:\n\nif the internal value of a property of type binary is created by the constructor BLOBFileValue(InputStream in) and the content is not stored in an temp-file, then calling the methods \n\na) #setProperty(InputStream in) on this node and then\nb) #refresh(false) on the node of this property \n\non the node of this property leads to an internal value of this property with an erased byte[].\n\nSolution:\n\nOnly if the spoolFile is created the field 'temp' should be set to true.\nIf the InputStream is stored in the byte[] the field 'temp' should be set to false.\n\nPatch:\n\nIndex: BLOBFileValue.java\n===================================================================\nretrieving revision 1.1\ndiff -u -r1.1 BLOBFileValue.java\n--- BLOBFileValue.java\t8 May 2006 13:57:49 -0000\t1.1\n+++ BLOBFileValue.java\t8 May 2006 15:19:54 -0000\n@@ -142,6 +142,7 @@\n                     len += read;\n                 }\n             }\n+            in.close();\n         } finally {\n             if (out != null) {\n                 out.close();\n@@ -151,8 +152,15 @@\n         // init vars\n         file = spoolFile;\n         fsResource = null;\n-        // this instance is backed by a temporarily allocated resource/buffer\n-        temp = true;\n+        if (file != null)\n+        {\n+            // this instance is backed by a temporarily allocated resource\n+            temp = true;\n+        }\n+        else\n+        {\n+            temp = true;\n+        }\n     }\n \n     /**\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1853",
        "summary": "Modified QueryImpl to enable external query builders to read and write JCR expressions in the orderBy Clause",
        "description": "The QueryImpl does not create the JCR expression on the fly. The OrderByExpression does the job. If an external querybuilder class needs to dynamically collect properties against which order by is required, QueryImpl does not support updating the JCR Expression. It can only return the built expression since arrayList is used for collecting the properties. The change enables one to add JCRExpression to the QueryImpl object. A test has been added.\n\nChanged files:\nPath\nsrc/main/java/org/apache/jackrabbit/ocm/query/impl/QueryImpl.java\nsrc/test/java/org/apache/jackrabbit/ocm/manager/query/DigesterSimpleQueryTest.java\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2872",
        "summary": "DataStore: changing the modified date fails if the file is open for reading (Windows only)",
        "description": "If the file is open for reading, Windows doesn't allow to change the last modified time using File.setLastModified():\n\norg.apache.jackrabbit.core.data.DataStoreException: Failed to update record\nmodified date: 2ac72495fd1e270777821b8a872903c79c84a8d9\n        at org.apache.jackrabbit.core.data.FileDataStore.addRecord(FileDataStore.java:250)\n        at org.apache.jackrabbit.core.value.BLOBInDataStore.getInstance(BLOBInDataStore.java:119)\n        at org.apache.jackrabbit.core.value.InternalValue.getBLOBFileValue(InternalValue.java:619)\n        at org.apache.jackrabbit.core.value.InternalValue.create(InternalValue.java:369)\n        at org.apache.jackrabbit.core.value.InternalValueFactory.create(InternalValueFactory.java:94)\n        at org.apache.jackrabbit.core.value.ValueFactoryImpl.createBinary(ValueFactoryImpl.java:74)\n\nTest case and possible workaround:\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.RandomAccessFile;\npublic class Test {\n    public static void main(String... args) throws Exception {\n        String name = \"test.txt\";\n        File test = new File(name);\n        RandomAccessFile r = new RandomAccessFile(name, \"rw\");\n        r.write(0);\n        r.close();\n        long mod = test.lastModified();\n        Thread.sleep(3000);\n        FileInputStream in = new FileInputStream(name);\n        if (!test.setLastModified(test.lastModified()+1)) {\n        \tif (!test.canWrite()) {\n        \t\tSystem.out.println(\"Can't write to \" + name);\n        \t} else {\n            \tSystem.out.println(\"canWrite ok\");\n            \tr = new RandomAccessFile(name, \"rw\");\n            \tint old = r.read();\n            \tr.seek(0);\n            \tr.write(old);\n            \tr.close();\n        \t}\n        } else {\n        \tSystem.out.println(\"setLastModified ok\");\n        }\n        System.out.println(\"Modified old: \" + mod);\n        System.out.println(\"Modified now: \" + test.lastModified());\n        in.close();\n        System.out.println(\"input closed\");\n        if (!test.setLastModified(test.lastModified()+1)) {\n        \tif (!test.canWrite()) {\n        \t\tSystem.out.println(\"Can't write to \" + name);\n        \t} else {\n            \tSystem.out.println(\"canWrite ok\");\n        \t}\n        } else {\n        \tSystem.out.println(\"setLastModified ok\");\n        }\n        new File(name).delete();\n    }\n}\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1395",
        "summary": "Use Commons IO 1.4",
        "description": "Commons IO contains a number of utility classes and methods for working with files and streams. Many of those utilities would be quite useful in Jackrabbit, so I'd like to introduce commons-io 1.4 as a dependency to jackrabbit-core.\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1011",
        "summary": "JCR2SPI: add configurable cache for Item instances (ItemManager)",
        "description": "Currently the ItemManager implementation uses a simple map with weak keys (ItemState) and weak values (Item) as cache.\nMarcel recently suggested to replace this with a more sophisticated cache mechanism that can be configured.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2981",
        "summary": "Bundle of events may be dropped due to NP.",
        "description": "In [1], if the resolver fails to lookup a node entry, a NP is thrown. This exception will break the loop which forwards the events to the observer in [2].\nThis will result in an observer not receiving events that he should have.\n\n[1] org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyManagerImpl#lookup(ItemId workspaceItemId)\n[2] org.apache.jackrabbit.jcr2spi.WorkspaceManager#onEventReceived(EventBundle[] eventBundles,InternalEventListener[] lstnrs)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3192",
        "summary": "Javadoc in jackrabbit-jcr-rmi is missing an ending \">\" ",
        "description": "The javadoc file /jackrabbit-jcr-rmi/src/main/javadoc/apache/rmi/observation/package.html is missing the final \">\" from the ending body tag.\n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-2519",
        "summary": "spi2davex: use srcWorkspaceName to build srcPath for clone and copy",
        "description": "spi2davex provides as simple workaround for the missing clone and cross-workspace-copy in spi2dav.\nhowever, the src workspace name isn't used to build the src path.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1177",
        "summary": "Move jackrabbit/trunk/contrib to jackrabbit/sandbox",
        "description": "As discussed on the mailing list (see http://www.nabble.com/Moving-contrib-outside-trunk-and-rename-to-sandbox-tf4635301.html), we should do the following:\n\n    svn move https://svn.apache.org/repos/asf/jackrabbit/trunk/contrib https://svn.apache.org/repos/asf/jackrabbit/sandbox\n\nI will do this in a few days unless anyone objects.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2553",
        "summary": "spi2davex: Batch fails to create/modify properties with non-ascii characters names",
        "description": "the spi2davex batch implementation fails upon creation/modification of all property types that have their value sent as\nseparate stringpart or binarypart AND contain non-ascii characters in their property name.\n\nfrom what i've seen this is due to a limitation in HttpClient 3.x Part#sendDispositionHeader that always writes the part name\nas ascii-bytes. in a related discussion [1] specification compliance and usability were addressed.\n\nlooking at the server-side part revealed that org.apache.commons.fileupload.FileUploadBase#FileItemIteratorImpl\nis prepared to receive non-ascii characters in a header value.\na simple test also showed that curl is perfectly able to send utf-8 part names.\n\nbased on this information and given the fact that spi2dav and the server-sided part are intended to communicate\nwith one other rather than with any kind of custom clients, i suggest to add a simple fix by patching the parts used\nwithin spi2davex.\n\nbtw: in HttpClient 4.x there seems to be a workaround for this problem [2]\n\n[1] http://www.mail-archive.com/httpclient-dev@jakarta.apache.org/msg04637.html\n[2] https://issues.apache.org/jira/browse/HTTPCLIENT-293",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2562",
        "summary": "spi2davex: uri-lookup not cleared after reordering referenceable same-name-siblings",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-629",
        "summary": "CompactNodeTypeDefWriter does not escaped names properly",
        "description": "CompactNodeTypeDefWriter does not escaped names properly. If the name includes a '-' or a '+' the names must be surrounded by single quotes.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1081",
        "summary": "bad test assumptions in org.apache.jackrabbit.test.api.lock",
        "description": "These tests make a lot of assumptions that may not be true for a compliant repository, such as:\n\n- ability to add nodes without specifiying the node type\n- assumption that ordering and same name siblings are supported\n- assumption that addMixin(lockable) is required on newly added nodes\n\nFurthermore, some repositories may not support shallow locks on leaf nodes. That's not compliant, but failure to do so should not abort a test that tests something else.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2814",
        "summary": "Login performance drop when using DefaultAccessManager",
        "description": "JCR-2700 caused a drop in login performance when using DefaultAccessManager. The drop is caused by the initialization of the LRU map used in CompiledPermissionsImpl. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2166",
        "summary": "Provide query support  for WEAKREFERENCE reverse lookup",
        "description": "the current implementation of Node.getWeakReferences() and getWeakReferences(String) uses a fulltext query in order to find weak references to a particular node.\n\nthis requires the PlainTextExtractor to be enabled in the Search config, e.g. :\n\n    <param name=\"textFilterClasses\" value=\"org.apache.jackrabbit.extractor.PlainTextExtractor\"/>\n\nproviding 'native' WEAKREFERNCE reverse lookup in Jackrabbit's QOM implementation would be certainly more efficient.\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1156",
        "summary": "DatabaseJournal refactoring for subclassing capability",
        "description": "In the 1.3 upgrade to JackRabbit, the DatabasePersistenceManager class was refactored to allow easy subclassing.  On my project, the subclassing is required because the DBAs have a specific naming convention for database columns, and the default JackRabbit columns don't fit within the naming convention.\n\nAt this point, we're cutting over to a clustered setup in preparation for production.  In my design, I would like to use the database for journaling.  But once again, the DBAs will want to change the column names to their own naming convention.  The existing DatabaseJournal class is not set up for the same type of subclassing that the PersistenceManager (or even the FileSystem) hierarchies.  I'd like the DatabaseJournal class to be updated accordingly.\n\nIn specific, here are the changes I'm looking for:\n\n* Extract protected instance variables for selectRevisionsStmtSql, updateGlobalStmtSql, selectGlobalStmtSql, and insertRevisionStmtSql.\n* Extract method protected void buildSQLStatements() which sets up the above sqls, and allows subclasses to override.\n* Update the existing prepareStatements method to use the above instance variables.\n* Update the init method to call the buildSQLStatements method before the call to prepareStatements.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2758",
        "summary": "Session.save() potentially causes endless loop when READ permission is denied on root node",
        "description": "if the current session doesn't have read permission on the root node, calling Session.save() triggers a call to SessionItemStateManager.getIdOfRootTransientNodeState()\nin order to find the root of the minimal subtree including all transient states. this might cause an endless loop, depending on the transient changes.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-966",
        "summary": "[OCM] Add unit tests with BundleDbPersistenceManager",
        "description": "Until now, we have not yet check the ocm framework with the BundleDbPersistenceManager",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-901",
        "summary": "Support synonym searches",
        "description": "Jackrabbit should support synonym searches in the jcr:contains function like Google does.\n\nExample:\n\n//element(*, nt:resource)[jcr:contains(., '~food')]\n\n-> finds all nt:resource nodes that contain the word food or synonyms for food.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-32",
        "summary": "sysview export/import of multivalue properties seems not to work",
        "description": "the sysview export of multivalue properties does not differ from the export of singlevalue properties.\n\nif a mv-property contains only 1 value, how can the import find the correct property-def?\n\ncurrently, it throws: \n  javax.jcr.nodetype.ConstraintViolationException: no matching property definition found for <propertyname>",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3139",
        "summary": "missing sync in InternalVersionManagerImpl.externalUpdate can cause ConcurrentModificationException",
        "description": "In\n\n        for (Map.Entry<ItemId, InternalVersionItem> entry : versionItems.entrySet()) {\n            if (changes.has(entry.getKey())) {\n                items.add(entry.getValue());\n            }\n        }\n\nwe need to sync on versionItems, I believe.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1276",
        "summary": "A Property and a Node Can Have the Same Name ",
        "description": "according to paragraph \"3.3.4\" of the of the JSR 283 specification (Public Review Draft), a property and a node can have the same name. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-700",
        "summary": "Tests fail with NoClassDefFoundError: org/w3c/dom/ranges/DocumentRange",
        "description": "The nekohtml dependency in jackrabbit-text-extractors brings in a transitive xerces 2.4.0 dependency without the extra XML API classes required by Xerces. This causes test failures in jackrabbit-core and jackrabbit-jca because the Xerces dependency included in the test classpath overrides the default XML parser. Then, when the test cases try to parse XML documents, the missing XML API dependency causes a NoClassDefFoundError.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-3185",
        "summary": "refactor consistency checks in BundleDBPersistenceManager into a standalone class that could be re-used for other PMs",
        "description": "see subject",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-257",
        "summary": "Use separate index for jcr:system tree",
        "description": "Currently each workspace index also includes index data of repository wide data (e.g. version nodes under jcr:system). There are several drawbacks with this approach:\n\n- indexing is duplicated and does not scale when using a lot of workspaces\n- workspaces cannot be 'put to sleep' when they are not actively used.\n\nThe repository should have an additional index for system data, which includes: versioning and nodetype representation in content. Basically data under /jcr:system.\n\nQueries issued on a workspace will then use two index to execute the query: the workspace index and the system index.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3002",
        "summary": "Add read acessor for user data to SessionInfoImpl",
        "description": "Add method SessionInfoImpl.getUserData() to retrieve the user data set through SessionInfoImpl.setUserData(String)",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2738",
        "summary": "allow AbstractFileSystemTest.getFileSystem to throw an Exception",
        "description": "",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2561",
        "summary": "SQL2 query - supplying column selector fails with NPE on getColumnName()",
        "description": "I am preparing and executing an SQL2 query (JCR 2.0) as follows:\n\nQueryManager qm = jcrSession.getWorkspace().getQueryManager();\nString queryString = \"select order.[customerAccountUUID] as cust from [atl:order] as order\";\nQuery query = qm.createQuery(queryString, Query.JCR_SQL2);\nQueryResult queryResult = query.execute();\n\nThe following query fails:\n\nselect order.[customerAccountUUID] from [atl:order] as order\n\njava.lang.NullPointerException\n        org.apache.jackrabbit.commons.query.sql2.QOMFormatter.isSimpleName(QOMFormatter.java:577)\n        org.apache.jackrabbit.commons.query.sql2.QOMFormatter.formatName(QOMFormatter.java:567)\n        org.apache.jackrabbit.commons.query.sql2.QOMFormatter.format(QOMFormatter.java:452)\n        org.apache.jackrabbit.commons.query.sql2.QOMFormatter.format(QOMFormatter.java:123)\n        org.apache.jackrabbit.commons.query.sql2.QOMFormatter.format(QOMFormatter.java:117)\n\nline 452: c.getColumnName() returns null.\n\nThe following query is fine:\n\nselect order.[customerAccountUUID] as cust from [atl:order] as order\n\nI have been using the test case (here: http://svn.apache.org/viewvc/jackrabbit/trunk/jackrabbit-spi-commons/src/test/resources/org/apache/jackrabbit/spi/commons/query/sql2/test.sql2.txt?view=markup) as a guideline.\n\nCheers,\n\nJames ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1214",
        "summary": "DocId.UUIDDocId should not have a string attr uuid",
        "description": "After JCR-1213 will be solved, lots of DocId.UUIDDocId can be cached, and not being cleaned after every gc(). The number of cached UUIDDocId can grow very large, depending on the size of the repository.  Therefor, instead of storing the private String uuid; we can make it more memory efficient by storing 2 long's, the lsb and msb of the uuid.  Storing 1.000.000 of parent UUIDDocId might differ about 100Mb of memory. \n\nI even did test by removing the entire uuid string, and not use msb or lsb, because, when everything works properly (with references to index reader segments (See JCR-1213)), the uuid is never needed again: in \n\nUUIDDocId getDocumentNumber(IndexReader reader) throws IOException {\n\nwe could set uuid = null just before the return. It works perfectly well, because when an index reader is recreated, the CachingIndexReader will be recreated, hence DocId[] parents will be recreated. \n\nSo, IMO, I think we might be able to remove the uuid entirely when the docNumber is found in DocId.UUIDDocId (obviously after JCR-1213)\n\nWDOT?\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-474",
        "summary": "Introduce 'SecurityConfig' for better extensability.",
        "description": "the current repository configuration parser parses the security confguration (inluding appName, AccessManagerConfig and LoginModuleconfig) internally and the passes those 3 values to the repository config. i suggest to add a new 'SecurityConfig' object that encapsulates those 3 values and is parsed in a seperate method, in order to allow for better extensability. this also reduces the size of the alredy bloated repository config constructor.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-256",
        "summary": "Improve jcr decorator in jcr-ext",
        "description": "The jcr decorator in jcr-ext does not cover all the necessary interfaces of the jcr api. It may happen that a client loses the decoration layer when accessing properties.\n\nI've added decoration for several jcr interfaces to ensure that the decoration layer is never left.\n\nThe attached patch also removes the classes related to decorator chaining. I found it hard to understand the purpose of those classes and decided to remove them from the default implementation. If we want to keep those classes they should be less intrusive.\n\nI've also noticed that there are class name clashes, specifically the package org.apache.jackrabbit.name contains classes that are also present in the jackrabbit and jackrabbit-commons jar file. I propose to move the respective classes in jcr-ext to a different package or remove them in favor of the jackrabbit-commons classes.\n\nLet me know if I should commit the the patch.\n\nThanks",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1056",
        "summary": "JCR2SPI: improve ItemDefinitionProviderImpl.getMatchingPropdef to better handle multiple residuals",
        "description": "When a new property is set with unknown type (missing PropertyType parameter), ItemDefinitionProviderImpl.getMatchingPropdef() is used to find an applicable property definition.\n\nThere may be cases where multiple residual property defs may match, for instance, when the repository allows only a certain set of property types on that node type.\n\nIn this case, when the set of allowable types includes STRING, that propdef should be returned. After all, the client did not specify the type, so STRING is most likely the best match.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1634",
        "summary": "In XA transaction session.addLockToken() does not have effect",
        "description": "Following sequence does not work as expected:\n1. first tx (and first session)\n  create node\n  make it lockable\n2. second tx (and second session)\n  lock this node and save lock token\n3. third tx (and third session)\n  add saved lock token to session\n  modify this locked node -> fails as if lock token was not added to session3\n\nThe same sequence works as expected without transactions.\nI had to separate transactions 1 and 2 because JCR-1633 prevents node from being locked in same tx in which it was created.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-137",
        "summary": "Open-scoped locks may be lost on restart and might not be transferrable",
        "description": "Two issues with open-scoped locks were reported by C\u00e9dric Damioli:\n\n(1) When open-scoped locks are being reapplied on repository startup, locks on non-referenceable nodes are lost.\n(2) When a session holding an open-scoped lock logs out, the lock token is not automatically removed from the session and other sessions are not able to take responsibility for the lock, even when having the correct lock token.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1751",
        "summary": "Update slf4j",
        "description": "Please update slf4j from 1.3.0 to 1.5.2.\n\njcl104-over-slf4j has been renamed as jcl-over-slf4j, so if one uses a recent version, he has to exclude jcl104-over-slf4j for every jackrabbit dependency, which is quite a pain...\n\nNo impact observed.\n\nBest regards,\n\nStephane Landelle",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-327",
        "summary": "Mixins as supertypes do not appear to be queryable",
        "description": "When creating custom nodetypes that contain mixins as the supertype, nodes of the custom type do not appear to be queryable when using statements of the form: //element(*, mixin). Attached are a relatively simple JUnit test and compact type definition that seem to illustrate the problem.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1619",
        "summary": "Update copyright years in READMEs and NOTICEs",
        "description": "The README.txt files of Jackrabbit components contain copyright lines like this:\n\n    Collective work: Copyright 2007 The Apache Software Foundation.\n\nThe year should be updated.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-933",
        "summary": "RepositoryImpl.acquireRepositoryLock() fails to detect that the file lock is already held by the current process",
        "description": "with java 1.4 and 1.5 on a *nix-based platform it is possible to (concurrently) instantiate \nmore than one repository instance in the same jvm based on same/identical configurations.\n\nthis is a critical issue since it might lead to data corruption.\n\nthe issue only exists with java versions prior to 1.6 and *nix-based platforms (only verified\non mac os-x 10.4).\n\nnote that the issue does not exist when the file lock is held by another jvm.\n\n code snippet to reproduce the issue:\n\n            Repository rep1 = new TransientRepository();\n            Session s1 = rep1.login(new SimpleCredentials(\"johndoe\", \"\".toCharArray()));\n            Repository rep2 = new TransientRepository();\n            Session s2 = rep2.login(new SimpleCredentials(\"johndoe\", \"\".toCharArray()));\n\n\nthe root problem is the incorrect behavior of java.nio.channels.FileChannel#tryLock()\nwhich is demonstrated by the following code snippet:\n\n            try {\n                FileLock fl1 = new FileOutputStream(\"foo\").getChannel().tryLock();\n                System.out.println(\"1st lock: \" + fl1);\n                FileLock fl2 = new FileOutputStream(\"foo\").getChannel().tryLock();\n                System.out.println(\"2nd lock: \" + fl2);\n            } catch (Throwable t) {\n                t.printStackTrace();\n            }\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2848",
        "summary": "UserManagerImpl: typo in \"compatibleJR16\" config option constant",
        "description": "",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1043",
        "summary": "Package names for spring project do not match update ocm packages",
        "description": "The spring package and tests reference the old graffitto package naming scheme.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "BUG"
    },
    {
        "key": "JCR-1695",
        "summary": "Improve and promote spi-logger",
        "description": "The spi-logger is very useful for debugging an SPI implementation. However it only supports the RepositoryService interface. Other SPI interfaces are not supported. Also writing log information as string seems a bit restrictive to me. Finally it is not included in the jackrabbit-spi package which introduces an additional dependency for debugging. \n\nI therefore suggest:\n- Add support for the other major SPI interfaces \n- Replace the current way of logging a String to a Writer instance by a more versatile mechanism (i.e. clients have to provide an interface which consumes more structured log data). \n- Provide some default implementation for the above mechanism (i.e. writing to a file, writing to a slf4j based logger, writing to the console...)\n- Promote this project to jackrabbit-spi\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-722",
        "summary": "typo in the mimetypes.properties file",
        "description": "The Powerpoint mime-type (ppt) is wrong in mimetypes.properties file. It was written with a equals(=) caracter in place of a dot (.).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-978",
        "summary": "Remove circular dependency between VersionManagerImpl and VersionItemStateProvider",
        "description": "From a architectural perspective the VersionManagerImpl (VMgr) is at a higher level as the VersionItemStateProvider (VISP). While the VMgr deals with Items the VISP deals with ItemState object. Nonetheless the VISP has a reference to the VMgr and also calls the method setNodeReferences(), which violates the rule of a strictly layered system. E.g. one negative effect of this was a deadlock as described in JCR-672. It also makes it hard to solve JCR-962.\n\nThe attached patch includes the following changes:\n\n- Move method VersionManagerImpl.setNodeReferences() VersionItemStateManager. The method can operate on ItemStates only and does not need to be in VersionManagerImpl. As can be seen in the current method it directly calls the PeristenceManager, which indicates it should be located in a lower layer.\n- Promote the class VersionItemStateManager to a top level class\n- Change method VersionManagerImpl.createSharedStateManager to return a VersionItemStateManager\n- Remove VersionManagerImpl instance variable from VersionItemStateProvider\n- In VersionItemStateProvider.setNodeReferences() call VersionItemStateManager.setNodeReferences()\n- Instead of using the PersistenceManager in VersionManagerImpl.getItemReferences() use the ItemStateManager. It also seems that locking is not necessary for this method.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-108",
        "summary": "Node's childNodes out of sync after unsuccessful save()",
        "description": "If node.save() failes due to an exception in PersistanceManager.store(ChangeLog) a successive call to node.getNodes() will still contain a reference to the node which failed to be persisted.\nThis is the case even after a call to refresh(false).\nYou have to restart Jackrabbit in order to get rid of this reference\n\n\nUseCase in kind of dummy-code:\n\nnode.addNode(\"new\", \"nt:unstructured\");\nnode.save();\n=> ItemStateException from persistance\n\nnode.refresh(false);\n\nIterator itr = node.getNodes();\nwhile(itr.hasNext()) {\n   child = itr.nextNode();\n}\n=> Exception: \"Failed to build path to \"new\"\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-888",
        "summary": "javax.jcr.NamespaceException: : is not a registered namespace uri",
        "description": "Using the first hops with both versions 1.2.3 and 1.3, the repository is created successfully the first time it is run.  Subsequent attempts to login result in a javax.jcr.NamespaceException.\n\n\nDEBUG - Initializing transient repository\nINFO - Starting repository...\nINFO - LocalFileSystem initialized at path repository\\repository\nException in thread \"main\" javax.jcr.NamespaceException: : is not a registered namespace uri.\n\tat org.apache.jackrabbit.core.NamespaceRegistryImpl.getPrefix(NamespaceRegistryImpl.java:538)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.checkNamespace(NodeTypeRegistry.java:1292)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.validateNodeTypeDef(NodeTypeRegistry.java:1415)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.internalRegister(NodeTypeRegistry.java:1221)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.<init>(NodeTypeRegistry.java:671)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.create(NodeTypeRegistry.java:118)\n\tat org.apache.jackrabbit.core.RepositoryImpl.createNodeTypeRegistry(RepositoryImpl.java:571)\n\tat org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:262)\n\tat org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:584)\n\tat org.apache.jackrabbit.core.TransientRepository$2.getRepository(TransientRepository.java:245)\n\tat org.apache.jackrabbit.core.TransientRepository.startRepository(TransientRepository.java:265)\n\tat org.apache.jackrabbit.core.TransientRepository.login(TransientRepository.java:333)\n\tat org.apache.jackrabbit.core.TransientRepository.login(TransientRepository.java:388)\n\tat testing.FirstHops.main(FirstHops.java:24)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-764",
        "summary": "PdfTextFilter may leave parsed document open in case of errors",
        "description": "In case of errors in a parsed PDF document jackrabbit may fail to properly close the parsed document. PDFBox will write a stack trace to system out at finalize to warn agains this.\n\nthis is the resulting log:\n\nWARN org.apache.jackrabbit.core.query.LazyReader LazyReader.java(read:82) 20.02.2007 15:42:50 exception initializing reader org.apache.jackrabbit.core.query.PdfTextFilter$1: java.io.IOException: Error: Expected hex number, actual=' 2'\njava.lang.Throwable: Warning: You did not close the PDF Document\n   at org.pdfbox.cos.COSDocument.finalize(COSDocument.java:384)\n   at java.lang.ref.Finalizer.invokeFinalizeMethod(Native Method)\n   at java.lang.ref.Finalizer.runFinalizer(Finalizer.java:83)\n   at java.lang.ref.Finalizer.access$100(Finalizer.java:14)\n   at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:160)\n\n\nthis may happens because the parse() method at\n\nparser = new PDFParser(new BufferedInputStream(in));\nparser.parse();\n\nimmediately creates a document, but it can throw an exception while processing the file.\nPdfTextFilter should check if parser still holds a document and close it appropriately.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-262",
        "summary": "In AbstractImportXmlTest, a bug in getUnusedUri() causes URI length to grow too quickly, causing test to fail when using ORM-PM",
        "description": "Test fails when using ORM-PM because the URI exceeds the column size in the database.\n\nHere is the current implementation:\n\n    protected String getUnusedURI() throws RepositoryException {\n        Set uris = new HashSet(Arrays.asList(nsp.getURIs()));\n        String uri = TEST_URI;\n        int i = 0;\n        while (uris.contains(uri)) {\n            uri += i++;\n        }\n        return uri;\n    }\n\nWhen running the test, the URI grows to become something like this:\n\nWhen i=50,\n\"www.apache.org/jackrabbit/test/namespaceImportTest01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950\"\n\nHere is the proposed fix:\n\n    protected String getUnusedURI() throws RepositoryException {\n        Set uris = new HashSet(Arrays.asList(nsp.getURIs()));\n        String uri = TEST_URI;\n        int i = 0;\n        while (uris.contains(uri)) {\n            uri = TEST_URI + i++;\n        }\n        return uri;\n    }\n\nWhen i=50,\n\"www.apache.org/jackrabbit/test/namespaceImportTest50\"",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-1749",
        "summary": "JCRUrlConnection relies on nt:file/nt:resource",
        "description": "The JCRUrlConnection class implementing the jcr: URL handler for the JCR class loader relies on the fact that the intended primary type of the jcr:content child node of an nt:file node is of type nt:resource. When writing files with the Jackrabbit WebDAV server this is not the case as the jcr:content child node is of type nt:unstructured.\n\nAs a result the JCRUrlConnection.connect method fails with an ItemNotFoundException in the Util.getProperty(Item)  method because the primary item of the nt:unstructured node type is not defined.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2337",
        "summary": "TCK: NodeMixinUtil should exclude for mix:shareable",
        "description": "The mixin test NodeRemoveMixinTest#testRemoveSuccessfully tries to remove a mixin:\n\nwhat it does: retrieve an addable mixin (NodeTypeUtil#getAddableMixinName), adds it and tries to remove it later on.\nthe addable mixins are retrieve from the complete set of mixin, testing node.canAddMixin.\n\nHowever: with jackrabbit-core \"mix:shareable\" can be added but not removed.\nif the test by chance gets exactly that mixin the test fails with exception (there is an explicit check the core for exactly that case).\n\nthe tck should exclude that special case, shouldn't it?\n\n((michael found the issue)) ",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-971",
        "summary": "DocumentViewExportVisitor class incorrectly handles XML escaping for element names",
        "description": "The method private static String escapeName(String name) should have the following test:\n\n if ((i == 0) ? XMLChar.isNCNameStart(ch) : XMLChar.isNCName(ch)) {\n\nchanged into\n\n if ((i == 0) ? !XMLChar.isNCNameStart(ch) :! XMLChar.isNCName(ch)) {\n\nin order to properly escape the text (those two methods in XMLChar return true when the character is valid, not the other way around.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2094",
        "summary": "Use an enumeration for QOM operators",
        "description": "The PFD version of QueryObjectModelConstants contains some incorrect constant values that make it unusable as a source of operator constants.\n\nSince we are now using Java 5, I propose that instead of adding our own replacement constant strings, we implement a type-safe Operator enumeration that contains fixed versions of all the operator constants declared in QueryObjectModelConstants.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-787",
        "summary": "Missing equals and hashcode preventing the re-use of SharedFieldSortComparator",
        "description": "As briefly mentioned in the dev email list, improperly implemented (i.e., missing - using the default Object implementation) equals and hashcode in SearchIndex.java prevents the reuse of a SharedFieldSortComparator between different queries when nothing has changed in the repository.  In tests, this appears to have a fairly significant negative performance impact.\n\nPlease see the following for the correct code:\n\nhttp://svn.apache.org/viewvc?view=rev&revision=506908\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-791",
        "summary": "Improve performance of MatchAllScorer",
        "description": "The BitSets created in MatchAllScorer should be cached per IndexReader. This enhancement should also take care that the supplied IndexReader may in fact be a CombinedIndexReader or a CachingMultiReader with multiple contained IndexReaders. To achieve a good cache efficiency the BitSets must be cached per contained IndexReader and combined later.\n\nSee also thread on dev list: http://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/10976",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2503",
        "summary": " inconsistent session and persistent state after ReferentialIntegrityException",
        "description": "When a ReferentialIntegrityException occurs in a session it seems that subsequent actions on that session may result in a inconsistent session state AND even inconsistent persistent state. The latter will even make jackrabbit fail to bootstrap an index from that persistent state.\n\nTypical rootcause:\n\nCaused by: org.apache.jackrabbit.core.state.NoSuchItemStateException: ddb9d3ea-59c1-4eb4-a83e-332f646d4f40\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.getItemState(SharedItemStateManager.java:270)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1082)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1088)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createInitialIndex(MultiIndex.java:395)\n\nBootstrap failure:\n\njava.io.IOException: Error indexing workspace\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createInitialIndex(MultiIndex.java:402)\n        at org.apache.jackrabbit.core.query.lucene.SearchIndex.doInit(SearchIndex.java:465)\n        at org.apache.jackrabbit.core.query.AbstractQueryHandler.init(AbstractQueryHandler.java:59)\n        at org.apache.jackrabbit.core.SearchManager.initializeQueryHandler(SearchManager.java:553)\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-677",
        "summary": "Do not fulltext index jcr:uuid property",
        "description": "The UUID value of a referenceable nodes is currently add to the index four times:\n- As a system field _:UUID\n- As a property value for jcr:uuid\n- As part of the node scope fulltext index\n- As part of the jcr:uuid property scope fulltext index\n\nIn a repository with lots of referenceable nodes this bloates the index and does not add much value. Searching a node by its UUID is preferably done using the equal operator and not by using the jcr:contains() function.\n\nI suggest to remove fulltext indexing of the jcr:uuid property. Existing indexes would still work after this change, new or updated nodes would simply not have the property jcr:uuid fulltext indexed anymore.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2663",
        "summary": "JCR unit tests use invalid queries",
        "description": "According to Section 8.5.2.11 of the JCR 1.0 specification:\n\n    It is optional to support properties in the SELECT, WHERE and ORDER BY clauses that are not explicitly\n    defined in the node types listed in the FROM clause but which are defined in subtypes of those node types.\n\n    It is optional to support the specifying of properties in the SELECT,WHERE and ORDERBY clauses that \n    are not explicitly defined in the node types listed in the FROM clause but which are defined in mixin \n    node types that may be assigned to node instances of the types that are mentioned in the SELECT clause.\n\nHowever, two of the test methods in the org.apache.jackrabbit.test.api.query.SQLJoinTest class are producing and executing queries that use in the WHERE clause different properties and node types than those listed in the FROM clause.  The testJoinNtBase() method is producing a query using the following code:\n\n        StringBuffer query = new StringBuffer(\"SELECT * FROM \");\n        query.append(ntBase).append(\", \").append(testMixin);\n        query.append(\" WHERE \");\n        query.append(testNodeType).append(\".\").append(jcrPath);\n        query.append(\" = \");\n        query.append(mixReferenceable).append(\".\").append(jcrPath);\n        query.append(\" AND \").append(jcrPath).append(\" LIKE \");\n        query.append(\"'\").append(testRoot).append(\"/%'\");\n\nThis code will produce a valid query only when \"testNodeType\" is set to \"nt:base\" and \"testMixin\" is set to \"mix:referenceable\":\n\n    SELECT * FROM nt:base, mix:referenceable \n    WHERE nt:base.jcr:path = mix:referenceable.jcr:path AND ...\n\nHowever, when any other values for \"testNodeType\" and \"testMixin\" are used, this produces an invalid query in which the WHERE criteria references tuple sources that do not exist in the FROM clause.  For example, when \"testNodeType\" is \"my:type\" and \"testMixin\" is \"my:mixin\", the query becomes:\n\n    SELECT * FROM nt:base, my:mixin \n    WHERE my:type.jcr:path = mix:referenceable.jcr:path AND ...\n\nThis code can be corrected by simply using the \"testNodeType\" in the FROM clause.\n\nA similar bug is in the testJoinFilterPrimaryType() method, which uses this code:\n\n        StringBuffer query = new StringBuffer(\"SELECT * FROM \");\n        query.append(testNodeType).append(\", \").append(ntBase);\n        query.append(\" WHERE \");\n        query.append(testNodeType).append(\".\").append(jcrPath);\n        query.append(\" = \");\n        query.append(mixReferenceable).append(\".\").append(jcrPath);\n        query.append(\" AND \").append(jcrPath).append(\" LIKE \");\n        query.append(\"'\").append(testRoot).append(\"/%'\");\n\nThis code will really never produce a valid query, since the FROM clause uses the \"testNodeType\" and \"nt:base\" node types, whereas the WHERE clause will use the \"testNodeType\" and \"mix:referenceable\" types.  For example, if \"testNodeType\" has a value of \"my:type\", the query becomes:\n\n    SELECT * FROM my:type, nt:base \n    WHERE my:type.jcr:path = mix:referenceable.jcr:path AND ...\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2993",
        "summary": "Add method to set uuid in NodeInfoBuilder",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-957",
        "summary": "Set jcr and servlet-api dependency scope to provided",
        "description": "The jcr and servlet API libraries should typically be provided by the deployment environment and not included as compile/runtime dependencies of Jackrabbit artifacts. The scope of those dependencies should thus be set to provided in the <dependencyManagement/> section of the Jackrabbit parent POM.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1203",
        "summary": "Reorganize test suites",
        "description": "I'd like to better organize the test setup in jackrabbit-core. The current test repository is located in applications/test and managed with custom ant tasks and explicit do_init/do_test surefire configuration. It would be better to have the test repository located in target/repository (with template content coming from src/test/repository) and managed using the Maven 2 integration test lifecycle phases.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1509",
        "summary": "[SUBMISSION] Amazon S3 Persistence Manager Project",
        "description": "As I noted previously on the dev-list (http://markmail.org/search/?q=amazon+list%3Aorg.apache.jackrabbit.dev#query:amazon%20list%3Aorg.apache.jackrabbit.dev+page:1+mid:qw27gopsn4lnbde5+state:results) I have written an Amazon S3 bundle persistence manager for Jackrabbit. I want to submit the code for the sandbox, the full source is included in the zip file. Licensed under the ASF.\n\nThe project also aims to implement a normal persistence manager (which I abandoned in favor of the more efficient bundle pm, which is implemented, but does not work 100%), a file system impl for S3 (only rough structure present) and an SPI impl that connects to S3 (dreaming ;-)). For more infos, I will include the README.txt of the project here:\n\n=================================================================\nWelcome to Jackrabbit persistence for Amazon Webservices (ie. S3)\n=================================================================\n\nThis module contains various persistence options for using\nAmazon Webservices as backend for Jackrabbit / JCR. Amazon has\ntwo persistence services: S3 (public) and SimpleDB (still beta).\nThe following options are available/ideas:\n\n- (1) persistence managers that connects to S3\n      (normal + bundle, in work, probably not very efficient)\n      \n- (2) persistence manager that connects to SimpleDB\n      (NOT feasible)\n      \n- (3) SPI implementation that connects to S3\n      (not implemented, very complicated, probably more efficient)\n      \nSee details below and also TODO.txt\n\n\nInstalling / Testing\n====================\n\nThis needs a patched Jackrabbit 1.3.x version. The patches can\nbe found in the directory \"patches-for-1.3\". One patch will modify\nthe pom of jackrabbit-core to generated the jackrabbit test jar\nfor reuse in this project. To build that customized version, you need\nto do the following steps:\n\n1) svn co http://svn.apache.org/repos/asf/jackrabbit/branches/1.3 jackrabbit-1.3\n2) cd jackrabbit-1.3\n3) apply all patches from the \"patches-for-1.3\" directory:\n   patch -p0 < %JR-AMAZON-PATH%/patches-for-1.3/%PATCH%.patch\n4) mvn install\n5) cd %JR-AMAZON-PATH%\n6) change jackrabbit version number in pom.xml to the one you just built\n   (eg. project/parent/version = 1.3.4)\n7) cp aws.properties.template aws.properties\n8) enter your credentials in aws.properties\n9) mvn test\n\nFor debugging, you can change the logging in applications/test/log4j.properties\nand set up proxying (for monitoring the traffic with eg. tcp mon) in\napplications/test/jets3t.properties.\n\n\nDetails about Implementations\n=============================\n\n(1) org.apache.jackrabbit.persistence.amazon.AmazonS3PersistenceManager\n\nhttp://www.amazon.com/s3\n\nStores JCR Nodes and Properties inside S3 Objects. Uses UUID for Nodes and\nUUID/Name for Properties as Object names. Node references are stored\nvia references/UUID.\n\nConfiguration parameters:\n\naccessKey\n    Amazon AWS access key (aka account user id) [required]\n\nsecretKey\n    Amazon AWS secret key (aka account password) [required]\n    \nbucket\n    Name of the S3 bucket to use [optional, default uses accessKey]\n    Note that bucket names are global, so using your accessKey is\n    recommended to prevent conflicts with other AWS users. \n    \nobjectPrefix\n    Prefix used for all object names [optional, default is \"\"]\n    Should include the workspace name (\"${wsp.name}\" or \"version\" for\n    the versioning PM) to put multiple workspaces into one bucket.\n\nExample XML Config:\n\n<PersistenceManager class=\"org.apache.jackrabbit.persistence.amazon.AmazonS3PersistenceManager\">\n    <param name=\"accessKey\"    value=\"abcde01234\"/>\n    <param name=\"secretKey\"    value=\"topsecret\"/>\n    <param name=\"bucket\"       value=\"abcde01234.jcrstore\"/>\n    <param name=\"objectPrefix\" value=\"${wsp.name}/\"/>\n</PersistenceManager>\n\n-----\n\n(2) AmazonSimpleDBPersistenceManager\n\nThis is *not* feasible because of the restrictions that are applied\nto SimpleDB. An item can only have up to 256 attributes, each attribute\ncan only contain a string value and that one can only have 1024 chars.\nSee this link for more information:\n\nhttp://docs.amazonwebservices.com/AmazonSimpleDB/2007-11-07/DeveloperGuide/SDB_API_PutAttributes.html\n\n-----\n\n(3) org.apache.jackrabbit.spi2s3\n\nTODO\n\nlots of work...\n\n\nAbout\n=====\n\nIt was originally written by Alexander Klimetschek\n(alexander.klimetschek at googlemail dot com) in 2008.\n\nSee the Apache Jackrabbit web site (http://jackrabbit.apache.org/)\nfor documentation and other information. You are welcome to join the\nJackrabbit mailing lists (http://jackrabbit.apache.org/mail-lists.html)\nto discuss this component and to use the Jackrabbit issue tracker\n(http://issues.apache.org/jira/browse/JCR) to report issues or request\nnew features.\n\nApache Jackrabbit is a project of the Apache Software Foundation\n(http://www.apache.org).\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1753",
        "summary": "Allow means force a Repository to synchronize with the cluster",
        "description": "Based on the thread on the user mailing list I'm logging this to propose adding a sync() method to force cluster synchronization using the JackrabbitRepository extension API.\n\nThe purpose of the method is such that in a distributed clustered environment sometime cluster synchronization does or has not occurred such that certain repositories are in a stale state.  This method would provide a means to force a repository to update pull in possible changes made by other Jackrabbit repositories.\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1502",
        "summary": "Journal log file rotation overwrites old files",
        "description": "Journal log files are rotated as follows:\n\n  journal.log.N -> journal.log.(N+1)\n\nBecause the list of files to be rotated is created with alphanumeric sort order\n(descending), it may destroy files in the following situation:\n\n  journal.log.9  -> journal.log.10\n  ..\n  journal.log.2  -> journal.log.3\n  journal.log.10 -> journal.log.11 (!)\n  journal.log.1  -> journal.log.2\n\ni.e. journal.log.10 is overwritten by journal.log.9 and then moved.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3266",
        "summary": "JCR-SQL2 query with multiple columns in result only returns last column when using Row.getValues()",
        "description": "When running a query like below on an in-process repository (via TransientRepository) or via RMI access, a call to Row.getValues() only returns the last column selected:\n\n       SELECT property1, property2 FROM [nodetype]\n\nQueryResult.getColumnNames() returns the right set of columns.\n\nStepping through the code shows that org.apache.jackrabbit.core.query.lucene.join.AbstractRow has the implementation of getValues() - this creates a new Values array, then overwrites it multiple times in a for loop that iterates once per column. That doesn't sound like the desired behaviour.\n\nGetting values via individual calls to Row.getValue(\"property1\") gives the correct results.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3161",
        "summary": "Add JcrUtils.getPropertyTypeNames ",
        "description": "for property related ui its common to populate a list with all property type names.\ninstead of hardcoding at various places that list could be provided by JcrUtils.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1480",
        "summary": "Deadlock when executing Version operations",
        "description": "This only happens when a XA transaction is committed without changes. In XAVersionManager there is a check in the InternalXAResource returned by getXAResourceBegin(), which only acquires the write lock on the version manager if there are version related changes in the transaction. This kind of check is missing in the methods XAVersionManager.prepare/commit/rollback().",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-416",
        "summary": "Webdav Simple: Delegate PROPPATCH to (extended) IOHandlers",
        "description": "complete description:\nhttp://article.gmane.org/gmane.comp.apache.jackrabbit.devel/6582\n\nProposed solution\n------------------------------------------------------------------------------------------------------------------------------------\n\nThe situation described before leads me to the following conclusion:\n\n- IOHandler should not only read/write resource data and properties during GET, PUT, PROPFIND but should\n   also take care of setting/removing properties upon PROPPATCH.\n\n- Since the previous suggestion would still limit the properties to (jcr:encoding, jcr:mimeType and\n   jcr:lastModified), we may think about changing the default nodetype for the jcr:content node to\n   nt:unstructured.\n\nI guess this would meet the requirements for those expecting a webDAV server that is (as a first step)\nnot limited regarding PROPPATCH. Second it would allow to have a handling of property modifications\nwhich is specific for individual resource types instead of trying to set all properties to the uppermost node.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-283",
        "summary": "NamespaceRegistry.registerNamespace(pre, uri)  might accidentally remove namespace in certain situations",
        "description": "assume the following mappings exist in the global NamespaceRegistry:\n\npre1 <-> uri1\npre2 <-> uri2\n\nthe following stmt correclty throws a NamespaceException, complaining that an existing prefix can not be remapped:\n\nnsReg.registerNamespace(\"pre2\", \"uri1\")\n\nbut, as a sideeffect, it has also removed the mapping pre1 <-> uri1.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1573",
        "summary": "Lucene Query Exception: 'attempt to access a deleted document'",
        "description": "Hi,\n\nI am getting an exception when trying to execute a query through the (Spring) JcrTemplate class....using the following code:\nQueryManager qMgr = session.getWorkspace().getQueryManager();\nQueryResult result = qMgr.createQuery(xpathQuery, Query.XPATH ).execute();\n\nThe exception is thrown at the second line and is as follows:\n\n[DEBUG] << \"[0x9]at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:113)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.lucene.search.Hits.getMoreDocs(Hits.java:74)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.lucene.search.Hits.&lt;init>(Hits.java:53)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.lucene.search.Searcher.search(Searcher.java:46)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.lucene.search.Searcher.search(Searcher.java:38)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.jackrabbit.core.query.lucene.SearchIndex.executeQuery(SearchIndex.java:660)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.jackrabbit.core.query.lucene.QueryResultImpl.executeQuery(QueryResultImpl.java:242)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.jackrabbit.core.query.lucene.QueryResultImpl.getResults(QueryResultImpl.java:290)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.jackrabbit.core.query.lucene.QueryResultImpl.&lt;init>(QueryResultImpl.java:192)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.jackrabbit.core.query.lucene.QueryImpl.execute(QueryImpl.java:138)[\\n]\"\n[DEBUG] << \"[0x9]at org.apache.jackrabbit.core.query.QueryImpl.execute(QueryImpl.java:176)[\\n]\"\n[DEBUG] << \"[0x9]at com.intel.cds.cr.jcr.JcrManager$5.doInJcr(JcrManager.java:363)[\\n]\"\n[DEBUG] << \"[0x9]at org.springmodules.jcr.JcrTemplate.execute(JcrTemplate.java:76)[\\n]\"\n[DEBUG] << \"[0x9]at org.springmodules.jcr.JcrTemplate.execute(JcrTemplate.java:108)[\\n]\"\n[DEBUG] << \"[0x9]... 19 more[\\n]\"\n[DEBUG] << \"</Exception></detail></soapenv:Fault></soapenv:Body></soapenv:Envelope>\"\norg.apache.axis2.AxisFault: attempt to access a deleted document\n\tat org.apache.axis2.util.Utils.getInboundFaultFromMessageContext(Utils.java:486)\n\tat org.apache.axis2.description.OutInAxisOperationClient.handleResponse(OutInAxisOperation.java:343)\n\tat org.apache.axis2.description.OutInAxisOperationClient.send(OutInAxisOperation.java:389)\n\tat org.apache.axis2.description.OutInAxisOperationClient.executeImpl(OutInAxisOperation.java:211)\n\tat org.apache.axis2.client.OperationClient.execute(OperationClient.java:163)\n\n\nMy Jackrabbit/Lucene configuration is as follows:\n\n<SearchIndex class=\"org.apache.jackrabbit.core.query.lucene.SearchIndex\">\n        <param name=\"path\" value=\"${rep.home}/repository/index\"/>\n        \n        <param name=\"useCompoundFile\" value=\"false\"/>\n        <param name=\"mergeFactor\" value=\"5\"/>\n        <param name=\"cacheSize\" value=\"10000\"/>\n        <param name=\"respectDocumentOrder\" value=\"false\"/>  \n  </SearchIndex>\n\nIs this a configuration issue or a bug?\n\nThanks,\nDavid.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2942",
        "summary": "Move privilege reader/writer to spi-commons and use qualified names",
        "description": "the current privilege reader in jcr-commons uses a PrivilegeDefinition that is based on pure string rather than qualified names. suggest to move that to the spi-commons and use org.apache.jackrabbit.spi.Name for the privilege names.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": ""
    },
    {
        "key": "JCR-2253",
        "summary": "Discovery of privileges of any set of Principals",
        "description": "jsr 283 defines means to discover the privileges for the editing session. however there is no way to determine the privileges for other principals.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2308",
        "summary": "Allow reuse of Q*DefinitionBuilder in QItemDefinitionsBuilder",
        "description": "It would be nice to reuse the builder implementations in QItemDefinitionsBuilder elsewhere when Q*Definitions need to be built.\n\nI will extract the relevant classes so they can be used independently and make QItemDefinitionsBuilder use them.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1235",
        "summary": "o.a.j.core.integration.PrepareTestRepository fails on 2nd and every subsequent invocation",
        "description": "console output: \n\n-------------------------------------------------------------------------------\nTest set: org.apache.jackrabbit.core.integration.PrepareTestRepository\n-------------------------------------------------------------------------------\nTests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.428 sec <<< FAILURE!\ntestPrepareTestRepository(org.apache.jackrabbit.core.integration.PrepareTestRepository)  Time elapsed: 3.397 sec  <<< ERROR!\njavax.jcr.RepositoryException: Invalid node type definition: {http://www.apache.org/jackrabbit/test}versionable already exists: {http://www.apache.org/jackrabbit/test}versionable already exists\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl.registerNodeTypes(NodeTypeManagerImpl.java:308)\n\tat org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl.registerNodeTypes(NodeTypeManagerImpl.java:488)\n\tat org.apache.jackrabbit.core.integration.PrepareTestRepository.testPrepareTestRepository(PrepareTestRepository.java:49)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-804",
        "summary": "Avoid using MultiTermDocs",
        "description": "Similar to MatchAllQuery also RangeQuery and WildcardQuery will result in use of MultiTermDocs. Those queries should also use the MultiScorer. See also issue JCR-791.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2460",
        "summary": "Rename GenericRepositoryFactory to JndiRepositoryFactory",
        "description": "The GenericRepositoryFactory class introduced in JCR-2360 has since been refactored so that most of its functionality is now distributed among the more implementation-specific RepositoryFactory classes. Now the GenericRepositoryFactory only contains support for looking the repository up in JNDI, so it would be better to rename the class to JndiRepositoryFactory.\n\nThe only troublesome part of the rename is the GenericRepositoryFactory.URI constant that was for a while documented on our wiki as a part of the canonical code snippet for accessing a remote repository based on the repository URI. The latest recommendation is to use the JcrUtils.getRepository(String uri) method so the constant is no longer needed in client code, but for backwards compatibility with earlier Jackrabbit 2.0 betas it may be good to keep the deprecated constant for at least the next beta release.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1381",
        "summary": "Path is not indexed when inserting a new node with SNS",
        "description": "Using Jackrabbit OCM, when inserting two nodes with the same path, the second node's path is not indexed. \nBoth nodes have the same path, and a search by path retrieves the first node only. \n\nThe node mapping included the following annotations:\n\n@Node(jcrMixinTypes=\"mix:referenceable,mix:lockable,mix:versionable\") \npublic class Article { \n\n        @Field(uuid=true) \n        private String id = null; \n        \n        @Field(path=true) \n        private String path = null; \n\n        ....\n}",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2502",
        "summary": "Upgrade to Tika 0.6 and PDFBox 1.0.0",
        "description": "Tika version 0.6 uses POI 3.6 that's notably smaller (-10MB!) than previous versions. There are also a number of other improvements in Tika 0.6 since the 0.5 release.\n\nWhile doing the upgrade we should also force the PDFBox version to 1.0.0 from the 0.8.0-incubating version that Tika 0.6 uses. PDFBox 1.0.0 has some nice performance gains (around 30% faster) to text extraction along with other improvements.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2895",
        "summary": "SessionImpl#getSubject() should return an unmodifiable subject",
        "description": "for security reasons the subject exposed by SessionImpl#getSubject() should be unmodifiable or at least changes made\nto it should not be modify the subject hold by the session.\n\ncurrently i see the following options to get there:\na: set readonly flag on the subject associated with the session\nb: getSubject() returns a new instance of Subject having the same characteristics as the subject associated with the session\nc: getSubject() returns a new but readonly Subject instance\n\nmy preferred solution was c as\n- it doesn't change the characteristics of the subject\n- the unmodifiable status is transparent to the caller since modifying the subject fails without forcing the api consumer\n  to read the javadoc to know why changing the subject is not reflected on the session itself (that would be a drawback of b).",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-3136",
        "summary": "Add m2e lifecycle mappings for Eclipse Indigo",
        "description": "When importing Jackrabbit to the latest Eclipse release (Indigo) that comes with m2e version 1.0, many of the POMs are flagged red because m2e doesn't know what to do with the custom plugin mappings we use in many components.\n\nThis is a pretty contentious issue for m2e (see for example https://bugs.eclipse.org/bugs/show_bug.cgi?id=350414), and ideally it should just work without any custom workarounds on our part.\n\nHowever, as a workaround until the core issue is solved, the best solution is to explicitly tell m2e what to do with these plugin mappings. The extra org.eclipse.m2e:lifecycle-mapping configuration is only active when used within Eclipse, so it doesn't affect\nnormal builds.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-297",
        "summary": "Jcr-Server: Avoid xml parsing if request body is missing",
        "description": "Originally reported by Brian.\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2425",
        "summary": "Session.save() and Session.refresh(boolean) rely on accessibility of the root node",
        "description": "follow-up issue to JCR-2418:\n\nan editing session that is only allowed to write in a subtree but isn't allowed to access the root node will not be\nable to save or revert changes made in the transient space within that subtree.\n\nthe reason for this is, that both SessionImpl.save() and SessionImpl.refresh(boolean) access the root node\nin order to execute the call. since it's the regular call READ permissions are checked, although the user\nmade no attempt to *look* at the root.\n\nA workaround would be to call Item.save() on the modified tree itself that obviously was visible for the \nuser... unfortunately that method is deprecated as of JCR 2.0. Therefore, I have the impression that we\nshould fix the methods mentioned above.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-623",
        "summary": "Clustering",
        "description": "Implement basic clustering, i.e. make two or more repositories available at the same time,  allowing them to stay in sync with changes applied to only one of them.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2106",
        "summary": "SystemSessions created for GarbageCollector are not logged out of",
        "description": "I have a simple garbage collection task that runs periodically. After upgrading to 1.5.5 it started logging a warning shortly after each run:\n\n2009-05-09 03:44:45,480 WARN [org.apache.jackrabbit.core.SessionImpl] - <Unclosed session detected. The session was opened here: >\njava.lang.Exception: Stack Trace\n\tat org.apache.jackrabbit.core.SessionImpl.<init>(SessionImpl.java:239)\n\tat org.apache.jackrabbit.core.SystemSession.<init>(SystemSession.java:76)\n\tat org.apache.jackrabbit.core.SystemSession.create(SystemSession.java:64)\n\tat org.apache.jackrabbit.core.SessionImpl.createDataStoreGarbageCollector(SessionImpl.java:649)\n\nSo it's not my session, but an internally created SystemSession.\n\n\nCode I'm using:\n            getTemplate().execute(new JcrCallback()\n            {\n                public Object doInJcr(Session session)\n                    throws IOException, RepositoryException {\n                    SessionImpl sessionImpl = (SessionImpl)session;\n                    GarbageCollector gc = sessionImpl.createDataStoreGarbageCollector();\n                    gc.scan();\n                    gc.stopScan();\n                    gc.deleteUnused();\n                    return null;\n                }\n            }, true);\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1645",
        "summary": "Add support for Map of referenced beans",
        "description": "OCM should support the mapping of maps of referenced beans.\n\n@Collection(collectionConverter= BeanReferenceCollectionConverterImpl.class)\nprivate java.util.Map<String, ReferencedBean> aMap;\n\nBeanReferenceCollectionConverterImpl (mainly the method doGetCollection) needs to be updated to support the interface ManageableMap interface.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1227",
        "summary": "Restore of empty multivalue property always changes property type to String",
        "description": "When you do a restore of  empty multivalue property (OPV=COPY), restored property always has the String type (no matter of property type in frozen state). The solution is to set the property type from frozen state instead of retriving it from 'first' value. If mulitvalue does not have any values the type is set to UNDEFINED and finally changed to STRING in restore method.\n\nAttached patch with test case.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1095",
        "summary": "ReferencesPropertyTest can't deal with multivalued reference properties",
        "description": "The setUp() method uses prop.getNode(), thus assuming that the reference property is not multivalued.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    }
]