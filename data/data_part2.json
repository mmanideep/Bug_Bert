[
  {
        "key": "HTTPCLIENT-1172",
        "summary": "LocalTestServer and supporting classes should be available as a separate jar",
        "description": "LocalTestServer and it's supporting classes are useful to anyone who wants to easily \"mock\"/test simple http calls without having to embed a full jetty or something.\nIt would be awesome if these were available in a separate http-localtestserver.jar that could be used in projects outside of httpclient.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": ""
    },
    {
        "key": "HTTPCLIENT-202",
        "summary": "GetMethod.java checks the \"used\" flag which cannot be set at this time",
        "description": "GetMethod.getResponseBodyAsStream calls HttpMethodBase.checkUsed, which asserts\nthe flag \"used\" is \"true\". But at this time, \"used\" cannot be true, as \"used\" is\nset to true in HttpMethodBase.processRequest, two lines after readResponse is\ncalled (which in turn calls readResponseBody / readResponseBodyAsStream).\n\nMaybe \"requestSent\" is the flag which should be checked instead of \"used\"?\n\nMy stack trace: (fragment)\n\njava.lang.IllegalStateException: Not Used.\n        at\norg.apache.commons.httpclient.HttpMethodBase.checkUsed(HttpMethodBase.java:1642)\n        at\norg.apache.commons.httpclient.methods.GetMethod.getResponseBodyAsStream(GetMethod.java:309)\n        at\norg.apache.commons.httpclient.methods.GetMethod.readResponseBody(GetMethod.java:428)\n        at\norg.apache.commons.httpclient.HttpMethodBase.readResponse(HttpMethodBase.java:1893)\n        at\norg.apache.commons.httpclient.HttpMethodBase.processRequest(HttpMethodBase.java:2496)\n        at\norg.apache.commons.httpclient.HttpMethodBase.execute(HttpMethodBase.java:1062)\n        at\norg.apache.commons.httpclient.HttpClient.executeMethod(HttpClient.java:599)\n        at\norg.apache.commons.httpclient.HttpClient.executeMethod(HttpClient.java:497)\n        at\norg.apache.webdav.lib.WebdavResource.getMethodData(WebdavResource.java:2227)\n        at\norg.apache.webdav.lib.WebdavResource.getMethodData(WebdavResource.java:2206)\n[...]",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-111",
        "summary": "Add multi-part post support",
        "description": "Add a new method to support multi-part post.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-353",
        "summary": "Setting different MAX_HOST_CONNECTION values per host using a single MultiThreadedHttpConnectionManager",
        "description": "Right now, it's not possible to use the\nMultiThreadedHttpConnectionManager.setMaxConnectionsPerHost(int) method in a per\nHostConfiguration basis. The value applies to every HostConfiguration the\ncurrent connection manager is managing.\n\nI would be quite useful to allow the connection manager to set different values\ndepending on the HostConfiguration.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-998",
        "summary": "cache should use both Last-Modified and ETag for validations when available",
        "description": "This is a protocol recommendation:\n\n\"[HTTP/1.1 clients], if both an entity tag and a Last-Modified value have been provided by the origin server, SHOULD use both validators in cache-conditional requests. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.\"\n\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4\n\nThe current implementation only uses the ETag when conditionally validating an entry, so HTTP/1.0 caches can't currently reply to us with a 304 (Not Modified), even if that would be appropriate.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-837",
        "summary": "Wire produces invalid log skipping zero bytes in certain cases",
        "description": "WireLogInputStream class line 82 check if the byte returned is not -1 meaning end of stream. But the condition is wrong in case if this byte is 0, it should look like\n\nif (l != -1) {\n//...\n}\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-554",
        "summary": "AbstractHttpProcessor hard-wired against a single context",
        "description": "I can't use the AbstractHttpProcessor as it is for asynchronously\nprocessing different requests, because it is hard-wired to use a\nsingle context which can not be changed. Async requires different\ncontexts for requests. Patch follows.\n\ncheers,\n  Roland",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-939",
        "summary": "302 response without location header throws exception",
        "description": "Hi, \n\nAccording to HTTP 1.1 Spec : http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.3\n\"The temporary URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).\"\n\nNow, in \"DefaultRedirectStrategy.getLocationURI()\", there's a ProtocolException thrown if location header is null.  \n\nif (locationHeader == null) {\n    // got a redirect response, but no location header\n    throw new ProtocolException(\n        \"Received redirect response \" + response.getStatusLine()\n       + \" but no location header\");\n }\n\nThe specs says \"SHOULD\" and not \"MUST\". ProtocolException \"signals that an HTTP protocol violation has occurred\", which is not exactly true.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-477",
        "summary": "There is no way to specify a different auth scheme priority for host and proxy",
        "description": "Using HttpClient 3.0 rc2, you cannot authenticate to a site using Basic\nAutentication and to a proxy server using NTLM authentication.\n\nWhen you indicate a prefference to use NTLM over Basic authentication the\nauthentication will fail when it tries to authenticate NTML to the Proxy and to\nthe Site. If you indicate Basic, then NTLM authentication order the Basic\nauthentication will fail when used for the Proxy (since basic authentication\ncan't send the domain name it fails).\n\nThe email thread from the discussion group is pasted below for refference.\n\n==============================================================\n==============================================================\n\nHi all,\nI am trying to authenticate to a server via a proxy which also requires\nauthentication. It seems that I can get either the proxy authentication to work\nOR the site authentication to work, but not both.\n\nBoth seem to work independently when I set the credentials (or proxy\ncredentials) using NTCredentials (e.g. if I connect to the site from a network\nnot using a proxy I can get it to work, and I can authenticate to the proxy only\nto get a 401 authentication failed from the server when using the proxy).\n\nI read in the Authentication tutorial that you can't authenticate using NTLM to\nboth the proxy and site, so I'm trying various combinations of authentication,\nbut I can't find any documentation that specifically covers this case and I feel\nlike I'm just taking stabs in the dark right now.\n\nIf anyone can point me in the direction of the light at the end of the tunnel\nI'd really appreciate it.\n\nThanks,\nDavid\n\n----------------\n\nOn Wed, Jun 29, 2005 at 09:53:07AM -0700, David Parks wrote:\n> Hi all,\n> I am trying to authenticate to a server via a proxy which also requires\nauthentication. It seems that I can get either the proxy authentication to work\nOR the site authentication to work, but not both.\n> \n> Both seem to work independently when I set the credentials (or proxy\ncredentials) using NTCredentials (e.g. if I connect to the site from a network\nnot using a proxy I can get it to work, and I can authenticate to the proxy only\nto get a 401 authentication failed from the server when using the proxy).\n> \n> I read in the Authentication tutorial that you can't authenticate using NTLM\nto both the proxy and site, so I'm trying various combinations of\nauthentication, but I can't find any documentation that specifically covers this\ncase and I feel like I'm just taking stabs in the dark right now.\n\nDavid,\n\nYou _really_ can't use NTLM to authenticate with the proxy and the\ntarget host at the same, due to the nature of this authentication\nscheme. Really. That was not a joke.\n\nPlease consider using one of the following combinations instead:\n\n(1) BASIC proxy + NTLM host if both the clent and the proxy are within a\ntrusted network segment\n\n(2) NTLM proxy + SSL + BASIC host\n\nBoth combinations should provide an adequate (or better in the latter case)\nsecurity\n\nHope this helps\n\nOleg\n\n> \n> If anyone can point me in the direction of the light at the end of the tunnel\nI'd really appreciate it.\n> \n> Thanks,\n> David\n> \n> \n\n-------------------\n\nThanks for the reply Oleg. This is what I figured, but I cannot see how to use\ndifferent authentication schemes for the Proxy vs. the Site authentication\nchallenge.\n\nI tried adding the code suggested in the Authentication tutorial:\n\n        List authPrefs = new ArrayList(2);\n        authPrefs.add(AuthPolicy.DIGEST);\n        authPrefs.add(AuthPolicy.BASIC);\n        authPrefs.add(AuthPolicy.NTLM);\n         This will exclude the NTLM authentication scheme\n        httpclient.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY,\nauthPrefs);\n\nI got a message stating that it was attempting BASIC authentication for the\nProxy and that it failed (probably because the domain doesn't get passed I\nguess). So my thought is that I need NTLM for the proxy authentication and Basic\nwill work for the site authentication.\n\nThe question I am then working on is how to direct the HttpClient to select that\norder of authentication methods. If I let it take NTLM as the preffered\nauthentication method then it will try to authenticate both challenges with NTLM.\n\nI sure there is just some little detail I'm missing here somewhere, it's just\nhard to find it.\n\nThanks a lot!\nDavid\n\n------------------\n\nDavid,\n\nI see the problem. This will require a patch and a new parameter.\nLuckily the preference API introduced in HttpClient 3.0 allows up to add\nparameters quite easily. Please file a feature request with Bugzilla\nASAP and I'll do my best to hack up a patch before I leave for holidays\n(that is Friday, July 1st)\n\nOleg\n\n\n--------------\n\nHi Oleg, thanks, I'll put that request in today.\nThis helps a lot, at least I know I'm on the right path now.\n\nI am attempting to devise a workaround for this by handling the authentication\nmanually (setDoAuthentication(false)).\n\nWhen I see a 401 error I am processing a basic authentication with the site\ncredentials, when I see a 407 error I want to process an NTLM authentication\nwith the proxy credentials.\n\nTo that end I have the following code that runs after\nhttpclient.execute(getmethod) executes. The code below works perfectly for the\nbasic authentication (when the proxy is not in the picture).\n\nIn looking up the Handshake of the NTLM authentication I see that I have a\nproblem with the code below since the handshake includes 2 challenge and\nauthorization steps before the authentication succeeds. I'm not clear how I\ncould manually authenticate the NTLM response. I would expect the NTLMScheme\nclass to contain a Type 1 and Type 3 authenticate() method for processing both\nchallenge responses. Is there another way of processing the NTLM authentication\nafter receiving the initial authentication challenge from the server?\n\n        //Check for Proxy or Site authentication\n        if(getmethod.getStatusCode() == 401){\n            //Authenticate to the site using Basic authentication.\n            BasicScheme basicscheme = new BasicScheme();\n            String basic_auth_string = basicscheme.authenticate(new\nNTCredentials(\"cwftp\", \"664A754c\", \"\", \"\"), getmethod);\n            Header basic_auth_header = new Header(\"Authorization\",\nbasic_auth_string);\n            getmethod.addRequestHeader(basic_auth_header);\n            try{\n                httpclient.executeMethod(getmethod);\n            }catch(Exception e){\n                logger.log(Level.SEVERE, \"ack!!!!\", e);\n            }\n            return getmethod;\n       }else if(getmethod.getStatusCode() == 407){\n            //Authenticate to the site using Basic authentication\n            NTLMScheme ntlmscheme = new NTLMScheme();\n            String basic_auth_string = ntlmscheme.authenticate(new\nNTCredentials(\"00mercbac\", \"!@SAMmerc2004\", \"simproxy\", \"CFC\"), getmethod);\n            Header basic_auth_header = new Header(\"Authorization\",\nbasic_auth_string);\n            getmethod.addRequestHeader(basic_auth_header);\n            try{\n                httpclient.executeMethod(getmethod);\n            }catch(Exception e){\n                logger.log(Level.SEVERE, \"ack!!!!\", e);\n            }\n            return getmethod;\n       }\n\n\nThanks,\nDavid",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-737",
        "summary": "EchoHandler:104 possible NPE",
        "description": "Line 104 of EchoHandler is\n\n    bae.setContentType(entity.getContentType());\n\na few lines previously, entity is checked for null, so it appears that entity can be null.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-4",
        "summary": "Chunked transfer encoding not isolated from application.",
        "description": "Chunked transfer encoding is not being supported transparently by the\nHttpMethodBase object, causing chunk data to be embedded in response body data\nand forcing the application to handle the HTTP/1.1 implementation of chunked\ntransfer encoding.\n\nThe included patch now properly parses chunk data as per RFC 2068 and provides\nbody content consistently, regardless of whether chunked transfer encoding was\nused by the server or not. This relieves the application from the requirement of\nimplementing RFC 2068.\n\nPatch sent to mailing list as per guidelines to address this deficiency.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-1007",
        "summary": "When A URL is redirected, there is no easy way to encode the new url before HC tries to execute it/",
        "description": "When you implement your custom RedirectHandler, there is no easy way to encode the new URL being redirected to.\n\nA public method to access the location string prior to the URI generation would be useful.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-902",
        "summary": "In case of ConnectTimeoutException : HttpRequestRetryHandler is not used.",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-1013",
        "summary": "website: 404 for several documentation pages",
        "description": "There are several 404 Not Found pages linked from hc.apache.org.\nPlease fix them as it's important documentation for HttpClient.\n\nSpecifically:\n\nlinked from http://hc.apache.org/user-docs.html\n\nnot found:\nhttp://hc.apache.org/httpcomponents-client/primer.html\nhttp://hc.apache.org/httpcomponents-client-4.0.1/httpclient/apidocs/index.html\nhttp://hc.apache.org/httpcomponents-client-4.0.1/httpmime/apidocs/index.html",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-83",
        "summary": "handle multivalue headers correctly",
        "description": "Some times, web servers send back multiple headers with the same key. e.g.\n\nWWW-Authenticate: Negotiate\nWWW-Authenticate: NTLM\nWWW-Authenticate: Basic realm=\"kmdc5\"\n\nTo handle this correctly, we should add a method \n\npublic java.util.Iterator getResponseHeaders(java.lang.String name)\n\njust as in javax.servlet.http.HttpServletRequest.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-239",
        "summary": "Redirect 302 to the same URL causes max redirects exception",
        "description": "I noticed that if the server returns a 302 without a URL in the link, the \nHttpClient follows the empty URL up to the maximum times (100 by default).  \nInstead it should check and if the URL is an empty string it shouldn't try to \nfollow the redirect.\n\n12:18:17,430 [U:          ] [main                ] ERROR \nHttpMethodBase               - Narrowly avoided an infinite loop in execute\n12:18:17,430 [U:          ] [main                ] DEBUG \nURLMonitor                   - Method.execute attempt 1 failed \nhttp://www.stagecoach.co.uk: \norg.apache.commons.httpclient.HttpRecoverableException: Maximum redirects (100) \nexceeded\n12:18:17,430 [U:          ] [main                ] DEBUG \nURLMonitor                   - HttpRecoverableException \n(http://www.stagecoach.co.uk) : \norg.apache.commons.httpclient.HttpRecoverableException: Maximum redirects (100) \nexceeded\n\tat org.apache.commons.httpclient.HttpMethodBase.execute\n(HttpMethodBase.java:1065)\n\tat com.verideon.veriguard.domain.URLMonitor.monitor(URLMonitor.java:189)\n\tat com.verideon.veriguard.domain.URLMonitor.monitor(URLMonitor.java:101)\n\tat com.verideon.veriguard.domain.TestURLMonitor.getPage\n(TestURLMonitor.java:58)\n\tat com.verideon.veriguard.domain.TestURLMonitor.monitorURL\n(TestURLMonitor.java:47)\n\tat com.verideon.veriguard.domain.TestURLMonitor.testMonitorURLStageCoach\n(TestURLMonitor.java:138)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke\n(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests\n(RemoteTestRunner.java:392)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run\n(RemoteTestRunner.java:276)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main\n(RemoteTestRunner.java:167)\n\nResult with telnet:\n\nGET /\nHTTP/1.1 302 Object moved\nServer: Microsoft-IIS/5.0\nDate: Tue, 01 Jul 2003 10:05:58 GMT\nX-Powered-By: ASP.NET\nLocation: http://www.stagecoach.co.uk\nConnection: Keep-Alive\nContent-Length: 121\nContent-Type: text/html\nSet-Cookie: ASPSESSIONIDCQCSRAAB=IFJJLEADOPDDNNGHLPFBIIIE; path=/\nCache-control: private\n\n<head><title>Object moved</title></head>\n<body><h1>Object Moved</h1>This object may be found <a HREF=\"\">here</a>.</body>\nConnection closed by foreign host.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-17",
        "summary": "need a way to set time out when using HttpClient and HttpMultiClient",
        "description": "When using class HttpClient or HttpMultiClient, there is no way to set the time \nout value. Because the setTimeout method is in HttpConnection and HttpClient or \nHttpMultiClient doesn't expose the HttpConnection object. One option is to add \na method setTimeout in HttpClient and HttpMultiClient. Another option is to add \nsuch a method in HttpMethod.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-933",
        "summary": "All implementations of SchemeSocketFactory.createSocket(HttpParams params) ignore the params",
        "description": "Only TestTSCCMWithServer.StallingSocketFactory.createSocket(HttpParams params) ever uses the HttpParams parameter.\n\nAll non-test implementations of the method ignore the parameter.\n\nNot sure why this version of the method exists if the parameter is never used - the parameterless method from SocketFactory could be used instead.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-290",
        "summary": "MS Proxy with NTLM authentication set up does not work",
        "description": "When I try to go via a MS Proxy which is set up with NTLM authentication I\nalways get a \"407\" error, no matter which credentials used.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-406",
        "summary": "Releasing a connection is unconfirmed",
        "description": "When a connection is attempted to be released using\nHttpConnection.releaseConnection(), it is unclear whether this is actually done.\nThe implementation for the method is as follows in 3.0-beta1:\n\n    /**\n     * Release the connection.\n     */\n    public void releaseConnection() {\n        LOG.trace(\"enter HttpConnection.releaseConnection()\");\n        if (locked) {\n            LOG.debug(\"Connection is locked.  Call to releaseConnection() ignore\n        } else if (httpConnectionManager != null) {\n            LOG.debug(\"Releasing connection back to connection manager.\");\n            httpConnectionManager.releaseConnection(this);\n        } else {\n            LOG.warn(\"HttpConnectionManager is null.  Connection cannot be relea\n        }\n    }\n\nSilently ignoring a request (to release the connection, in this case) is hardly\never the right thing to do, in my opinion. Instead, I suggest the method\nindicates whether the connection was actually closed or not.\n\nI see at least 2 alternatives:\n\n1) throw an exception to indicate the connection could not be released;\n2) return a flag indicating whether the connection could actually be released.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-977",
        "summary": "provide a memcached implementation for HttpCache",
        "description": "The feature here would be an implementation of the HttpCache interface that stored cache entries in memcached.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "HTTPCLIENT-986",
        "summary": "cache module does not completely handle upstream Warning headers correctly",
        "description": "There are a couple of MUST requirements from the RFC for Warning headers that aren't correctly handled by the current implementation:\n\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.46\n\n1. \"However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for specific Warning codes. It MUST then add any Warning headers received in the validating response.\"\n\n2. \"If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it. (This prevents bad consequences of naive caching of Warning header fields.) If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well.\" ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-384",
        "summary": "3.0 not compile-time compatible with 2.0 library usage",
        "description": "To my surprise Oleg says this was the intent, yet the Jakarta-Slide webdavclient\nlibraries do not compile out of the box.  Patch for that issue to follow.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-257",
        "summary": "NTLM class registers Sun JCE implementation by default",
        "description": "Currently the NTLM class attempts to load and register the Sun JCE implementation unless a \nSystem property is set to indicate a different JCE to use.  We should remove this entirely and leave \nthe installation and configuration of the JCE to the application rather than trying to do it ourselves \nas this could cause problems with other implementations of JCE.  I'll attach an initial patch for this \nin a moment, with a patch for the documentation in the morning.  (Writing docs at 1am is never a \ngood idea.)",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-733",
        "summary": "Implementation of Delete method",
        "description": "The HTTP request method, Delete, had not been implemented. I needed it and created an HttpDelete class modeled after HttpGet.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "HTTPCLIENT-582",
        "summary": "Allow access to registered cookie policies",
        "description": "It would be useful for JMeter (and perhaps other applications) to have access to the list of registered Cookie policy names.\n\n[If this is acceptable, let me know if you want me to provide a patch.]",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1139",
        "summary": "NTLM Authentication No Longer Working In Latest Release",
        "description": "Our application has been working fine using NTLM auth with HttpClient for 3 years.   We were most recently on 4.0.3.    Upon upgrading to 4.1.2, NTLM stopped working.\n\nI tried both the new for 4.1 built-in NTLM and the \"old way\" of using JCIFS: client.getAuthSchemes().register(\"ntlm\", new NTLMSchemeFactory()); \n\nUsing wireshark I can see that NTLM auth is not even attempted using 4.1.2.    Rolling back to 4.0.3 immediately resolved this problem.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-754",
        "summary": "BasicClientCookie.toString() contains 'name' instead of 'value' when writing out cookie value",
        "description": "{noformat}\nbuffer.append(\"[name: \");\nbuffer.append(this.value);\n{noformat}\n\nshould be\n\n{noformat}\nbuffer.append(\"[value: \");\nbuffer.append(this.value);\n{noformat}\n\nWill provide a patch soon.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-281",
        "summary": "DefaultHttpParamsFactory violates applet sandbox",
        "description": "The DefaultHttpParamsFactory in nightly build 20031009 makes two calls to \nSystem.getProperties().  This is by default verboten in an applet.  I have \npatched the source to catch the security exceptions and set the properties to a \ndefault value.  My modified code block follows:\n\n        // TODO: To be removed. Provided for backward compatibility\n        try {\n          String agent = System.getProperties().getProperty\n(\"httpclient.useragent\");\n          if (agent != null) {\n            params.setParameter(HttpMethodParams.USER_AGENT, agent);\n          }\n        }\n        catch (SecurityException dontCare) { }\n\n        // TODO: To be removed. Provided for backward compatibility\n        try {\n          String preemptiveDefault = System.getProperties()\n              .getProperty(\"httpclient.authentication.preemptive\");\n          if (preemptiveDefault != null) {\n            preemptiveDefault = preemptiveDefault.trim().toLowerCase();\n            if (preemptiveDefault.equals(\"true\")) {\n              params.setParameter\n(HttpClientParams.PREEMPTIVE_AUTHENTICATION, \"on\");\n            }\n            else if (preemptiveDefault.equals(\"false\")) {\n              params.setParameter\n(HttpClientParams.PREEMPTIVE_AUTHENTICATION, \"off\");\n            }\n          }\n        }\n        catch(SecurityException dontCare) { }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-495",
        "summary": "DefaultHttpMethodRetryHandler does not check whether the failed method has been aborted",
        "description": "DefaultHttpMethodRetryHandler does not check whether the failed method has been\naborted.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-597",
        "summary": "MultithreadedConnectionManager and IdleConnectionTimeoutThread improvements",
        "description": "Changes to MultithreadedConnectionManager and IdleConnectionTimeoutThread following the suggestions of Balazs SZ\u00dcCS.\n\n\n-------- Forwarded Message --------\nFrom: SZ\u00dcCS Balazs <Balazs.Szuecs@wave-solutions.com>\nReply-To: HttpClient User Discussion\n<httpclient-user@jakarta.apache.org>\nTo: 'HttpClient User Discussion' <httpclient-user@jakarta.apache.org>\nSubject: RE: MultithreadedConnectionManager pooling strategy\nDate: Mon, 15 May 2006 15:26:08 +0200\n\nHello,\n\nI made two changes to the HttpClient code:\n\n1) in the class ConnectionPool in the method getFreeConnection( ... ) I\nchanged freeConnections.removeFirst() to freeConnections.removeLast(). Now\nthe container for free connections behaves as a stack rather than a queue.\n\n2) additionally I changed the IdleConnectionTimeoutThread, in the run()\nmethod I added connectionManager.deleteClosedConnections() so that the pool\nsize is maintained correctly.\n\nWhat do you think?\nBalazs",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-882",
        "summary": "Auth state is not correctly maintained if a successful NTLM authentication results in a redirect",
        "description": "HttpClient fails to update the auth state correctly if a successful NTLM authentication results in a redirect response. Reported by Valentin Popov <valentin.po at gmail.com>",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-860",
        "summary": "DefaultRequestDirector converts redirects of PUT/POST to GET for status codes 301, 302, 307",
        "description": "The DefaultRequestDirector treats redirect requests created by all redirect status codes (HttpStatus.SC_MOVED_TEMPORARILY: , HttpStatus.SC_MOVED_PERMANENTLY, HttpStatus.SC_SEE_OTHER, HttpStatus.SC_TEMPORARY_REDIRECT) the same, converting PUT/POST methods to GET.  The HttpClient Tutorial even documents this as being in accordance with the specification, but I don't believe that's true.\n\nPer the RFC (http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html), conversion of PUT/POST to GET is appropriate only for 303 (See Other).  The others do not suggest this behavior.  In fact, the following notes attached to them call it out as incorrect.\n\n301 (Moved Permanently) has this note:\n\n      Note: When automatically redirecting a POST request after\n      receiving a 301 status code, some existing HTTP/1.0 user agents\n      will erroneously change it into a GET request.\n\nAnd 302 (Found) say this:\n\n      Note: RFC 1945 and RFC 2068 specify that the client is not allowed\n      to change the method on the redirected request.  However, most\n      existing user agent implementations treat 302 as if it were a 303\n      response, performing a GET on the Location field-value regardless\n      of the original request method. The status codes 303 and 307 have\n      been added for servers that wish to make unambiguously clear which\n      kind of reaction is expected of the client.\n\nThe currently implemented behavior is causing problems with interacting with Central Authentication Service protected resources, among other things.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-617",
        "summary": "Hostname verification:  turn off wildcards when CN is an IP address",
        "description": "Hostname verification:   turn off wildcards when CN is an IP address.  This is a further improvement on HTTPCLIENT-613 and HTTPCLIENT-614.\n\nExample - don't allow:\nCN=*.114.102.2\n\nI'm thinking of grabbing the substring following the final dot, and running it through \"Integer.parseInt()\".  If the NumberFormatException isn't thrown (so Integer.parseInt() actually worked!), then I'll turn off wildcard matching.  Notice that this won't be a problem with IP6 addresses, since they don't use dots.  It's only a problem with IP4, where the meaning of the dots clashes with dots in domain names.\n\nNote:  when I turn off wildcard matching, I still attempt an exact match with the hostname.  If through some weird mechanism the client is actually able to use a hostname such as \"https://*.114.102.2/\", then they will be okay if that's what the certificate on the server contains.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-748",
        "summary": "make SchemeRegistry friendlier for DI frameworks",
        "description": "Scheme's in SchemeRegistry are registered via 'register' method, but there is no way to pass it a set of schemes so those can be registered in one step. This way it can be externally configured and 'spring/guice friendly'... something like this is sufficient...\n\npublic void setSchemes (final Set <Scheme> schemes) {\n    for (final Scheme scheme : schemes) \n        register(scheme);    \n}\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1057",
        "summary": "wrong class name in statemgmt.xml",
        "description": "\"BasicClientCookie\" should read \"BasicCookieStore\", see the patch for details",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-462",
        "summary": "ProtocolException thrown on slightly broken headers",
        "description": "HTTPClient throws an exception when parsing headers returned by GET from the\nfollowing URL:\n\n http://butler.cit.nih.gov/hembase/hembase.taf\n\nThe headers returned are as follows:\n\nHTTP/1.0 200 OK\\r\\nServer: WebSTAR/1.0 ID/ACGI\\r\\nMIME-Version:\n1.0\\r\\nContent-Type: text/html\\r\\nSet-Cookie:\nTango_UserReference=ADC5871C57FABEDEC63DD47B; path=/\\n\\r\\r\\n\\r\\n<!DOCTYPE HTML\nPUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">...\n\nPlease note the superfluous \\r in the line separating headers from the body.\nIMHO this type of error should generate a warning, but then it should cause a\ngraceful recovery. Currently a ProtocolException is thrown.\n\nStandard java.net.HttpURLConnection handles this just fine, without giving any\nwarning.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-377",
        "summary": "[API Doc] HttpClient tutorial update",
        "description": "Bring the tutorial up to date with the latest best practices",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-833",
        "summary": "SSLSocketFactory.connectSocket() possible NPE - or use of wrong variable?",
        "description": "SSLSocketFactory.connectSocket() has a possible NPE at line 324:\n\n            sock.connect(remoteAddress, connTimeout);\n\nOr perhaps this should really be:\n\n            sslsock.connect(remoteAddress, connTimeout);",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-805",
        "summary": "Pass ClientConnectionManager to DefaultHttpClient constructor",
        "description": "Copied from my mailing list post, Oleg suggested I post it to JIRA for 4.1 fix.\n\nI'm trying to find the least verbose way of configuring a DefaultHttpClient with a ThreadSafeClientConnManager.\n\nThe example code given for this goes through a manual process of configuring HttpParams and SchemeRegistry objects, which is more or less copied from the DefaultHttpClient.createHttpParams() and createClientConnectionManager() methods.\n\nIt's a bit of a chicken and egg situation - DefaultHttpClient can create its own HttpParams and SchemeRegistry, which are themselves fine, but only once its been constructed, and the constructor requires the ThreadSafeClientConnManager, but that in turn requires the HttpParams and SchemeRegistry objects.  The only way out is to manually construct the HttpParams and SchemeRegistry, which is a waste.\n\nIt seems to me that DefaultHttpClient's constructor should take a ClientConnectionManagerFactory instead of a ClientConnectionManager. That way, the createClientConnectionManager() method already has the factory reference, and doesn't have to grub around in the HttpParams object to find it.\n\nThe code would then become:\n\nnew DefaultHttpClient(new ThreadSafeClientConnManagerFactory(), null);\n\nwhere ThreadSafeClientConnManagerFactory.newInstance() just constructs ThreadSafeClientConnManager.  There's no manual construction of HttpParams and SchemeRegistry, you just leave it up to DefaultHttpClient.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1026",
        "summary": "Properly close resources",
        "description": "Java has exceptions so resources must always be closed on a finally clause",
        "label": "NUG",
        "classified": "TASK",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-275",
        "summary": "problem with isIPv4address() for relative uri's",
        "description": "the following block of code:\n\ntry {\n\tURI uri = new URI(\"http://10.0.1.10:8830\");\n\tSystem.out.println(\"is IP=\"+uri. isIPv4address());\n\turi = new URI(uri, \"/04-1.html\");\n\tSystem.out.println(\"is IP=\"+uri. isIPv4address());\n} catch (URIException e) { ; }\n\nreturns the output:\n\nis IP=true\nis IP=false\n\nso by being created from a relative uri URI objects don't have the right setting of  isIPv4address().",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-242",
        "summary": "Add InputStream buffering.",
        "description": "Currently HttpClient does not buffer the InputStream received from the socket. \nPerhaps doing so would improve performance.\n\nReported by Tony Bigbee.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-502",
        "summary": "HttpConnection isOpen flag concurrency problem",
        "description": "The HttpConnection.java class contains an isOpen boolean used to track the state\nof the connection (opened or closed).  The problem is that in the\ncloseSocketAndStreams(), the flag is only flipped at the end of the\nunsynchronized method (after resources have been released) which causes a\nconcurrency issue in flushRequestOutputStream() where the flag is checked first\nand the the outputStream is accessed.\n\nI'm providing a patch for this problem.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-679",
        "summary": "URI Absolutization does not follow browser behavior",
        "description": "This was encountered using Heritrix to crawl a prominent website.\n\nThe URI resulting from the HttpClient URI constructor (base, relative) does not follow browser behavior:\nURI newUrl = new URI(new URI(\"http://www.theirwebsite.com/browse/results?type=browse&att=1\"), \"?sort=0&offset=11&pageSize=10\")\n\nResults in newUrl:\nhttp://www.theirwebsite.com/browse/?sort=0&offset=11&pageSize=10\n\nThe desired behavior based on Firefox and IE should be:\nhttp://www.theirwebsite.com/browse/results?sort=0&offset=11&pageSize=10\n\nThese browsers treat the question mark similar to a directory separator and do not require a file to be specified before the query.\n\nHttpClient's current behavior does not correspond to current browser behavior and leads to an inability to crawl certain websites if HttpClient's URI class is used.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-112",
        "summary": "HttpClient incorrectly handles Transfer-Encoding header",
        "description": "RFC2616, section 4.4 item 3 states:\n     If a Content-Length header field (section 14.13) is present, its\n     decimal value in OCTETs represents both the entity-length and the\n     transfer-length. The Content-Length header field MUST NOT be sent\n     if these two lengths are different (i.e., if a Transfer-Encoding\n     header field is present). If a message is received with both a\n     Transfer-Encoding header field and a Content-Length header field,\n     the latter MUST be ignored.\n\nThis is not handled correctly in the case that a noncompliant HTTP server\nreturns both a Transfer-Encoding header and a Content-Length header.\n\nI gave up on writing a TestCase for this as it would require a reliably\nnoncompliant HTTP Server.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-349",
        "summary": "Credentials ignored if realm specified in preemptive authentication",
        "description": "When you specifiy credentials for a specific realm using preemptive \nauthentication, the credentials are ignored during the first try (error 401 \nback).\n\n...\nHttpClient client = new HttpClient(manager);\nclient.getState().setCredentials(\"myRealm\",\"myHost\",\n\t\t\tnew UsernamePasswordCredentials(\n\t\t\t\t\"user\",\"password\"));\nclient.getState().setAuthenticationPreemptive(true); \n...\n\n\"myRealm\" will be ignored in HttpState's matchCredentials() private method \nbecause during preemptive authentication, it is called with a null realm:\n\n private static Credentials matchCredentials(HashMap map, String realm, String \nhost) {\n        HttpAuthRealm entry = new HttpAuthRealm(host, realm);\n\t// no possible match here, map only contains the version with the realm\n        Credentials creds = (Credentials) map.get(entry);\n        if (creds == null && host != null && realm != null) {\n            entry = new HttpAuthRealm(host, null);\n            creds = (Credentials) map.get(entry);\n            if (creds == null) {\n                entry = new HttpAuthRealm(null, realm);\n                creds = (Credentials) map.get(entry);\n            }\n        }\n        if (creds == null) {\n            creds = (Credentials) map.get(DEFAULT_AUTH_REALM);\n        }\n        return creds;\n    } \n\nThis is quite logical since the realm comes from the server and you don't \ncontact the server first during preemptive authentication.\n\nBut, it should not be possible to set a realm when using preemptive mode, or at \nleast it should not be silently ignored.\n\nThe current workaround is to set the realm to null in setCredential(), no \nelegant but works.\n\nRegards,\n\nPhilippe",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-185",
        "summary": "Ordering of methods in PostMethod changes behaviour",
        "description": "I have just spent the best part of two days trying to work out why\na servlet running in Tomcat was not getting UTF-8 when I had set my\nclient to send UTF-8. It turns out that if I set my PostMethod request\nheader after setting the request body the content does not get sent as\nUTF-8.\n\nThe following gets sent as UTF-8:\n\n      PostMethod post = new PostMethod(destinationUrl.toString());\n      post.setStrictMode(false);\n      post.setRequestHeader(\"Content-Type\",\"text/xml; charset=UTF-8\");\n      post.setRequestHeader(\"user-agent\", \"myAgent\");\n      post.setRequestBody(content);\n      post.setFollowRedirects(true);\n\nthe following doesn't:\n\n      PostMethod post = new PostMethod(destinationUrl.toString());\n      post.setStrictMode(false);\n      post.setRequestBody(content);\n      post.setRequestHeader(\"Content-Type\",\"text/xml; charset=UTF-8\");\n      post.setRequestHeader(\"user-agent\", \"myAgent\");\n      post.setFollowRedirects(true);\n\nIn a live execution I would understand that order makes a big difference, but\nwhen you fill out an object that feels like defining the values of a Java Bean\nthis likely to be less obvious.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-162",
        "summary": "Realm from authentication challenge unavailable",
        "description": "There is currently no way to extract the authentication realm from HttpClient \nexcept to extract the authentication challenge header and parse it manually.\n\nEither the realm needs to be available to the client or a method in \nAuthenticator should extract the realm from a given authentication header.\n\nThe same problems occurs with determining which type of authentication is \nbeing used and what other options there are (basic, digest, NTLM, others).",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-718",
        "summary": "SSL verification occurs before setSoTimeout, which can lead to hangs",
        "description": "partial thread dump:\n\n       at java.net.SocketInputStream.socketRead0(Native Method)\n       at java.net.SocketInputStream.read(SocketInputStream.java:129)\n       at com.sun.net.ssl.internal.ssl.InputRecord.readFully(InputRecord.java:293)\n       at com.sun.net.ssl.internal.ssl.InputRecord.read(InputRecord.java:331)\n       at com.sun.net.ssl.internal.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:723)\n       - locked <0x00002aaab87d9de0> (a java.lang.Object)\n       at com.sun.net.ssl.internal.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1030)\n       - locked <0x00002aaab87d9dc0> (a java.lang.Object)\n       at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1057)\n       at com.sun.net.ssl.internal.ssl.SSLSocketImpl.getSession(SSLSocketImpl.java:1757)\n       at org.apache.http.conn.ssl.AbstractVerifier.verify(AbstractVerifier.java:87)\n       at org.apache.http.conn.ssl.SSLSocketFactory.connectSocket(SSLSocketFactory.java:295)\n       at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:131)\n       at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:143)\n       at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:120)\n       at org.apache.http.impl.client.DefaultClientRequestDirector.execute(DefaultClientRequestDirector.java:286)\n       at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:452)\n       at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:406)\n       at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:365)\n\n\n... this is because in DefaultClientConnectionOperator, prepareSocket (which sets any configured timeouts) isn't called until after SocketFactory.connectSocket. When using SSLSocketFactory, the default behavior is to verify the hostname, which opens a connection, and can block indefinitely.\n\nSimple workaround is to use the AllowAllHostnameVerifier which doesn't do any verification.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-601",
        "summary": "SecureProtocolFactoryWrapper class for using the socket factory created by Java Web Start",
        "description": "As smartcards and SSL are becoming more and more prevelant, Java Web Start has started to become better equiped to handle these situations.  When running an app within webstart, it can access the browser's keystore, which (at least in our case) accessed the users smartcard to make the SSL connection.\n\nI wanted to start using HttpClient, but needed a way to do so while still mainaining access to the browser's keystore.\n\nMy initial tests show that getting the default socket factory from the java.net.HttpURLConnection and wrapping it in a class that implements org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory is sufficient.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "HTTPCLIENT-688",
        "summary": "HttpOptions.getAllowedMethods expects single Allow header",
        "description": "In client.methods.HttpOptions.getAllowMethods(), a single Allow header is parsed to obtain the result. Since the value is a comma-separated list, servers can optionally return the values in multiple headers. HttpMethod.getHeaders(name) should be used instead of .getFirstHeader(name).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-166",
        "summary": "waitForResponse is using busy wait",
        "description": "In HttpConnection, the method waitForResponse is using busywait, instead of \nblocking until the response is arriving.\n\nIs this on purpose, or shouldn't it handle this by blocking instead ??",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-184",
        "summary": "org.apache.commons.httpclient.HeaderElement fail to parse cookie header",
        "description": "if Set-Cookie header has value such \"expires=Mon, ..\".\norg.apache.commons.httpclient.HeaderElement will fail to parse this header.\n\nCause:\nIn the source cord:\n-------------\n            try {\n                /*\n                 * Following to RFC 2109 and 2965, in order not to conflict\n                 * with the next header element, make it sure to parse tokens.\n                 * the expires date format is \"Wdy, DD-Mon-YY HH:MM:SS GMT\".\n                 * Notice that there is always comma(',') sign.\n                 * For the general cases, rfc1123-date, rfc850-date.\n                 */\n                if (tokenizer.hasMoreTokens()) {\n                    String s = nextToken.toLowerCase();\n                    if (nextToken.endsWith(\"mon\") \n                        || s.endsWith(\"tue\")\n                        || s.endsWith(\"wed\") \n                        || s.endsWith(\"thu\")\n                        || s.endsWith(\"fri\")\n                        || s.endsWith(\"sat\")\n                        || s.endsWith(\"sun\")\n                        || s.endsWith(\"monday\") \n                        || s.endsWith(\"tuesday\") \n---- snip ---\n \n\"if (nextToken.endsWith(\"mon\") \" is wrong.\nthis must be \"if (s.endsWith(\"mon\") \".\n\nSource cord version:\n * $Header:\n/home/cvspublic/jakarta-commons/httpclient/src/java/org/apache/commons/httpclient/HeaderElement.java,v\n1.17 2003/03/08 21:30:02 olegk Exp $\n * $Revision: 1.17 $\n * $Date: 2003/03/08 21:30:02 $",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-346",
        "summary": "Cookies with names containing blanks or starting with $ should be rejected by RFC2109 spec only",
        "description": "Reported by John Patterson:\n\n> The Cookie class does not like names with spaces in them.  It throws an\n> IllegalArgumentException.  Unfortunately the server that my app interacts\n> with uses a space in the cookie name.  Both IE and Mozilla don't mind.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-961",
        "summary": "not all applicable URIs are invalidated on PUT/POST/DELETEs that pass through client cache",
        "description": "\"Some HTTP methods MUST cause a cache to invalidate an entity. This is either the entity referred to by the Request-URI, or by the Location or Content-Location headers (if present). These methods are: PUT, DELETE, POST.\"\n\nhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.10\n\nThe current caching implementation only invalidates the Request URI, and not those present in the Location or Content-Location headers on the request.\n\nI have a patch that fixes this which I will upload momentarily.\n",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-795",
        "summary": "If there is more than 15 seconds between HttpClient.execute() calls using a MultipartEntity, a ProtocolException is thrown complaining about the Content-Length header already being present.",
        "description": "I am not sure if this time-related behaviour is intentional or not (I have only been using this library for a few weeks) , but even if a timeout is to be expected, the exception thrown ought to indicate that there is a time component involved. \"org.apache.http.ProtocolException: Content-Length header already present\" is incredibly misleading. \n\nA simple-ish compileable program to reproduce the bug is as follows:\n\nimport java.nio.charset.Charset;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.params.ClientPNames;\nimport org.apache.http.client.params.CookiePolicy;\nimport org.apache.http.entity.mime.MultipartEntity;\nimport org.apache.http.entity.mime.content.StringBody;\nimport org.apache.http.impl.client.DefaultHttpClient;\npublic class Simple {\n    static public void main(String [] args)\n    {\n        try\n        {\n            DefaultHttpClient client = new DefaultHttpClient();\n            client.getParams().setParameter(\n                        ClientPNames.COOKIE_POLICY, CookiePolicy.BROWSER_COMPATIBILITY);\n            MultipartEntity entity;\n            StringBody stringBody;\n            HttpPost post;\n            HttpResponse response;\n            entity = new MultipartEntity();\n            stringBody = new StringBody(\"field contents\",Charset.forName(\"ISO-8859-1\"));\n            entity.addPart(\"field\", stringBody);  \n            post = new HttpPost(\"http://localhost/simple.php\");\n            post.setEntity(entity); \n            response = client.execute(post);\n            \n            //The exception does not occur if the content is not consumed\n            response.getEntity().consumeContent();\n            System.out.println(\"First post done\");\n            \n            //The exception does not occur if the time interval between the requests is too short\n            Thread.sleep(15000);\n            \n            //The exception naturally doesn't occur if a new HttpClient is created\n            //client = new DefaultHttpClient();\n\n            entity = new MultipartEntity();\n            stringBody = new StringBody(\"field contents\",Charset.forName(\"ISO-8859-1\"));\n            entity.addPart(\"field\", stringBody);  \n\n            post = new HttpPost(\"http://localhost/simple.php\");\n            post.setEntity(entity); \n            response = client.execute(post); //Will throw the following:\n            /*\n                org.apache.http.ProtocolException: Content-Length header already present\n                at org.apache.http.protocol.RequestContent.process(RequestContent.java:70)\n                at org.apache.http.protocol.BasicHttpProcessor.process(BasicHttpProcessor.java:290)\n                at org.apache.http.protocol.HttpRequestExecutor.preProcess(HttpRequestExecutor.java:160)\n                at org.apache.http.impl.client.DefaultClientRequestDirector.execute(DefaultClientRequestDirector.java:356)\n                at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:501)\n                at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:456)\n                at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:422)\n                at test.Simple.main(Simple.java:57)\n             */ \n            System.out.println(\"Second post done\");\n        }\n        catch(Exception e)\n        {\n            System.out.println(e);\n            e.printStackTrace();\n        }\n    }    \n}",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-30",
        "summary": "should allow receiving secure cookies from non-secure chanel",
        "description": "Currently, httpclient will throw an exception if a secure cookie is received \nfrom a non-secure chanel. Although RFC doesn't specify explicitly on if the \nclient should allow receiving secure cookie from non-secure channel, the \ndefault setting in browser seems to allow it.\n\nTry the following link in IE:\n\nhttp://www.snapfish.com\n\nThe default cookie policy in httpclient should be the same.",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-253",
        "summary": "Javadocs clean-up",
        "description": "Before Httpclient can be released Javadocs need to be updated and proof-read",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-937",
        "summary": "Make CacheEntry use an immutable object to represent cache content ",
        "description": "Make CacheEntry use an immutable object to represent cache content similar to HttpEntity",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-984",
        "summary": "additional conditional compliance tests for the caching module for Content-Encoding, Content-Location, Date, Expires, Server, Transfer-Encoding, and Vary headers",
        "description": "Patch is forthcoming.",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "HTTPCLIENT-1134",
        "summary": "BasicResponseHandler Javadoc Needs Clarification",
        "description": "The class-level javadoc for BasicResponseHandler indicates that it reads the response body before throwing an Exception for responses with status code >= 300, which is not the case.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-379",
        "summary": "JVM bug 4949631 causes BufferOverflowException in HttpMethodBase.getResponseBodyAsString",
        "description": "ava.nio.BufferOverflowException\n        at java.nio.charset.CoderResult.throwException(CoderResult.java:259)\n        at java.lang.StringCoding$CharsetSD.decode(StringCoding.java:188)\n        at java.lang.StringCoding.decode(StringCoding.java:224)\n        at java.lang.String.<init>(String.java:320)\n        at\norg.apache.commons.httpclient.HttpConstants.getContentString(HttpConstants.java:199)\n        at\norg.apache.commons.httpclient.HttpConstants.getContentString(HttpConstants.java:233)\n        at\norg.apache.commons.httpclient.HttpMethodBase.getResponseBodyAsString(HttpMethodBase.java:735)\n\n\nThis seems to be caused by a known JVM bug:\nhttp://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4949631\n\nStrings over 16Mb can cause the problem.   Some workarounds are listed, the\nessence being to split the string and call getBytes on each piece and reassemble\nwith a ByteBuffer.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-813",
        "summary": "HttpClient throws NPE on Invalid Port when used with MultiThreadedHttpConnectionManager",
        "description": "The HttpClient throws NullPointerException in the main thread when an invalid port (like 80001) is used in the URL. An IllegalArgumentException is thrown in TimeoutGuard thread.\n \nException in thread \"Timeout guard\" java.lang.IllegalArgumentException: port out of range:80001\n\tat java.net.InetSocketAddress.<init>(InetSocketAddress.java:118)\n\tat java.net.Socket.<init>(Socket.java:240)\n\tat org.apache.commons.httpclient.protocol.DefaultProtocolSocketFactory.createSocket(DefaultProtocolSocketFactory.java:80)\n\tat org.apache.commons.httpclient.protocol.ControllerThreadSocketFactory$1.doit(ControllerThreadSocketFactory.java:91)\n\tat org.apache.commons.httpclient.protocol.ControllerThreadSocketFactory$SocketTask.run(ControllerThreadSocketFactory.java:158)\n\tat java.lang.Thread.run(Thread.java:613)\nException in thread \"main\" java.lang.NullPointerException\n\tat org.apache.commons.httpclient.HttpConnection.open(HttpConnection.java:721)\n\tat org.apache.commons.httpclient.MultiThreadedHttpConnectionManager$HttpConnectionAdapter.open(MultiThreadedHttpConnectionManager.java:1361)\n\tat org.apache.commons.httpclient.HttpMethodDirector.executeWithRetry(HttpMethodDirector.java:387)\n\tat org.apache.commons.httpclient.HttpMethodDirector.executeMethod(HttpMethodDirector.java:171)\n\tat org.apache.commons.httpclient.HttpClient.executeMethod(HttpClient.java:397)\n\tat org.apache.commons.httpclient.HttpClient.executeMethod(HttpClient.java:323)\n\tat com.aol.test.HttpTest$PoolingHttpConnector.doGet(HttpTest.java:47)\n\tat com.aol.test.HttpTest.main(HttpTest.java:17)\n\nIt should throw a checked exception in main thread so caller can handle the error condition more gracefully.\n\nThe test program is attached. This is caused by a race condition and it's not always reproducible. Running in debugger shows a different behavior.\n\npackage com.aol.test;\n\nimport java.io.IOException;\n\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.params.HttpConnectionManagerParams;\n\npublic class HttpTest {\n\t\n\tpublic static void main(String[] args) {\n\t\tPoolingHttpConnector conn = new PoolingHttpConnector();\n\t\t\n\t\ttry {\n\t\t\tString response = conn.doGet(\"http://www.aol.com:80001\");\n\t\t\tSystem.out.println(\"Response='\" + response + \"'\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\n\tstatic class PoolingHttpConnector {\n\t\t\n\t\tpublic static final int MAX_TOTAL_CONNECTIONS = 16;\n\t\tpublic static final int MAX_CONNECTIONS_PER_HOST = 8;\n\t\tpublic static final int CONNECT_TIMEOUT = 5000;\n\t\tpublic static final int SOCKET_TIMEOUT = 5000;\n\t\tpublic static final boolean TCP_NO_DELAY = true;\n\t\t\n\t    private static MultiThreadedHttpConnectionManager poolManager;\n\t    private static HttpConnectionManagerParams httpParams;\n\t    private static HttpClient httpClient;\n\t    private static boolean initialized = false;\n\t    \n\t\tpublic PoolingHttpConnector() \n\t\t{\n\t\t\tinitialize();\n\t\t}\n\n\t\tpublic String doGet(String url) throws IOException {\n\t\t\tGetMethod method = new GetMethod(url);\n\t\t\t\t\t\n\t\t\ttry {\n\t            int status = httpClient.executeMethod(method);\t            \n\t\t        String response = new String(method.getResponseBody());\n\t            \n\t            if (status != HttpStatus.SC_OK)\n\t            \tthrow new IOException(\"HTTP error: \" + response);\n\t            \n\t            return response;\n\t            \n\t\t\t} finally {\n\t            method.releaseConnection();\n\t\t\t}\n\t \t} \t\n\t\n\t\tprivate synchronized void initialize() {\t\n\t\t\tif (initialized)\n\t\t\t\treturn;\n\t\t\t\n\t        poolManager = new MultiThreadedHttpConnectionManager();\n\t        httpParams = new HttpConnectionManagerParams();\n\t        \n\t        httpParams.setMaxTotalConnections(MAX_TOTAL_CONNECTIONS);\n\t        httpParams.setDefaultMaxConnectionsPerHost(MAX_CONNECTIONS_PER_HOST);\n\t        httpParams.setTcpNoDelay(TCP_NO_DELAY);\n\t        httpParams.setSoTimeout(SOCKET_TIMEOUT);\n\t        httpParams.setConnectionTimeout(CONNECT_TIMEOUT);\n\t        \n\t        poolManager.setParams(httpParams);\n\t        httpClient = new HttpClient(poolManager);\n\n\t\t\tinitialized = true;\n\t\t}\n\t\t\n\t}\n}\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-48",
        "summary": "User interaction for authentication",
        "description": "Some actions require user input.  Like forwarding to another host or retrieveing\nauthentication credentials.  Should have some way for clients to setup listeners\nfor such events so that they can be handled on the fly.  No gui, programatic\nonly.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-168",
        "summary": "Include generated website in the distribution",
        "description": "A user should be able to build the non-api docs as well.\n\nSo it would be nice, to include xdocs in the source packages as well ...",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-667",
        "summary": "Provide BestMatch cookie policy",
        "description": "Presently HttpClient uses a single cookie policy for all target hosts, which is suboptimal for two reasons:\n(1) the user needs to know beforehand what kind of HTTP cookie support the target host provides\n(2) does not work well with multiple sites with different level of HTTP cookie support \n\nIntroduce new cookie policy that dynamically picks up a CookieSpec (browser compatibility | Netscape draft | RFC2109 | RFC2965) based on properties of the response received from the target host",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1003",
        "summary": "Handle conditional requests in cache",
        "description": "Return 304 if incoming request has \"If-None-Match\" or \"If-Modified-Since\" headers and can be served from cache.  Currently we return a 200 which is correct but not optimal.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-803",
        "summary": "SSL connections cannot be established using the IP address",
        "description": "HttpClient 4.x introduced a regression in establishing SSL connections to remote peers. The AbstractVerifier class only checks for matches in CN and SubjectAlternative->DNSName. But, when an IP (instead of a hostname) is used, the check should be done on CN and SubjectAlternative->IPAddress.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-676",
        "summary": "memory leak in MultiThreadedHttpConnectionManager",
        "description": "MultiThreadedHttpConnectionManager.getConnectionsInPool(hostConfiguration) will create HostConnectionPool entries that will not be cleaned up unless they are later used for communication. This should be changed to not create pools in that method, but rather return 0 for a non-existent pool.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-273",
        "summary": "ConnectionTimeoutException doesn't releaseConnection()",
        "description": "When a ConnectionTimeoutException is thrown, HttpConnection doesn't seem to\nrelease the connection. Instead, the connection is properly released if an\nInterruptedIOException is thrown.\n\nThis is the pattern I use:\n\nTry {\n     method.execute(...);\n     method.getResponseBodyAsString();\n } catch (ConnectionTimeoutException cte) {\n     ...\n } catch (InterruptedIOException ioe) {\n     ...\n } finally {\n     method.releaseConnection();\n     LOG.info(\"RELEASED\");   \n }\n\nThe following log shows that no actual release is performed, while the message\n\"RELEASED\" is logged.\n\n10544  DEBUG [MainCheck2] httpclient.HttpConnection - enter\nHttpConnection.isResponseAvailable(int)\n10930  WARN  [MainCheck1] httpclient.HttpConnection - The host\nwww.pccomputing.com:80 (or proxy null:-1) did not accept the connection within\ntimeout of 3000 milliseconds\n10931  WARN  [MainCheck1] CheckPerformer - Connection Timeout occurred..\norg.apache.commons.httpclient.HttpConnection$ConnectionTimeoutException\nat org.apache.commons.httpclient.HttpConnection.open(HttpConnection.java:659) \n...\nat PersistenceCheck$MainCheck.run(PersistenceCheck.java:306)\n10932  INFO  [MainCheck1] CheckPerformer - RELEASED\n\n->Here no call to HttpConnection.releaseConnection() is performed. \n\nThanks",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-436",
        "summary": "Retry on ConnectionException does not work",
        "description": "I noticed that the Retry handler mechanism does not work when the client cannot\ninitiate a connection (which throws java.net.ConnectionException). This happens\nfor me for instance when there is proxy and a tunneling in the picture and\nsometimes there are connectivity problems.\n\nI had my own RetryHandler, however, the Connection Timeout exception never falls\nin it. I took a look at the source code and noticed that the open() method and\nany thrown exception at this level occurs outside the control of the Retry\nHandler (which seems to be involved only after open() succeeds).\n\nIn fact, if the open() throws ConnectionException (as is my case), since the\ntry/catch wrapping the open() is not inside the while() but on top of it, it\nstops the loop and the retry handler does not get a chance to be invoked .\n\nriad",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-192",
        "summary": "Duplicate request headers when connect through proxies",
        "description": "When negotiating proxy servers or during write-failure retries, the httpClient \nadds duplicate request headers to each retry.  The result is that each header \nis duplicated multiple times (number of retries).  This only impact the headers \nthat allow multiple values (the others were prevented byt the code).  In  \nParticular, it affects \"cookie\" header.  It happens more often when going \nthrough proxy server with tunnelling connections (https), but also happens on \nhttp on NTLM proxy server (need multiple round trips to get authenticated).\n\nSteps to Reproduce:\nSetup a client application to go to a website that requires going through a \nproxy server that supports tunnelling for https connections and authenticate \nusers (Basic and/or NTLM).  The website also need to support keep-alive and \nsupport https. Initilize the HttpState with a cookie. Turn httpClient \nlogging \"wire, debug and trace\" logging on.  Set the proxy credential with \nvalid user id and password.\n\nThen run the application against any url on the website.\n\nTest Results and fixes:\n1. When connect to https through a (Netscape/Basic auth) proxy that does \nthe \"tunnelling\", the initial \"CONNECT\" adds the cookie header once.  The proxy \nreturns the 407.  Then the code will use the proxy credential to do \nthe \"CONNECT\" again.  After successful connection (200), the code will do the \nproper \"POST\".  The httpClient code adds the same cookie one more time in here.\n\nThis case was caused by the wrapper class ConnectMethod using the wrapped \nmethod \"addRequestHeaders\" to build headers for the \"CONENCT\".  It can be fixed \nby having the ConnectMethod only adds headers it needs (\"addHostRequestHeader\" \nand \"addProxyAuthorizationRequestHeader\").\n\n2. When connect to http through proxy.  The client first sends a \"POST\" without \nproxy credentials, and gets a 407 back.  The cookie header is added before that \nhappens.  Then (loop in the HttpMethodBase.execute) the client will retry \nthe \"POST\" with the credentials (the logic require to have a response header to \nsubmit credentials).  In the retry, the cookie is added again \n(addRequestHeaders is called inside the writeRequest).\n\n3. When using kee-alive with no-proxy on http, if the connection times out, the \nnext call of the method will get a socket error on write.  The retry loop in \nthe processRequest method will retry the request again.  It will add the cookie \nagain.  To deal with both case 2 and 3, the addRequestHeadres call need to be \nmoved up to the beginning of the HttpMethodBase.execute.  We tested this \napproach and it worked for us.\n\n4. When negotiating NTLM proxy for https, multiple round trips are needed to \nget user authenticated.  The same ConnectMethod instance is used.  So the \nadding of the proxy authenticate headers need to be done with the ConnectMethod \ninstance (vs. the wrapped method for Host header).  Otherwise, the \nAuthenticator class would not be able to find the information for \nauthenticating user.\n\n\nI will send in our suggested fixes later.\n\nBuild: This is based on 0307 nightly build.  We run into some other problems \nwhen trying the 0410 nightly build.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-655",
        "summary": "User-Agent string violates RFC",
        "description": "Our User-Agent says \"Jakarta Commons-HttpClient/3.1-rc1\". But space is a reserved character to separate individual *products* and comments according to RFC 2616, section 14.43. Jakarta is not a product. At the same time we may want to drop the Jakarta name altogether.\n\nWe should change this to something more standard like: \n\n\"Apache-HttpClient/3.1-rc1 (\"+ System.getProperty(\"os.name\") +\";\"+ System.getProperty(\"os.arch\") +\") \"+\n\"Java/\"+ System.getProperty(\"java.vm.version\") +\" (\"+ System.getProperty(\"java.vm.vendor\") +\")\"\n\nwhich renders:\n\n\"Apache-HttpClient/3.1-rc1 (Windows XP 5.1;x86) Java/1.5.0_08 (Sun Microsystems Inc.)\"\n\nSun's internal Http client uses something like \"Java/1.5.0_08\".\n\nI am completely ignoring the fact that real-world user agents use almost arbitrary strings.\nSome fine examples of misbehaviour from my private logs:\n\n\"Jakmpqes dihurxf wfyiupsc\" -- apparently somebody has to hide something...\n\"Missigua Locator 1.9\"\n\"Poodle predictor 1.0\"\n\"shelob v1.0\"\n\"ISC Systems iRc Search 2.1\"\n\"ping.blogug.ch aggregator 1.0\"\n\"http://www.uni-koblenz.de/~flocke/robot-info.txt\"  -- ...sigh\n\nI am very tempted to write a User-Agent string validator that prevents misuse of this field in HttpClient.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-512",
        "summary": "UsernamePasswordCredentials.equals(null) throws NPE",
        "description": "Steps to reproduce:\n1. new UsernamePasswordCredentials().equals(null);\n\nObserved:\nNullPointerException is thrown\n\nExpected:\nequals() returns false",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-771",
        "summary": "ConcurrentModificationException thrown in MultiThreaded code",
        "description": "Now seeing this error.  This is with default cookie settings.  Happening rarely, however the web sites we're talking to do not use cookies very much.\n\n\njava.util.ConcurrentModificationException\n        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)\n        at java.util.AbstractList$Itr.next(AbstractList.java:343)\n        at java.util.Collections$UnmodifiableCollection$1.next(Collections.java:1010)\n        at org.apache.http.client.protocol.RequestAddCookies.process(RequestAddCookies.java:152)\n        at org.apache.http.protocol.BasicHttpProcessor.process(BasicHttpProcessor.java:290)\n        at org.apache.http.protocol.HttpRequestExecutor.preProcess(HttpRequestExecutor.java:160)\n        at org.apache.http.impl.client.DefaultClientRequestDirector.execute(DefaultClientRequestDirector.java:355)\n        at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:501)\n        at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:456)\n        at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:422)\n        at com.hi5.os.Hi5RemoteContentFetcher.fetch(Hi5RemoteContentFetcher.java:279)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-951",
        "summary": "Incorrect handling of InputStreams when connecting to a server that requires authentication",
        "description": "I'm trying to upload a file to a WebDav server (mod_dav on Apache Web Server 2.2.14) that has basic (or digest, the result is the same) authentication enabled.\nI'm using the following code:\n        String url = \"http://myserver/dir/test2.gif\";\n        File file = new File(\"d:/test2.gif\");\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        HttpPut put = new HttpPut(url);\n        put.setEntity(new InputStreamEntity(new FileInputStream(file), file.length()));\n        \n        URI uri = put.getURI();\n        httpClient.getCredentialsProvider().setCredentials(new AuthScope(uri.getHost(), uri.getPort()),\n                getCredentials());\n        put.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, true);\n        HttpResponse response = httpClient.execute(put);\n        System.out.println(response.getStatusLine());\n\nWhen running the above code, I'm getting a org.apache.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity. I tested both the latest alpha & the svn head. Doing the same thing in HttpClient 3.1 worked as expected. \n\nThis could be normal, as I'm using an InputStream that is indeed not repeatable, but as I'm also using Expect: 100-Continue, the stream shouldn't have been consumed with the first connection (the one that gets a code 401 from the WebDav server), and only in the second one, when the credentials are provided.\n\nThe problem is that DefaultRequestDirector.execute doesn't take this into account and assumes that if a request has been tried once, its associated entity (if any) has been consumed.\nHere's the fix that I came up with:\nChange DefaultRequestDirector.execute so that if the wrapper is an EntityEnclosingRequestWrapper, it checks if the entity has actually been consumed before throwing a NonRepeatableRequestException. I'm using the method isStreaming() from HttpEntity, as it's the closest thing to what I was looking for. Reading the JavaDoc, it could lead to the situation where an entity has started streaming but has not yet finished, and so is not in a state where it can be used. However I don't think that's a problem as the javadoc for HttpEntity.getContent() states that it can't be called two times on a non-repeatable entity, so it's just a matter of when the request will fail.\nThis lead me to also modify InputStreamEntity (from the httpCore project) as it didn't comply with the javadoc. With these two modifications, The file upload completes successfully.\n\nI also modified:\n * TestInputStreamEntity.testBasics() (from the httpCore project) test so that it complies with getContent()'s Javadoc.\n * TestDefaultClientRequestDirector.FaultyHttpRequestExecutor because it didn't consume the entity's content.\nAll the tests from both httpCore and httpClient pass.\nI tested both InputStreamEntity and BasicHttpEntity.\n \nPlease keep in mind that I am by no means an httpClient (or http, for that matter) expert, and these modifications may have some unexpected side-effects that I did not foresee, contain plain dumb code, or whatever, so it would be great if someone could review my changes and give their opinion.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-143",
        "summary": "Better integration of the TestWebApp-HowTo into the documentation",
        "description": "The excellent webapp howto written by Olegolas needs to be integrated better\ninto httpclient documentation.  Currently it is in the docs directory as a html\nfile, but it would be better if it was in the xdocs directory as an xml file.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-303",
        "summary": "auto close idle connections",
        "description": "This has been mentioned several times on the mailing list (most recently here:\nhttp://nagoya.apache.org/eyebrowse/ReadMsg?listName=commons-httpclient-dev@jakarta.apache.org&msgNo=5191\n)\nIt is desirable for the http client to close it's connection after some\nconfigurable idle time. Failing to do so causes the server (and every TCP\nresource in between) to keep the socket open and possibly run out of resources\nunder load.\n\nThe HTTP 1.1 RFC has this to say under section 8.1.4:\nServers will usually have some time-out value beyond which they will\n   no longer maintain an inactive connection. Proxy servers might make\n   this a higher value since it is likely that the client will be making\n   more connections through the same server. The use of persistent\n   connections places no requirements on the length (or existence) of\n   this time-out for either the client or the server.\n\n   When a client or server wishes to time-out it SHOULD issue a graceful\n   close on the transport connection. Clients and servers SHOULD both\n   constantly watch for the other side of the transport close, and\n   respond to it as appropriate. If a client or server does not detect\n   the other side's close promptly it could cause unnecessary resource\n   drain on the network.\n\nThe first sentence of the 2nd paragraph is interesting: how is the client\nsupposed to do a \"graceful close\"? Does it simply mean closing the socket?\nOne possiblity may be to issue a HTTP/OPTIONS * request with a Connection:close\nheader.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-227",
        "summary": "Missing Content-Length header causes a SocketException",
        "description": "Essentially, we have an invalid HTTP server (Stellent CMS actually and we will file a bug with them), \nwhich is returning headers like:\n\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Basic \"Secure Realm\"\nConnection: keep-alive\n\nWhich is clearly missing the Content-Length header.  Now, previously HttpClient handled this \nperfectly by reading until the end of the connection (ie: treating it like it was a Connection: close), \nhowever for some reason a socket exception is being thrown and the invalid connection is added \nback into the connection pool and then every connection to the server after that thows an \nexception.\n\nSee the thread \"SocketException with invalid server\" for the full discussion of the issue.\n\nI'll attach a patch that fixes the problem.  The biggest thing to consider is the changes to the \nduplicate Connection header test cases which resolves around the question: if Connection: keep-\nalive is present but no Content-Length is provided, should the connection be closed?  The patch \nrequires the answer to be yes and I really can't see any other way to do it.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-9",
        "summary": "Null paths break the compare method",
        "description": "The compare method cannot handle the path being null",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-588",
        "summary": "relative URIs with internal double-slashes ('//') misparsed",
        "description": "URI.parseUriReference()'s heuristic for interpreting URI parts is thrown off by relative URIs which include an internal '//'. As a result, portions of the supplied relative URI (path) can be lost. \n\nFor example:\n\nURI rel = new URI(\"foo//bar//baz\");\nrel.toString();\n(java.lang.String) //bar//baz\n\nThe culprit seems to be line 1961 of URI improperly concluding that two slashes later than the beginning of 'tmp' are still indicative the URI is a 'net_path'. \n\nA possible quick fix might be to add a '!isStartedFromPath &&' to the beginning of the line 1961 test, making the line:\n\n            if (!isStartedFromPath && at + 2 < length && tmp.charAt(at + 1) == '/') {\n\n... and thus preventing the misguided authority-parsing from happening when earlier analysis already identified the current string as a strictly path-oriented URI.\n\n(It also appears the setting of the is_net_path boolean at the end of this if's block may be wrong; this code is run for hier_path URIs that are not net_paths in the 2396 syntax. For example:\n\nURI uri = new URI(\"http://www.example.com/some/page\");\nuri.isNetPath();\n (boolean) true \n\n)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-689",
        "summary": "stackable parameters",
        "description": "Implement \"stackable parameters\" to allow for a parameter hierarchy without linking params instances.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1034",
        "summary": "Add link to \"Benchmarking the HttpClient Caching Module\" article from Comcast Interactive Media",
        "description": "I'd like to add a link into the HttpClient docs detailing some benchmarking we did with the HttpClient Cache module.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-653",
        "summary": "connection wrapper prevents GC of TSCCM",
        "description": "Even if a connection is released back to the ThreadSafeClientConnManager, a hard reference to the connection wrapper will prevent GC of the TSCCM.\nMake sure the connection wrapper is properly detached on release. Then update TestTSCCMWithServer.testConnectionManagerGC() accordingly. \n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1136",
        "summary": "BasicClientConnectionManager.releaseConnection accesses poolEntry using non-standard lock",
        "description": "According to the annotation, poolEntry is @GuardedBy(\"this\").\n\nHowever, in at least one place, it is accessed without holding a lock on this: \n\nBasicClientConnectionManager.releaseConnection synchronizes on managedConn, and then accesses poolEntry without synchronising on this.\n\n[Synch. only works if all parties use the same lock.]",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-110",
        "summary": "Port 80 is needed to run tests",
        "description": "I'm trying to upgrade to Cactus 1.4.1 and StrutsTest 1.9.  My tests where \nworking about fine a month ago with nightly builds of both.  Now I get the \nfollowing error:\n\n    [junit] Testcase: testCreate took 0.2 sec\n    [junit]     Caused an ERROR\n    [junit] port out of range:-1\n    [junit] java.lang.IllegalArgumentException: port out of range:-1\n    [junit]     at java.net.InetSocketAddress.<init>\n(InetSocketAddress.java:103)\n    [junit]     at java.net.Socket.<init>(Socket.java:119)\n    [junit]     at org.apache.commons.httpclient.HttpConnection.open\n(HttpConnection.java:260)\n    [junit]     at org.apache.commons.httpclient.HttpClient.executeMethod\n(HttpClient.java:255)\n    [junit]     at \norg.apache.cactus.client.HttpClientConnectionHelper.dispatch24_connect\n(HttpClientConnectionHelper.jav\na;org/apache/cactus/util/log/LogAspect.aj(1k):164)\n    [junit]     at \norg.apache.cactus.client.HttpClientConnectionHelper.around24_connect\n(HttpClientConnectionHelper.java;\norg/apache/cactus/util/log/LogAspect.aj(1k):1236)\n    [junit]     at org.apache.cactus.client.HttpClientConnectionHelper.connect\n(HttpClientConnectionHelper.java;org/apach\ne/cactus/util/log/LogAspect.aj(1k):106)\n    [junit]     at org.apache.cactus.client.AbstractHttpClient.callRunTest\n(AbstractHttpClient.java;org/apache/cactus/uti\nl/log/LogAspect.aj(1k):186)\n    [junit]     at org.apache.cactus.client.AbstractHttpClient.dispatch2_doTest\n(AbstractHttpClient.java;org/apache/cactu\ns/util/log/LogAspect.aj(1k):109)\n    [junit]     at org.apache.cactus.client.AbstractHttpClient.around2_doTest\n(AbstractHttpClient.java;org/apache/cactus/\nutil/log/LogAspect.aj(1k):1236)\n    [junit]     at org.apache.cactus.client.AbstractHttpClient.doTest\n(AbstractHttpClient.java;org/apache/cactus/util/log\n/LogAspect.aj(1k):104)\n    [junit]     at org.apache.cactus.AbstractWebTestCase.runGenericTest\n(AbstractWebTestCase.java:260)\n    [junit]     at org.apache.cactus.ServletTestCase.runTest\n(ServletTestCase.java:133)\n    [junit]     at org.apache.cactus.AbstractTestCase.runBare\n(AbstractTestCase.java:195)\n\nI found that I had to add port 80 (:80) get it to work with the new stuff:\n\ncactus.properties from: cactus.contextURL = http://localhost/myApp\n\nTo: cactus.contextURL = http://localhost:80/myApp\n\nbuild.xml from:\n\n    <target name=\"tomcat.navigationAction\" depends=\"deploy\" if=\"tomcat.home\">\n        <!-- We suppose our webapp is named \"onpoint\" -->\n        <runservertests testURL=\"http://localhost/${webapp.name}\" \n            startTarget=\"start.tomcat\" \n            stopTarget=\"stop.tomcat\" \n            testTarget=\"test.navigationAction\"/>\n    </target>\n\nTo:\n\n    <target name=\"tomcat.navigationAction\" depends=\"deploy\" if=\"tomcat.home\">\n        <!-- We suppose our webapp is named \"onpoint\" -->\n        <runservertests testURL=\"http://localhost:80/\n${webapp.name}/ServletRedirector?Cactus_Service=RUN_TEST\" \n            startTarget=\"start.tomcat\" \n            stopTarget=\"stop.tomcat\" \n            testTarget=\"test.navigationAction\"/>\n    </target>",
        "label": "NUG",
        "classified": "UNKNOWN",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-149",
        "summary": "303 Redirects are not handled properly",
        "description": "When the server spits back a 303 (See Other), the redirect is not handled. \nLooking at the code, I saw that the processRedirectResponse method in\nHttpMethodBase does not check for SC_SEE_OTHER in the case statement. \nSC_SEE_OTHER is a redirect and should be handled appropriately.\n\nHere is a trace from the output of the client and server.\n\nGET http://172.30.229.75/CGI/Screenshot HTTP/1.1 \nAuthorization: Basic c3VwZXJ1c2VyOnJvb3Q= \nHost: 172.30.229.75 \nUser-Agent: Jakarta Commons-HttpClient/2.0M1 \n\nHTTP/1.1 303 See Other \nLocation: http://172.30.229.75/FS/CIP_0_5842\nContent-Length: 0 \nServer: *snip*",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-1164",
        "summary": "Compressed entities are not being cached properly",
        "description": "org.apache.http.impl.client.cache.CacheValidityPolicy.contentLengthHeaderMatchesActualLength() returns false for entities decompressed by ContentEncodingHttpClient, because the length of decompressed entity stored in cache will be different from the length specified in the response header.\nConsequently, gzipped/deflated entities will never be satisfied from the cache.\n\nProposed fix: introduce new field in HttpCacheEntry() - actualContentLength, and populate it with the actual content length rigth before the cache entry is stored in the cache. Change the org.apache.http.impl.client.cache.CacheValidityPolicy.contentLengthHeaderMatchesActualLength() method to compare\nentry.getResource().length() with entry.getActualContentLength()\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-292",
        "summary": "NTLM Proxy and basic host authorization",
        "description": "Using a Microsoft proxy with NTLM validation enabled the authorization against a\nremote host does not work. This, of course, assuming that the page is correctly\nfetched (which currently is not), see the NTLM authentication bug number 24327",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-980",
        "summary": "CachingHttpClient returns a 503 response when the backend HttpClient produces an IOException",
        "description": "The CachingHttpClient returns an HTTP 503 response when the backend HttpClient throws an IOException.\n\nIt happens for instance when the backend is DefaultHttpClient (AbstractHttpClient), issuing a request to a server not listening on the target port.\nWell, it sounds tricky, but it makes the HttpClient not having a consistant behaviour in an implementation using both caching and regular clients.\n\nIf a 503 should really be returned in that case, I suggest the AbstractHttpClient to return it and the CachingHttpClient to just propagate any exception thrown by the backend.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-1122",
        "summary": "NPE in RequestProxyAuthentication on Android",
        "description": "Got a NPE backtrace in RequestProxyAuthentication.process(). \n\nHttpRoute route = conn.getRoute();\n        if (route.isTunnelled()) {      <= line 88, NPE here\n            return;\n        }\n\nThere's no null check on the returned route although getRoute() can return null.\nI guess it's not supposed to happen.\n\nIn the httpclient code, there's a few more calls to getRoute() without a null check on the returned route.\n\n\njava.lang.NullPointerException\nat com.bubblesoft.org.apache.http.client.protocol.RequestProxyAuthentication.process(SourceFile:88)\nat com.bubblesoft.org.apache.http.protocol.ImmutableHttpProcessor.process(SourceFile:108)\nat com.bubblesoft.org.apache.http.protocol.HttpRequestExecutor.preProcess(SourceFile:174)\nat com.bubblesoft.org.apache.http.impl.client.DefaultRequestDirector.execute(SourceFile:457)\nat com.bubblesoft.org.apache.http.impl.client.AbstractHttpClient.createHttpProcessor(SourceFile:821)\n                                                                 execute\nat com.bubblesoft.org.apache.http.impl.client.AbstractHttpClient.createHttpProcessor(SourceFile:755)\n                                                                 execute\nat com.bubblesoft.org.apache.http.impl.client.AbstractHttpClient.createHttpProcessor(SourceFile:733)\n                                                                 execute\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-755",
        "summary": "Use of java.net.URI.resolve() is buggy",
        "description": "The use of java.net.URI.resolve() is buggy (see <http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4708535>). Affected class: org.apache.http.impl.client.DefaultRedirectHandler.\n\nProposed solution: Create a resolve(URI, String) method in o.a.h.client.utils.URLUtils.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-917",
        "summary": "When authentication is invalidated during redirection, proxy authentication also should be invalidated",
        "description": "This was discovered during use by Lucene Connector Framework, on 3.1.\n\nWhen a document is fetched through a proxy authenticated with NTLM, and\nthat document is a redirection (301 or 302), the httpclient fails to\nproperly use the right proxy credentials on the subsequent document\nfetch. This leads to 407 errors on these kinds of documents.\n\nI've attached a proposed patch.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-542",
        "summary": "Explicit VirtualHosts Can Cause Issues On Redirects",
        "description": "If you set an explicit virtual host then a getmethod may get stuck in a redirect\nloop (up to maxRedirects).\n\ne.g. execute a get on www.google.com (with a www.google.com virtualhost).  That\nredirects to www.google.co.nz (at least if you come from an NZ IP).  The current\nhttpclient behavior is to then connect to www.google.co.nz but pass through,\nwith the request, \"Host: www.google.com\".  Google will then reply with another\nwww.google.co.nz redirect and the loop continues.\n\nThere are probably a few ways to work around this.  It seems reasonable to drop\nan explicity set virtual host in the event a redirect redirects to a different\nuri authority.  The following patch works for me:\n\n\ndiff -Naur\n../../t2/commons-httpclient/src/java/org/apache/commons/httpclient/HttpMethodDirector.java\nsrc/java/org/apache/commons/httpclient/HttpMethodDirector.java\n---\n../../t2/commons-httpclient/src/java/org/apache/commons/httpclient/HttpMethodDirector.java\n2005-12-22 01:06:55.000000000 +1300\n+++ src/java/org/apache/commons/httpclient/HttpMethodDirector.java\t2005-12-22\n19:09:51.000000000 +1300\n@@ -605,6 +605,27 @@\n \t\t\t\t\tredirectUri = new URI(currentUri, redirectUri);\n \t\t\t\t}\n \t\t\t}\n+            do {\n+                // scenario we're trying to avoid:\n+                // virtual host is set (e.g. google.com); a request to that\nserver responds\n+                // with a redirect to google.co.nz; we issue a request to\ngoogle.co.nz with \n+                // a virtual host request of google.com\n+                // \n+                // This code will remove any set virtual host if the redirect\nis to a different \n+                // domain\n+\n+                if(redirectUri.isRelativeURI()) {\n+                    break;\n+                }\n+\n+                String vhost = hostConfiguration.getParams().getVirtualHost();\n+                if(vhost==null)\n+                    break;\n+                if(redirectUri.getAuthority()!=currentUri.getAuthority()) {\n+                    hostConfiguration.getParams().setVirtualHost(null);\n+                }\n+            } while(false);\n+",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-786",
        "summary": "variables should be accessed through getters",
        "description": "Some attention should be placed on classes who shared their variables directly (as opposed to through a getter). This is sometimes OK for subclasses, but rarely good for other classes that use the objects. There's a small number of classes that have non-private variables, especially in the impl.conn & impl.conn.tsccm packages.\n\nSee HTTPCLIENT-745 .",
        "label": "NUG",
        "classified": "TASK",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1137",
        "summary": "The values for the Via header are created by httpclient-cache for each cached and backend request",
        "description": "The Via header that gets generated and inserted by the caching layer is done repeatedly in the HTTP conversation, even if the constructed string is constant for each protocol version that is involved.\n\nThe proposed patch constructs a map of generated values held in memory with the associated ProtocolVersion as a key and uses read/write locks to access the data. This  solution minimizes the time to generate such a value from several milliseconds to 40-50 microseconds.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-198",
        "summary": "The PostMethod did not bring back response headers from proxy servers",
        "description": "Description:\n\nWhen doing tunnelling through proxy servers, in case of 407 response, the \nwrapper class ConnectMethod failed to pass the response header back to the \nwrapped method (PostMethod in our case).  As result, the response headers are \nnot passed back to the application.\n\nProposed Fix:\nChange the ConnectMethod to use the wrapped method instance to get response \nheaders.  It will be reinitialized again if \"CONNECT\" is successful.\n\nAlso have to modify the addProxyAuthorizationRequestHeader code to use the \nwrapped method for the authenticator to work.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-827",
        "summary": "ServerTestBase, LocalTestServer should be redistributed",
        "description": "ServerTestBase and LocalTestServer should be redistributed, so that we can all benefit from these wonderful classes without having to copy / paste them.\n\nFor instance, I am currently creating a REST client for some web service, and I would totally benefit from your classes to check borderline cases (404, 500, etc..)\n\nthe simplest possible way to achieve this would be to add a maven-jar-plugin entry to the POM that executes the test-jar goal.\n\nregards,\nSami Dalouche\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-705",
        "summary": "Handle URIs with path component null",
        "description": "HttpClient does not handle URIs with path component null (e.g. http://google.com) the same as path component '/'. This results e.g. in a ProtocolException \"The server failed to respond with a valid HTTP response\".",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-92",
        "summary": "Cookies with ',' in the value string is not parsed correctly in some cases",
        "description": "This version extracts the \"Set-Cookie\" statementes of the following\nHTTP response headers incorrectly.\n\nThe HTTP response is sent when executing GET method on --->\n\"http://my.taishinbank.com.tw/netbank/nbslogin.asp?\nsubFunID=https://my.taishinbank.com.tw/netbank/AccountQuery/QAccbyID.asp\"\n\nAfter the HttpClient extracts Set-Cookie from the response, it generates a wrong\ncookie statement---->\n\n  [INFO] wire - ->> \"Cookie: $Version=0; _mysite=520163500; 1027657033=null; \n   1027787539=null; 0=null; $Path=/; cata=11; $Path=/;   \n   ASPSESSIONIDGGGQQXEU=ADLCDAGAJLKEBJEKBOMMAMOB; \n   $Path=/\"\n\n, where it shall \nbe \"_mysite=520163500,1027657033,1027787539,1027787539,0;\" ,but \nnot \"_mysite=520163500; 1027657033=null; 1027787539=null; 0=null;\"\n \n\nThank you",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-485",
        "summary": "Connection is not released back to the pool if a runtime exception is thrown in HttpMethod#releaseConnection method",
        "description": "the default config of leaving the HttpClientParams.CONNECTION_MANAGER_TIMEOUT as zero means \nthat the first time the connection manager fails to immediately get a connection you application hangs. \n(at least using MultiThreadedHttpConnectionManager.)\n\nthis is because the zero gets passed onto a call to Object.wait(long timeout) and, from the docs, \"If \ntimeout is zero, however, then real time is not taken into consideration and the thread simply waits \nuntil notified.\". \n\nsince nothing ever \"notify()\"s the thread everything just stops...\n\nthe default behaviour of the client more should be more predictable. you don't expect it to hang your \nentire app if it can't get a connection, you expect it to timeout then throw an exception or give some \nother kind of feedback.\n\nit would make sense to give a default of, say, arbitrarily, 10 seconds or so. this would save every single \nuser of the classes having to dig around in the code/documentation and explictly set this param. they \nmight decide that the default value isn't right and hence change it, but that's tweaking behaviour, not \ncorrecting it. i certainly thought it was a bug in the code (yours or mine), not my config and have been \nfretting around it for a while.\n\nbest,\ngarry",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-862",
        "summary": "Extend the client's redirect handling interface to allow control of the content of the redirect",
        "description": "The existing RedirectHandler interface provides the ability influence which situations cause redirects, but gives you no control over the content of the redirect itself.  For example, if you want the client follow the redirect of a POST request with a POST request to the new location, you can't do it.  DefaultRequestDirector decides what method will be used on the redirect request and as of the most recent patch, it's always either a HEAD or a GET.\n\nOne option for resolving this might be extending the RedirectHandler interface to be a factory for creating the redirect request object.  The the DefaultRequestDirector could then be changed to ask the RedirectHandler to create the appropriate request for the situation.\n\nThanks,\nBen",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-557",
        "summary": "Nullpointer when creating URI from scheme specific part with null fragment",
        "description": "in org.apache.commons.httpclient.URI class constructor:\n\npublic URI(String scheme, String schemeSpecificPart, String fragment)\n        throws URIException {\n....\n_fragment = fragment.toCharArray(); \n\nshould be \n\n_fragment = fragment==null ? null : fragment.toCharArray();",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-11",
        "summary": "null domains break Cookie.java",
        "description": "the domain is assumed to be non-null in a few places in Cookie.java, see matches\nmethod, for example",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-447",
        "summary": "IllegalStateException: Authentication state already initialized",
        "description": "Hi,\n\nI am running HttpClient 3.0 RC2 in my application and a user send me a logfile\ntelling \"IllegalStateException: Authentication state already initialized\". \n\nHe wanted to access a site on SUN.com and is behind a proxy. The site seems to\nredirect to a different domain.\n\nI have attached a Debug+Trace HttpClient log.\n\nBen",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-883",
        "summary": "SO_TIMEOUT is not set on a request level",
        "description": "The scenario is as follows: I'm doing two consecutive requests to the same host, using a multi-threaded (or thread safe) connection pool manager. The first invocation has a timeout of 10s and the second has a timeout of 30s. \n\nIn version 3.1 of HttpClient all works well, but in 4.0 I get a timeout exception in the second request, after ~10 seconds, which means the first timeout is used.\n\nLooking at the code, I see that in version 3.1, the HttpMethodDirector.executeWithRetry() method invokes a method named applyConnectionParams() that took care of setting the timeout taken from the request on the socket. \n\nBut in version 4.0, the only place I see the timeout is set on the socket is when DefaultRequestDirector.execute(HttpHost, HttpRequest, HttpContext) opens a connection using the managedConn.open() method. Since the connection is reused between the requests, the second request uses a socket with a timeout of the first request.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-1017",
        "summary": "Checksum Wrong for HttpComponent project pom v4.1 on central",
        "description": "As evidenced on the log here: http://vmgump.apache.org/gump/public/httpcomponents/httpcomponents-core/gump_work/build_httpcomponents_httpcomponents-core.html\n\nThe checksum in central for httpcomponents-project-4.1.pom is incorrect in maven central.\n\n---------------------------8<--------------------------------\n\nDownloading: http://localhost:8192/maven2/org/apache/httpcomponents/project/4.1/project-4.1.pom\n\n[WARNING] *** CHECKSUM FAILED - Checksum failed on download: local = 'b63ff67e6ffc1940041319e0e06d7c6b1d671fd2'; remote = '8edff11652ca51b9d110ebfb321daac24f031c07' - RETRYING\nDownloading: http://localhost:8192/maven2/org/apache/httpcomponents/project/4.1/project-4.1.pom\n\n[WARNING] *** CHECKSUM FAILED - Checksum failed on download: local = 'b63ff67e6ffc1940041319e0e06d7c6b1d671fd2'; remote = '8edff11652ca51b9d110ebfb321daac24f031c07' - IGNORING\nThis pom appears to be a dependency for httpcomponents 4.0.3\n\n---------------------------8<--------------------------------\n\nThis checksum failure causes configurations that reject such artifacts (such as many maven proxy configurations) to result in build failures due to unsatisfied dependencies. \n\n",
        "label": "NUG",
        "classified": "OTHER",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-593",
        "summary": "ProtocolSocketFactory equals and hashCode don't support subclassing",
        "description": "In the implemenation of equals and hashCode for the classes\norg.apache.commons.httpclient.protocol.DefaultProtocolSocketFactory\norg.apache.commons.httpclient.protocol.SSLProtocolSocketFactory\n\nThe implementation of equals and hashCode attempts to make all instances of the classes equal.  However, the manner in which the methods are coded makes it necessary for any subclass to implement equals and hashCode themselves.  A minor change to the methods in these classes will make possible to subclass these factories without re-implementing the equals and hashCode.  The method equals should be written as\n\n        return ((obj != null) && obj.getClass().equals(getClass()));\n\nrather than\n\n        return ((obj != null) && obj.getClass().equals(DefaultProtocolSocketFactory.class));\n\nAnd similarly, the hashCode method should be\n\n        return getClass().hashCode();\n\nrather than\n\n        return DefaultProtocolSocketFactory.class.hashCode();",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-213",
        "summary": "Authentication fails with proxied SSL Connections",
        "description": "When connecting through a proxy, using SSL and authentication HttpClient winds \nup sending a GET request to the proxy after the initial auth required response, \nthe proxy then obviously responds with a not implemented response since it \ncan't handle a GET request to an SSL URL.  In essence the following is \nhappening:\n\n1. HttpClient sends Connect response.\n2. Proxy responds 200 Connect OK\n3. HttpClient uses SSL connection to send the request to the web server.\n4. Web server responds with not authorized and closes the connection.\n5. HttpClient opens a new connection to the proxy and issues a GET request for \nthe SSL URL.\n6. Proxy returns 501 not implemented.\n\nI'll attach a full log to this bug.\n\nThis is likely to be hard to fix since the retry is performed in HttpMethodBase \nbut the Connect method is executed by HttpClient so a fix for this may be best \nwaiting for 2.1.  This looks very similar to HTTPCLIENT-195 except that that bug is \nmarked as fixed and this one still doesn't work, this also applies to \nauthentication schemes other than NTLM (testing NTLM and basic).\n\nMy best evaluation is that the web server returns Connection: close when it \nrejects the authorization attempt and then HttpMethodBase is incapable of \ncreating a new SSL connection through the proxy.  The only thing I can think of \nthat could be done prior to 2.1 to fix this is to send a Connection: keep-alive \nas well as the Proxy-Connection: Keep-Alive we're already sending with the \noriginal request.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-323",
        "summary": "GetMethod.getResponseBodyAsStream() .available() could return content-length",
        "description": "It would be nice if the InputStream returned from\nGetMethod.getResponseBodyAsStream() could override the available()\nmethod to return the content-length of the requested URL.  This would\nmake things like ProgressMonitorInputStream useful for monitoring the\nprogress of a download.  Here is a code snippet:\n\n\n/**\n * supply a hard-coded value for available() method.\n */\nclass FixedInputStream extends FilterInputStream {\n  private int contentLength;\n\n  public FixedInputStream(InputStream is,\n              int contentLength) {\n    super(is);\n    this.contentLength = contentLength;\n  }\n\n  public int available() throws IOException {\n    return contentLength;\n  }\n} \n\n\n\nAlso, somewhat related to this request, could\nGetMethod.getResponseContentLength() must be made public?  Is there a\ngood reason for it to be protected?  I had to extend GetMethod and\nimplement a public getResponseContentLength() in order to feed that\nvalue to my FixedInputStream.\n\nThanks for your time.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-388",
        "summary": "http.connection-manager.timeout is a LONG not an INTEGER",
        "description": "Documentation is wrong.\n\nTable in Preference Architecture page states http.connection-manager.timeout \nis an Integer.\n\nDoing:\n\nsetParameter(\"http.connection-manager.timeout\", new Integer(n));\n\nCauses:\n\njava.lang.ClassCastException\n\tat \norg.apache.commons.httpclient.params.DefaultHttpParams.getLongParameter\n(DefaultHttpParams.java:171)\n\tat \norg.apache.commons.httpclient.params.HttpClientParams.getConnectionManagerTimeo\nut(HttpClientParams.java:143)\n\tat org.apache.commons.httpclient.HttpMethodDirector.executeMethod\n(HttpMethodDirector.java:161)\n\tat org.apache.commons.httpclient.HttpClient.executeMethod\n(HttpClient.java:437)\n\tat org.apache.commons.httpclient.HttpClient.executeMethod\n(HttpClient.java:324)",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-869",
        "summary": "Incorrect/incomplete product name in META-INF/NOTICE file",
        "description": "The NOTICE file in the HttpClient jars is incorrect.\n\nIt states:\n\n=====\n\nHttpClient\nCopyright 1999-2009 Apache Software Foundation\n<snip/>\n======\n\nThe leading blank line should be deleted, and \"HttpClient\" should be \"Apache HttpComponents Client - HttpClient\"  (or similar) as is the case for the source archive.\n\nSimilarly for HttpMime",
        "label": "NUG",
        "classified": "OTHER",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-979",
        "summary": "cache entry resource management should be extracted from CachingHttpClient",
        "description": "As we have built in support for stream-based management of cached response bodies, the CachingHttpClient class has its fingers in too many pies and is involved in resource management but not storage of the actual HttpCacheEntries.\n\nI have a patch forthcoming. :)\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-815",
        "summary": "Quick Start guide for HttpClient 4.0",
        "description": "cannot determine the required jar files to compile samples/ own files\n\nexample org.apache.http.examples.client.ClientFormLogin\n\nused\n\nset CLASSPATH=P:\\j\\samples\\httpClient\\examples;j:\\j\\j5\\h;P:\\j\\e\\mysql.jar;P:\\j\\e\\commons-logging-api-1.1.1.jar;P:\\j\\e\\commons-logging-1.1.1.jar;P:\\j\\e\\4\\httpmime-4.0-beta2.jar;P:\\j\\e\\4\\httpclient-4.0-beta2.jar;P:\\j\\e\\4\\h\\e\\4\\httpcore-4.0-beta3.jar;P:\\j\\e\\4\\httpcore-nio-4.0-beta3.jar\n\nbut still needs org.apache.http.*; ... where are these jars? a quick start guide / link to all jars for one version would help\n\n- only known workaround - go back to old version 3.1",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-595",
        "summary": "Fix junit scope in maven pom",
        "description": "Please change the junit dependency to\n\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <url>http://www.junit.org/</url>\n      <properties>\n        <scope>test</scope>\n      </properties>\n    </dependency>\n\nfor better automatic conversion to maven 2",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "HTTPCLIENT-1158",
        "summary": "Change the error message in the exception at URIUtils#rewriteURI ",
        "description": "The message in URIUtils#rewriteURI is misspelled - \"URI may nor be null\" should be \"URI should not be null\"",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": ""
    },
    {
        "key": "HTTPCLIENT-931",
        "summary": "Change value of 'Expect' header in org.apache.http.client.methods.HttpPost",
        "description": "see original report at http://code.google.com/p/android/issues/detail?id=7208.\n\ni'm going to apply the obvious patch to Android:\n\ndiff --git a/src/org/apache/http/params/CoreProtocolPNames.java b/src/org/apache/http/params/CoreProtocolPNames.java\nindex a42c5de..a0a726d 100644\n--- a/src/org/apache/http/params/CoreProtocolPNames.java\n+++ b/src/org/apache/http/params/CoreProtocolPNames.java\n@@ -94,8 +94,8 @@ public interface CoreProtocolPNames {\n \n     /**\n      * <p>\n-     * Activates 'Expect: 100-Continue' handshake for the \n-     * entity enclosing methods. The purpose of the 'Expect: 100-Continue'\n+     * Activates 'Expect: 100-continue' handshake for the\n+     * entity enclosing methods. The purpose of the 'Expect: 100-continue'\n      * handshake to allow a client that is sending a request message with \n      * a request body to determine if the origin server is willing to \n      * accept the request (based on the request headers) before the client\ndiff --git a/src/org/apache/http/protocol/HTTP.java b/src/org/apache/http/protocol/HTTP.java\nindex de76ca6..9223955 100644\n--- a/src/org/apache/http/protocol/HTTP.java\n+++ b/src/org/apache/http/protocol/HTTP.java\n@@ -60,7 +60,7 @@ public final class HTTP {\n     public static final String SERVER_HEADER = \"Server\";\n     \n     /** HTTP expectations */\n-    public static final String EXPECT_CONTINUE = \"100-Continue\";\n+    public static final String EXPECT_CONTINUE = \"100-continue\";\n \n     /** HTTP connection control */\n     public static final String CONN_CLOSE = \"Close\";\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-85",
        "summary": "Host request header does not contain port",
        "description": "The Host request header is always added with just the hostname used for the \nconnection.  If the port is different than 80 it needs to be included as well, \nwith a colon separating it from the hostname.  This problem is especially \napparent when you use the httpclient to connect to tomcat 4 and then use \nHttpUtils to create a full URL representing the request.  HttpUtils pulls the \nhost and port from the Host header.  When commons-httpclient is used HttpUtils \nnever includes the port since it was never in the Host header.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-641",
        "summary": "Resource Leakage when loading keystore in AuthSSLProtocolSocketFactory",
        "description": "Opened stream not closed after keystore is loaded, resulting in resource leakage:\n\nprivate static KeyStore createKeyStore(final URL url, final String password) \n        throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException\n    {\n        if (url == null) {\n            throw new IllegalArgumentException(\"Keystore url may not be null\");\n        }\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore  = KeyStore.getInstance(\"jks\");\n        keystore.load(url.openStream(), password != null ? password.toCharArray(): null);\n        return keystore;\n    }\n\nShould be changed to something like:\n\nprivate static KeyStore createKeyStore(final URL url, final String password) \n        throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException\n    {\n        if (url == null) {\n            throw new IllegalArgumentException(\"Keystore url may not be null\");\n        }\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore  = KeyStore.getInstance(\"jks\");\n        InputStream is = ulr.openStream();\n        try {\n          keystore.load(is, password != null ? password.toCharArray(): null);\n        } finally {\n           is.close();\n        }\n        return keystore;\n    }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "HTTPCLIENT-553",
        "summary": "JavaDoc getConnection methods in Connection Managers",
        "description": "The JavaDoc for the getConnection() methods in the Simple and MultiThreaded\nConnection managers is taken from the interface, and so is too generic.\n\nThe Javadoc for the doGetConnection() method in the MultiThreaded manager is\nfine, but is not visible in the JavaDoc\n\nThe Simple Mangager JavaDoc could likewise be improved\n\n[I hope to provide patches shortly]",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-930",
        "summary": "[OCM] rename o.a.j.ocm.persistence.PersistenceManager to avoid confusion with core component",
        "description": "PersistenceManager is a well known and established interface in jackrabbit's architecture. the same-named class in the\njcr-mapping contrib project should IMO be renamed in order to avoid confusion in mailing list threads and jira issues,",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-443",
        "summary": "Deadlock when concurrently committing and reading versioning states",
        "description": "there is a rear occation when one thread commits a transaction and another thread reads versioing related information, so that a deadlock can occurr. \n\nexample:\n\nThread1:\n                        ut.begin();\n                        session.getWorkspace().clone(\"default\", \"/content\", \"/content\", true);\n                        ut.commit();\n\nThread2:\n                        VersionHistory vh = folder.getVersionHistory();\n                        VersionIterator iter = vh.getAllVersions();\n                        while (iter.hasNext()) {\n                            Version v = iter.nextVersion();\n                        }\n\n\nto fix this issue we must ensure, that methods below the shareditemstatemgr do not call higher instances (like itemmgr) again.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1818",
        "summary": "Too many open files when merging large index segments",
        "description": "When large index segments are merged it may happen that lots of smaller index segments are created but have to wait until the large\nindex merge has completed. This may lead to a 'too many open files' exception on some system.\n\nWe should find a solution where large index merges are better decoupled from regular index operations.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1070",
        "summary": "Promotion of SPI from Contrib",
        "description": "This has been suggested by Jukka on the dev-list [1] and i would like to start the promotion now. Apart from \nthe promotion itself the discussion regarding distribution of common classes [2] and the related issue JCR-996 somehow depends on the promotion and i consider the latter one to be important to follow.\n\nSo far nobody objected the promotion. If this is still true, i will start working on that.\n\n\n\n\n[1] http://www.mail-archive.com/dev@jackrabbit.apache.org/msg06433.html\n[2] http://www.mail-archive.com/dev@jackrabbit.apache.org/msg06698.html",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-693",
        "summary": "jackrabbit-jca rar archive misses required classes",
        "description": "Since the Maven 2 upgrade, the jackrabbit-jca rar archive doesn't contain the rar-specific classes in a jackrabbit-jca jar file that was previously also included in the archive.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-126",
        "summary": "Jcr-Server Module: Remove Dependency from Jackrabbit-Core",
        "description": "",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2543",
        "summary": "spi2dav : Query offset not respected",
        "description": "the TCK query test SetOffsetTest fails in the setup jcr2spi - spi2dav(ex) - jcr-server.\nnot sure whether it is due to missing implementation on client or server part of something completely different....",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1636",
        "summary": "Make shutdown hooks in TransientFileFactory removable",
        "description": "TransientFileFactory class always registers shutdown hook. So, if jackrabbit classes were loaded by web-app classloader, they will not be released when web-app is undeployed (if jackrabbit-jcr-commons JAR is inside WAR). This causes classloader leak.\nIt seems to be useful to have ability to cancel TransientFileFactory's shutdown hook when application is going to be unloaded to avoid classloader leak.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1248",
        "summary": "Helper Method to escape illegal XPath Search Term",
        "description": "If you try to perform a search like this\n\n//element(*, nt:base)[jcr:contains(., 'test!')]\n\nyou get this exception\n\njavax.jcr.RepositoryException: Exception building query: org.apache.jackrabbit.core.query.lucene.fulltext.ParseException: Encountered \"<EOF>\" at line 1, column 6.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1413",
        "summary": "[PATCH] retain exception stack traces",
        "description": "Code catches one exception, and throws another, losing the stack trace information of the causal exception. This makes it more difficult to understand what happened when an exception occurs. This patch retains all stack traces that occur that causes a thrown exception.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-863",
        "summary": "Use FileLock for locking instead of empty file",
        "description": "The FSDirectory uses File.createNewFile to effectively lock a directory (in makeLock), yet the Java Spec says explcitly not to use it for this purpose, and instead use FileLock from nio.\n\nThe attached patch shows how this is/could be done (change is internal to the makeLock method only, and functionally equivalent, the same tests apply).",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1108",
        "summary": "JCR2SPI: error level logging when cleaning up session locks ",
        "description": "LockManagerImpl.loggingOut() tries to unlock nodes that have a session lock. If, while doing so, a RepositoryException is thrown, this gets locked on error level.\n\nThe TCK tests tearDown code removes test nodes using a separate session; thus we see RepositoryExceptions for the simple reason that the nodes have already been removed by somebody else.\n\nProposal: handle ItemNotFoundExc and PathNotFoundExc separately, not logging them.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3003",
        "summary": "Tika configuration may use wrong class loader",
        "description": "The configurable Tika parser construction mechanism added in JCR-2864 constructs the parser instance lazily when the first indexing request is made. This may confuse things as the context class loader used by Tika to load all the available parser classes may not always be the class loader used to create the repository. To avoid this problem the Tika parser should be constructed already during normal repository initialization.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2047",
        "summary": "Test failure: org.apache.jackrabbit.test.TestAll",
        "description": "Subsequent test runs fail unless doing a mvn clean first.\n\n-------------------------------------------------------\n T E S T S\n-------------------------------------------------------\nRunning org.apache.jackrabbit.spi2jcr.spi.TestAll\nTests run: 50, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.965 sec\nRunning org.apache.jackrabbit.test.TestAll\nTests run: 1038, Failures: 11, Errors: 0, Skipped: 0, Time elapsed: 44.925 sec <<< FAILURE!\nRunning org.apache.jackrabbit.spi2jcr.jcr2spi.TestAll\nTests run: 394, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.416 sec\n\nResults :\n\nFailed tests:\n  testOrderByAscending(org.apache.jackrabbit.test.api.query.SQLOrderByTest)\n  testOrderByDescending(org.apache.jackrabbit.test.api.query.SQLOrderByTest)\n  testOrderByDefault(org.apache.jackrabbit.test.api.query.SQLOrderByTest)\n  testDocOrderIndexedNotation(org.apache.jackrabbit.test.api.query.XPathPosIndexTest)\n  testDocOrderPositionFunction(org.apache.jackrabbit.test.api.query.XPathDocOrderTest)\n  testDocOrderPositionIndex(org.apache.jackrabbit.test.api.query.XPathDocOrderTest)\n  testDocOrderLastFunction(org.apache.jackrabbit.test.api.query.XPathDocOrderTest)\n  testDocOrderFirstFunction(org.apache.jackrabbit.test.api.query.XPathDocOrderTest)\n  testOrderByAscending(org.apache.jackrabbit.test.api.query.XPathOrderByTest)\n  testOrderByDescending(org.apache.jackrabbit.test.api.query.XPathOrderByTest)\n  testOrderBy(org.apache.jackrabbit.test.api.query.XPathOrderByTest)\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1459",
        "summary": "NullPointerException on startup if IndexingQueue has pending nodes",
        "description": "This happens because of the newly introduced index version, which is not yet set when the IndexingQueue is instanciated.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1271",
        "summary": "NullPointerException when iterating over properties",
        "description": "Running ConcurrentReadWriteTest (NUM_NODES=5, NUM_THREADS=3, RUN_NUM_SECONDS=120) resulted in a NullPointerException:\n\nException in thread \"Thread-11\" java.lang.NullPointerException\n\tat org.apache.commons.collections.map.AbstractReferenceMap$ReferenceEntry.getValue(AbstractReferenceMap.java:596)\n\tat org.apache.commons.collections.map.AbstractReferenceMap.containsKey(AbstractReferenceMap.java:204)\n\tat org.apache.jackrabbit.core.state.ItemStateMap.contains(ItemStateMap.java:66)\n\tat org.apache.jackrabbit.core.state.ItemStateReferenceCache.isCached(ItemStateReferenceCache.java:91)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.hasItemState(LocalItemStateManager.java:173)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.hasItemState(XAItemStateManager.java:252)\n\tat org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState(SessionItemStateManager.java:174)\n\tat org.apache.jackrabbit.core.ItemManager.createItemInstance(ItemManager.java:495)\n\tat org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:326)\n\tat org.apache.jackrabbit.core.LazyItemIterator.prefetchNext(LazyItemIterator.java:90)\n\tat org.apache.jackrabbit.core.LazyItemIterator.next(LazyItemIterator.java:203)\n\tat org.apache.jackrabbit.core.LazyItemIterator.nextProperty(LazyItemIterator.java:118)\n\tat org.apache.jackrabbit.core.ConcurrentReadWriteTest$1$1.execute(ConcurrentReadWriteTest.java:64)\n\tat org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:110)\n\tat java.lang.Thread.run(Thread.java:619)\n\nThe cache is not synchronized and is accessed at the same time by the current thread and another thread that notified ItemStates about changes.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-365",
        "summary": "Web client/WebDAV fails to unescape workspace names",
        "description": "It seems that when you try to access to a workspace through the web client/webdav, and the workspace has special characteres like spaces on its name like (\"my workspace\"), then the web cliente/webdav is not able to load it.\n\nProbablly the only thing to do is to unscape the workspace name.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3017",
        "summary": "Version history recovery fails in case a version does not have a jcr:frozenNode",
        "description": "With JCR-2551 in place, a version recovery mode has been introduced. Problem now is that in case a version is encountered that misses a mandatory jcr:frozenNode, an InternalError is thrown by o.a.j.c.version.InternalVersionHistoryImpl#createVersionInstance. Since o.a.j.c.RepositoryChecker#checkVersionHistory only catches Exception, it fails to catch it properly which leads to a complete repository shutdown.\n\nThrowing for example a RuntimeException instead fixes the problem.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1301",
        "summary": "Trouble undeploying jackrabbit-webapp from Tomcat",
        "description": "When testing jackrabbit-webapp for the 1.4 release, I again came across this issue that I've occasionally seen also before, but never qualified enough for a bug report.\n\nThe Jackrabbit webapp would deploy without problems, but when I undeploy the webapp Tomcat fails to remove the Derby jar in WEB-INF/lib (I have unpackWARs enabled). This causes problems especially when I have autoDeploy enabled, as Tomcat then deploys the skeleton webapp right after undeployment, and the only way to really get rid of the webapp is to shutdown Tomcat and to manually remove the webapp on the file system.\n\nI suspect that this problem is related to Derby jar being somehow referenced even after the webapp is undeployed, causing Windows to prevent the jar file from being removed.\n\nUnless someone has some bright idea on how to resolve this, I'll consider this a known issue in Jackrabbit 1.4.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2762",
        "summary": "Optimize bundle serialization",
        "description": "There are a number of ways we could use to make bundle serialization more optimized. Thomas has already done some work on this in the Jackrabbit 3 sandbox, and I'd like to apply some of the optimizations also to the trunk.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1209",
        "summary": "NodeImpl.checkout() calls save() two times",
        "description": "Similar to JCR-975, The version related properties on a versionable node that is checked out are saved individually. There is no need to save them individually because checkd in node must not have pending changes and save() can be called safely on the node itself.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3047",
        "summary": "OperandEvaluator should be able to handle Nodes as well, not just Rows",
        "description": "OperandEvaluator is used to evaluate Operands values against given Rows, and in an effort to improve the sorting part of SQL2 (JCR-2959), I need it to handle plain Nodes as well.\n\nThis is a small change, as the OperandEvaluator already extracts the Node info from the Row, so there is no obvious reason no to expose the Node operations directly.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3270",
        "summary": "Error instantiating lucene search index in Turkish Regional Setting",
        "description": "There is an issue when changing regional setting to Turkish. \nIt fails when starting a repository, instantiating the lucene search index due to the following issue :\n\norg.apache.jackrabbit.core.config.ConfigurationException: Configured class org.apache.jackrabbit.core.query.lucene.SearchIndex does not contain a property named indexingConfiguration\n\tat\norg.apache.jackrabbit.core.config.BeanConfig.newInstance(BeanConfig.java\n:205)\n\tat\norg.apache.jackrabbit.core.config.RepositoryConfigurationParser$1.getQue\nryHandler(RepositoryConfigurationParser.java:631)\n\tat\norg.apache.jackrabbit.core.config.RepositoryConfig.getQueryHandler(Repos\nitoryConfig.java:1013)\n\nThis issue is known in java world, due to lower case conversion of 'I' character (in Turkish locale). JackRabbit source code try to instantiate the indexing configuration during the repository starting and is accessing indexingConfiguration property. It instantiates a setter for this property with a bad 'i' character.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1590",
        "summary": "JSR 283: Locking",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-616",
        "summary": "Completeness/Freshness of NamespaceRegistry and NodeTypeRegistry",
        "description": "We need to define the requirements on completeness and freshness of RepositoryService.getRegisteredNamespaces().\n\nRight now the optimistic assumption seems to be that an SPI provider is able to report all namespaces that can occur in a repository beforehand. Even if it can do that (and I know of potential targets for SPI that simply can't), this seems to be quite a waste of time if these namespace prefixes aren't actually used later on.\n\nFurthermore, in SPI namespace prefixes aren't really relevant, except to enable the transient layer to return \"meaningful\" prefixes instead of automatically generated ones.\n\nTherefore my propoal would be to:\n\n1) Clarify that the Map returned from getRegisteredNamespaces() isn't required to be complete,\n\n2) Enhance JCR2SPI to auto-generate prefixes when it encounters namespaces not in the registry.\n\nI expect this to also affect RepositoryService.(un)registerNamespace(...), but let's discuss the underlying issue first...\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2832",
        "summary": "Crash when adding node to cluster with big journal on PSQL DB",
        "description": "When adding a new node to a cluster with big journal on PSQL database application runs out of memory on the new node and crashes (no exception, application exits with code 137).\nIt's because with PSQL, when no fetchSize is specified, all the results of query are loaded into memory before being passed to application. Furthermore, specification of fetchSize only works in transactional mode and have no effect if autoCommit is true. (these are configured in ConnectionHelper)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-921",
        "summary": "Add more unit tests on BeanConverters",
        "description": "Some BeanConverters are not yet stable. We have to add more unit tests.  It seems that null values for bean attributes are not well supported. We have to test that for all BeanConverters. \n\nHere is a good scenario to test : \n\nModel : Class A contains an attribute \"b\" based on class B. \n\nCreate an instance of A with \"b\" = null\ninsert A / save\nGet instance of A\nset the attribute of B\nupdate A /save\n\n\n\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-1776",
        "summary": "Some unit tests are not well configured",
        "description": "Some unit tests used for the annotation support are not well defined. There are inherited from DigesterTestBase instead of AnnotationTestBase",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2763",
        "summary": "Drop the Dumpable interface",
        "description": "I belive the o.a.j.core.util.Dumpable interface was originally used for diagnostic purposes, but AFAIUI we don't use it anywhere anymore. I'd like to drop the interface and refactor the dump() methods in various Jackrabbit classes to more detailed toString() methods that would be more useful to debuggers and other general-purpose diagnostic tools.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2979",
        "summary": "Deprecate RepositoryService.getNodeInfo method",
        "description": "I suggest to deprecate RepositoryService.getNodeInfo in favor of RepositoryService.getItemInfos. The former method is not called from jsr2spi anymore and thus not required. ",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-277",
        "summary": "reorganize xdocs and website",
        "description": "i would like to propose a change to the website and xdocs structure.\n\nthe current structure below seems like it could use a brush up.\n\n---\nOverview\nArchitecture Doc\n.Overview\n..JSR-170 Levels\n.Deployment Models\n..Application HOWTO\n..Model 1 HOWTO\n..Model 2 HOWTO\n..Model 3 HOWTO\n.Core Operations\n..Start-up, Initialize\n..QueryManager Implementation\nFirst Steps\nJCR API Documentation\nLayout\nDownloads\nFAQ\n---\n\ni would propose the following, instead:\n---\nAbout \nDocumentation\n.First Steps\n.JCR\n.API Documentation\n.Jackrabbit Architecture\n..Start-up, Initialize\n..QueryManager Implementation\n.Deployment Models\n..Application HOWTO\n..Model 1 HOWTO\n..Model 2 HOWTO\n..Model 3 HOWTO\n.Nodetype Modelling *new*\nLayout\nDownloads\nFAQ\n---\n\nalso i would like to introduce a new \"homepage\" with a little bit more attractive content like jackrabbit\nnews, maybe featured jackrabbit applications, schedules and events.\n\nideally i would like to re-organize the file structure according to the navigation, which may break\nbookmarks and search indexes.\n\nthoughts?",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2011",
        "summary": "Replacing mixin type doesn't preserve properties",
        "description": "NodeImpl.setPrimaryType(String) attempts to \"redefine\" nodes and properties that were defined by the previous node type if they also appear in the new type. If there is no matching definition for a node/property in the new type - or value conversion for matched node/property fails - only then are children removed. For example, say I have a node \"harry\", with a primary type \"Human\" that defines a \"bloodgroup\" property. If I set the primary type to be an unrelated type \"Animal\" that has a similar \"bloodgroup\" property, then its property value will survive the call to setPrimaryType(\"Animal\").\n\nThe same is apparently not possible with mixins. NodeImpl.removeMixin(Name) immediately removes all children that were defined by the mixin (strictly, those that are not present in the effective node type resulting from the mixin being removed). In addition, NodeImpl.addMixin(Name) immediately throws a NodeTypeConflictException if you attempt to add a mixin defining an identically-named property prior to calling removeMixin. For example, say I have a node \"matrix\", with a mixin type \"movie\" that defines a \"title\" property. If I wish to replace the \"movie\" mixin on that node with another \"jcr:title\" mixin type, the existing \"title\" property will be deleted.\n\nThis occurs regardless of the order in which removeMixin and addMixin are called, and without session.save() being called between them. One option for coding this is to defer validation (and possible node/property removal) until session.save() is called.\n\nThis is not strictly a bug, as JSR-283 seems to leave the details of assigning node types (section 5.5) unspecified. However, it does say for Node.removeMixin(String) that \"Both the semantic change in effective node type and the persistence of the\nchange to the jcr:mixinTypes property occur on save\" and ideally we could emulate the nice behaviour in NodeImpl.setPrimaryType(String) for mixin types.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2960",
        "summary": "Long values not properly stored",
        "description": "When a long value assigned to a property is too big, when restarting the server the value become 0 !! \n\nThe test pass with versions 1.6.4 and 2.0",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2826",
        "summary": "Test dependency on Jackrabbit core (from o.a.j.c.security.user.XPathQueryEvaluator)",
        "description": "o.a.j.c.security.user.XPathQueryEvaluator wrongly imports \n\n    import org.apache.jackrabbit.test.api.util.Text\n\ninstead of\n\n    import org.apache.jackrabbit.util.Text\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1789",
        "summary": "Provide access to cluster records",
        "description": "Cluster records are read/written inside o.a.j.core.cluster.ClusterNode in private methods. In order to support tools such as a journal walker that would display human readable descriptions of cluster records, these inner workings should be made public. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-531",
        "summary": "TCK: OrderByMultiTypeTest doesn't respect nodetype configuration property",
        "description": "OrderByMultiTypeTest creates test data by calling addNode(String).  This fails if there is no default primary type.\n\nProposal: call addNode(String, String)\n\n--- OrderByMultiTypeTest.java   (revision 428760)\n+++ OrderByMultiTypeTest.java   (working copy)\n@@ -43,9 +43,9 @@\n      * Tests order by queries with a String property and a long property.\n      */\n     public void testMultipleOrder() throws Exception {\n-        Node n1 = testRootNode.addNode(nodeName1);\n-        Node n2 = testRootNode.addNode(nodeName2);\n-        Node n3 = testRootNode.addNode(nodeName3);\n+        Node n1 = testRootNode.addNode(nodeName1, testNodeType);\n+        Node n2 = testRootNode.addNode(nodeName2, testNodeType);\n+        Node n3 = testRootNode.addNode(nodeName3, testNodeType);\n  \n         n1.setProperty(propertyName1, \"aaa\");\n         n1.setProperty(propertyName2, 3);\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1603",
        "summary": "Remove getSafeJCRPath methods in HierarchyManagerImpl",
        "description": "The getSafeJCRPath utility methods in the HierarchyManagerImpl class have not been used since revision 485720, but their presence still causes the hierarchy managers to depend on namespace mapping information. I'll remove the methods to simplify things.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2840",
        "summary": "Inconsistencies if \"everyone\" Group is created by User Management",
        "description": "currently the 'everyone' principal used to define ACEs that apply for all regular users in the repository is hardcoded in the\nprincipal management. this leads to inconsistencies if a group (or user) is created within the user management that has a principal \nname 'everyone'.\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-84",
        "summary": "WebDAV LocatorFactoryImpl$Locator.getHref() constructs root resource URLs incorrectly",
        "description": "cadaver was reporting an error when i tried to open / in my repository's default workspace at <https://localhost:8443/webdav/).\n\nin tracking down the problem, i saw something strange - the multistatus response's href had an extra \"/\" tacked onto the end:\n\n  <D:multistatus xmlns:D=\"DAV:\">\n    <D:response>\n      <D:href>https://localhost:8443/webdav//</D:href>\n\nWebdavServlet (rather, my subclass of it) is mapped as the default servlet of a webapp mounted at /webdav. i've configured the WebdavServlet with a resource path prefix of \"\" (incidentally, i'm not sure what that's meant to be used for - i see that when the value is not empty, it's appended to the response's href, but i don't know in what circumstance that would be useful).\n\nwhen i requested a child node such as <https://localhost:8443/webdav/bcm>, the response's href was formed as expected:\n\n  <D:multistatus xmlns:D=\"DAV:\">\n    <D:response>\n      <D:href>https://localhost:8443/webdav/bcm/</D:href>\n\ni found that LocatorFactoryImpl$Locator.getHref() was adding the extra \"/\" since the requested resource was a collection. i patched the method to not add the character when itemPath == \"/\", and cadaver stopped complaining. all is well.\n\ni also patched WebdavServlet to default to an empty resource path prefix if one is not specified as a servlet init parameter.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1519",
        "summary": "Property.getLength() returns -1 for BOOLEAN, REFERENCE and DATE values",
        "description": "It seems those three are simply missing in PropertyImpl.getLength().",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-922",
        "summary": "jcr mapping layer (OCM) should expose lock owner",
        "description": "jcr mapping layer 's  persistencemanager.java  does not expose an API for returning lockowner. Ideally   , the following method \n\npublic String lock(final String absPath, final boolean isDeep, final boolean isSessionScoped) \n\nshould return a hashmap/String array containing locktoken as well as lockowner. \n\nI tried having lockowner as a field in my java object and mapping it to jcr:lockOwner , so that I can just use getLockOwner() . But the problem is this property gets introduced in the node only if  the node is locked. So, when I try to insert a node , before I can even lock it , the insertion fails since there is no property like jcr:lockOwner   till then . \n\nSo, I feel there is need for the above API. It is ok to have it exposed via separate call in order to maintain backward compatability\n",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1468",
        "summary": "LockTest.testLogout fails to refresh session before checking lock from other session",
        "description": "LockTest.testLogout() fails to refresh the session before checking the lock state of a node that was locked by another session.\n\nProposal:\n\nInsert \n\n  n1.refresh(false);\n\nbefore \n\n  assertTrue(\"node must be locked\", n1.isLocked());\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1532",
        "summary": "ERROR 40XD0: Container has been closed exception with Derby DB",
        "description": "This seems very similar to JCR-1039, only I am getting it on 1.4 using the regular DatabasePersistenceManager.\nWas the fix for JCR-1039 in 1.3.3 merged to 1.4.x?\n\nHere is the relevant part of the exception:\n\nINFO | jvm 1 | 2008/04/10 14:00:37 | Caused by: javax.jcr.RepositoryException: failed to retrieve item state of item fb648866-a236-42aa-8039-df68f26dd2ad/{http://www.jcp.org/jcr/1.0}data: failed to read property state: fb648866-a236-42aa-8039-df68f26dd2ad/{http://www.jcp.org/jcr/1.0}data: failed to read property state: fb648866-a236-42aa-8039-df68f26dd2ad/{http://www.jcp.org/jcr/1.0}data\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.ItemManager.createItemInstance(ItemManager.java:570)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:395)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.NodeImpl.getProperty(NodeImpl.java:2553)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.artifactory.jcr.JcrFile.getStream(JcrFile.java:133)\nINFO | jvm 1 | 2008/04/10 14:00:37 | ... 55 more\nINFO | jvm 1 | 2008/04/10 14:00:37 | Caused by: org.apache.jackrabbit.core.state.ItemStateException: failed to read property state: fb648866-a236-42aa-8039-df68f26dd2ad/{http://www.jcp.org/jcr/1.0}data\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.load(DatabasePersistenceManager.java:406)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.state.SharedItemStateManager.loadItemState(SharedItemStateManager.java:1161)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.state.SharedItemStateManager.getNonVirtualItemState(SharedItemStateManager.java:1086)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.state.SharedItemStateManager.getItemState(SharedItemStateManager.java:248)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.state.LocalItemStateManager.getPropertyState(LocalItemStateManager.java:118)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.state.LocalItemStateManager.getItemState(LocalItemStateManager.java:150)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.state.XAItemStateManager.getItemState(XAItemStateManager.java:226)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState(SessionItemStateManager.java:175)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.ItemManager.createItemInstance(ItemManager.java:564)\nINFO | jvm 1 | 2008/04/10 14:00:37 | ... 58 more\nINFO | jvm 1 | 2008/04/10 14:00:37 | Caused by: javax.jcr.RepositoryException: Error creating temporary file: ERROR 40XD0: Container has been closed.: ERROR 40XD0: Container has been closed.\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.value.BLOBInTempFile.<init>(BLOBInTempFile.java:69)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.value.BLOBInTempFile.getInstance(BLOBInTempFile.java:103)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.value.InternalValue.getBLOBFileValue(InternalValue.java:630)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.value.InternalValue.create(InternalValue.java:265)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.persistence.util.Serializer.deserialize(Serializer.java:296)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.load(DatabasePersistenceManager.java:397)\nINFO | jvm 1 | 2008/04/10 14:00:37 | ... 66 more\nINFO | jvm 1 | 2008/04/10 14:00:37 | Caused by: java.io.IOException: ERROR 40XD0: Container has been closed.\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.derby.impl.store.raw.data.OverflowInputStream.fillByteHolder(Unknown Source)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.derby.impl.store.raw.data.BufferedByteHolderInputStream.read(Unknown Source)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at java.io.DataInputStream.read(DataInputStream.java:132)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at java.io.FilterInputStream.read(FilterInputStream.java:116)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at java.io.FilterInputStream.read(FilterInputStream.java:116)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at java.io.SequenceInputStream.read(SequenceInputStream.java:191)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at java.io.InputStream.read(InputStream.java:85)\nINFO | jvm 1 | 2008/04/10 14:00:37 | at org.apache.jackrabbit.core.value.BLOBInTempFile.<init>(BLOBInTempFile.java:61)\nINFO | jvm 1 | 2008/04/10 14:00:37 | ... 71 more",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1809",
        "summary": "Jcr2Spi: Avoid extra round trip to the SPI upon Node.getNode and Session.getItem",
        "description": "Upon Session.getItem/itemExists and Node.getNode/hasNode JCR2SPI currently tries to load the Node from the persistent layer (SPI) if no corresponding entry exists in the hierarchy.\n\nSince with JCR-1638 a flag has been introduced indicating if the child node entries are complete. In this case, the extra round trip could be omitted.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1153",
        "summary": "remove support for event bundle IDs",
        "description": "Event bundle IDs currently are not used. We can re-add them later in case we need them.\n",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3248",
        "summary": "TimeoutHandler visitor should be extracted into a dedicated class",
        "description": "This is a minor problem that I've stumbled upon when looking at a memory leak.\nIt seems that the TimeoutHandler thread runs each second and it uses a custom ElementVisitor to do its business. By creating a new instance of ElementVisitor each second this creates some garbage that could be avoided by using a predefined class.\n\nShort story: during a unit test it creates 3x instances each second that have 16 bytes each. Having a dedicated visitor class creates just 3 instances for the lifespan of the repository.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2317",
        "summary": "Lower log level for index updates from queue",
        "description": "The log level is currently at info and should be lowered to debug.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2877",
        "summary": "Extend the consistency check in BundleDbPersistenceManager's to fix child-parent relations",
        "description": "It could happen that a child node is not in the ChildNodeEntries of its parent node.\nYou will get something like (javax.jcr.ItemNotFoundException: failed to build path of node1: parentNode has no child entry for node1) if you try to retrieve the path from node1.\nWe should handle such cases and fix it on consistency check",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1625",
        "summary": "The repository-1.5.dtd is not well formed",
        "description": "The repository-1.5.dtd file at http://jackrabbit.apache.org/dtd/repository-1.5.dtd\nis not well formed at the time of this writing 200/05/23 19:30GMT\n\n1. It looks like a #REQUIRED is missing at line 173\n2. Detected this while trying the 5minutes with ocm tutorial\n\nHope this helps,\n S.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "BUG"
    },
    {
        "key": "JCR-2499",
        "summary": "Add simple benchmarking tools for jcr2spi read performance",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": "TASK"
    },
    {
        "key": "JCR-2899",
        "summary": "[patch] fix uppercase/lowercase handling for not equal to",
        "description": "code is missing breaks in switch statements, which causes both uppercase and lowercase terms to the not equal to lucene search. patch fixes.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2624",
        "summary": "Reduce memory usage of ParentAxisScorer",
        "description": "The ParentAxisScorer keeps a map of non-default scores while it calculates the parent matches of the context scorer. In most cases the scores are not equal to the default score, but still may be all the same.\n\nThe scorer should therefore use the first score value as the default instead of the currently used 1.0f.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1241",
        "summary": "NodeIndexer creates unnecessary string representation of Name value",
        "description": "NodeIndexer.addNameValue() calls Name.toString() but never uses it.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-371",
        "summary": "ItemStateException on concurrently committing transactions of versioning operations",
        "description": "see tests in JCR-335\n\n\norg.apache.jackrabbit.core.state.ItemStateException: Unable to resolve path for item: 69d80165-7ef5-4b6b-8aa9-be9c9be1f994\n\tat org.apache.jackrabbit.core.observation.EventStateCollection.getPath(EventStateCollection.java:525)\n\tat org.apache.jackrabbit.core.observation.EventStateCollection.createEventStates(EventStateCollection.java:377)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:547)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:668)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:151)\n\tat org.apache.jackrabbit.core.version.XAVersionManager.prepare(XAVersionManager.java:431)\n\tat org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:129)\n\tat org.apache.jackrabbit.core.XASessionImpl.prepare(XASessionImpl.java:309)\n\tat test.JCRUserTransaction.commit(JCRUserTransaction.java:74)\n\tat org.apache.jackrabbit.JRTestDeadlock.run(JRTestDeadlock.java:110)\nCaused by: javax.jcr.ItemNotFoundException: failed to build path of 69d80165-7ef5-4b6b-8aa9-be9c9be1f994: a0ecd4b0-a442-4b1e-a2f6-51441f40d452 has no child entry for 69d80165-7ef5-4b6b-8aa9-be9c9be1f994\n\tat org.apache.jackrabbit.core.HierarchyManagerImpl.buildPath(HierarchyManagerImpl.java:308)\n\tat org.apache.jackrabbit.core.HierarchyManagerImpl.getPath(HierarchyManagerImpl.java:357)\n\tat org.apache.jackrabbit.core.observation.EventStateCollection.getPath(EventStateCollection.java:520)\n\t... 9 more",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2075",
        "summary": "JSR 283: Identifier based event filtering",
        "description": "JSR 283 PFD states:\n\nOnly events whose associated parent node has one of the identifiers in the uuid String array will be received. If this parameter is null then no identifier-related restriction is placed on events received. Note that specifying an empty array instead of null results in no nodes being listened to. The uuid is used for backwards compatibility with JCR 1.0.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2161",
        "summary": "Deprecate org.apache.jackrabbit.api.JackrabbitNodeTypeManager in 2.0 and 1.6",
        "description": "The JackrabbitNodeTypeManager defines 3 methods that can be removed for version 2.0 since they are no longer needed:\n\n    NodeType[] registerNodeTypes(InputSource in)  throws SAXException, RepositoryException;\n    NodeType[] registerNodeTypes(InputStream in, String contentType)  throws IOException, RepositoryException;\n\nthose deal with directly register nodetypes from a XML or CND source. since we don't want to support XML serialization any longer, and the CND import can be easily done using the spi-commons CompactNodeTypeDefReader with the new JCR2.0 node type registration. if the XML is to be supported, i suggest to detach the reader similar to the CND one.\n\n    boolean hasNodeType(String name) throws RepositoryException;\n\nthis is now in the JCR2.0 api\n",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": ""
    },
    {
        "key": "JCR-1856",
        "summary": "Change value for SearchIndex#DEFAULT_EXTRACTOR_BACK_LOG",
        "description": "The value is currently 100. This means that once 100 extractor jobs are pending in the indexing queue additional extractor jobs are executed with the current thread. I think it would be more useful to change this value to Integer.MAX_VALUE (or in other words: unbounded).\n\nIf the backlog is filled up then this indicates that the repository is very busy and we should not put additional burden on the current thread in that case.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2307",
        "summary": "BLOBFileValue.read(byte[] b, long pos) ignores return value of InputStream.skip",
        "description": "InputStream.skip(long n) returns a long, which may be different from the parameter n (possibly lower).\nCurrently in BLOBFileValue.read(byte[] b, long pos) the return value is ignored.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-968",
        "summary": "Add support for tablespaces to Oracle related classes",
        "description": "When a user account for an Oracle database has no or a temporary default tablespace, then the appropriate database schemas cannot be created. This is an issue for at least the following packages:\n- o.a.j.core.persistence.bundle\n- o.a.j.core.persistence.db\n- o.a.j.core.fs.db\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2665",
        "summary": "JCR Test for Adding Node Type Tests That Abstract Nodes Can Be Added as Children, contrary to JCR 2.0 specification",
        "description": "When the TCK test method testLegalAndResidualType in the CanAddChildNodeCallWithNodeTypeTest class picks a node with a residual type, it does not filter out abstract nodes.  For example, in my local test, nt:hierarchyNode is selected for the local variable 'type'.\n\nSince abstract node types \"cannot be directly assigned to a node,\"[1] canAddChildNode(anyPropertyName, \"nt:hierarchyNode\") must return false.  However, since the test assumes that a non-abstract node type was chosen, it expects canAddChildNode(String, String) to return true.\n\nThis could be fixed if NodeTypeUtil.locateChildNodeDef(...) were extended to add an extra argument allowing or disallowing abstract types and that extra argument was used to filter the type used in testLegalAndResidualType (or if locateChildNodeDef(...) automatically excluded abstract types in the same manner that it automatically excludes protected types).\n\n[1] - Section 3.7.1.3 of the JCR2 specification",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-1027",
        "summary": "SPI: change param order with RepositoryService.createBatch",
        "description": "all methods on RepositoryService that require a SessionInfo list the info as first parameter, except for \n\nRepositoryService.createBatch(ItemId, SessionInfo) \n\nunless someone objects i would refacter the method signature for consistency reasons.\n\nnew:\n\nRepositoryService.createBatch(SessionInfo, ItemId)",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-35",
        "summary": "NodeTypeDefDiff compares to restrictive",
        "description": "The NodeTypeDefDiff class is used to compare NodeTypeDef instances. Unfortunately this class reports two NodeTypeDef instances which are not equal but have no structural difference as having trivial changes. The correct result would be to have no modification at all.\n\nI suggest to modify the NodeTypeDefDiff.init() method such, that the initial type is \"NONE\" instead of \"TRIVIAL\" and to first compare the \"hasOrderableChildNodes\" first and raise the level to \"TRIVIAL\" if not equal. Next the rest of the current comparisons would follow.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1232",
        "summary": "Merge UUID to NodeId",
        "description": "The current NodeId class is mostly just a wrapper around UUID, which causes two objects to be instantiated for each node identifier that the system uses. The memory and processing overhead is quite small, but given that there are tons of NodeId instances it would be good to eliminate that overhead.\n\nThere is also lots of code that just converts UUIDs to NodeIds and vice versa. We could simplify such code if we just used NodeId everywhere.\n\nAlso, we might want to open up the possibility of using non-UUID node identifiers at some point in future, so it would make a lot of sense to remove the NodeId.getUUID method and rely directly on NodeId and it's equals(), hashCode(), and toString() methods in many places where we currently use UUIDs.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2454",
        "summary": "spi2dav: JSR 283 NodeType Management",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1762",
        "summary": "Improvement to MultiValueCollectionConverterImpl to Map collections with element class Object.class",
        "description": "Currently MultiValueCollectionConverterImpl  does not support elements of type Object.class.  The type of the contained class has to be specified either through the mapping file or through the Bean annotation.  Even with that flexibility Object.class is specifically excluded (For good reasons.).  \n\nMy view is that by definition MultiValueCollectionConverterImpl   should make a best effort to convert and that best effort should include using Undefined UndefinedTypeConverterImpl to convert an object when all the other conversion strategies run out.  To this resolve I have patched the OCM source.  I have test cases also.  I will upload the patch files right after.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2061",
        "summary": "JSR 283: References and Dereferencing of Property Values",
        "description": "References\n--------------------------------------------------------------------------------------------------------------------------\nnew methods are:\n\n- Node.getReferences(String name) PropertyIterator \n- Node.getWeakReferences() PropertyIterator \n- Node.getWeakReferences(String name) PropertyIterator\n\n\nDerferencing\n--------------------------------------------------------------------------------------------------------------------------\nAs of JSR 283 the following property types may be dereferenced to a Node:\n\n- REFERENCE\n- WEAKREFERENCE\n- PATH\n- any type that can be converted to either of the types above\n\nThe new method\n- Property.getProperty() returns the Property pointed to by a PATH value.\n- any type that can be converted to PATH\n\n\n\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1547",
        "summary": "JCR2SPI: remove dependency to state-package within nodetype package",
        "description": "",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2100",
        "summary": "jackrabbit-jcr-tests should still be based on Java 1.4",
        "description": "The JCR 2.0 TCK needs to be runnable on Java 1.4, so even though we've upgraded to Java 5 as the base platform for Jackrabbit 2.0, the jackrabbit-jcr-tests component needs to still be based on Java 1.4.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2229",
        "summary": "Improve behaviour when 'too many open files' occurs",
        "description": "The MultiIndex may leave unused directories that were created in an attempt to create an index segment. The directory is not removed again when an error occurs (e.g. 'too many open files').",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-107",
        "summary": "Typos in jcr-server io package javadocs",
        "description": "",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2333",
        "summary": "ItemImpl#validateTransientItems: Incomplete validation of mandatory child item",
        "description": "ItemImpl#validateTransientItems iterates over all mandatory child node/property definitions in order to assert that those items have\nbeen created. However, it only checks if an item with the name defined by the mandatory item definition is present and not if that\nexisting item really has the mandatory definition.\n\nthe example i had:\n- mandatory single-value property.\n- there is the possibility to add residual props\n- added a residual property with the name of the mandatory prop but with multiple values\n\n-> changes are saved without exception.\n-> the node doesn't have a property with the mandatory definition.\n\n((without having tried it out, i think the same would be possible with child nodes))\n\nsuggested fix:\nif there is a child item with the mandatory-item-name -> make sure it's definition is mandatory (or the expected one...)\npatch will follow.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2718",
        "summary": "Incorrect results from joins on multivalued properties",
        "description": "It looks like join conditions on multivalued properties only use one of the multiple values for the comparison.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2429",
        "summary": "Clustering is broken due to duplicated CachingPersistenceManager interface",
        "description": "There are now two interfaces CachingPersistenceManager in the packages org.apache.jackrabbit.core.persistence.bundle and org.apache.jackrabbit.core.persistence.pool. A persistence manager that implements the ..bundle... interface doesn't receive the onExternalUpdate events that are required for clustering to work.\n\nI will move this interface to the package org.apache.jackrabbit.core.persistence and remove the second implementation.\n\nThis change has no affect to backward compatibility, because anyway there were many breaking changes in the past (NodeId / UUID for example).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1183",
        "summary": "JCR2SPI: potential race condition in event listener registration",
        "description": "There's a potential race condition when the first event listener is registered (ObservationManager.addEventListener). The observation manager should only start listening for events after the new SPI event filter has been created.\n\n(Note there's a related problem when an *additional* event listener is getting registered, while a RepositoryService.getEvents call is already in progress).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3085",
        "summary": "better diagnostics when version storage is broken",
        "description": "In InternalVersionManagerBase, the code doesn't do a null-check on the predecessors property, assuming it'll always be present. When this is not the case due to a repository problem, we'll see a NPE.\n\nProposal: add code that generates a more meaningful error message; making it easier to debug in production.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1332",
        "summary": "CLONE -Aggregate include ignored if no primaryType set",
        "description": "If the include element of an aggregate definition does not have a primaryType attribute then the include is never matched.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-407",
        "summary": "read IOHandlers from the config.xml",
        "description": "I would like to be able to change the order of the IOHandlers and add some.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-725",
        "summary": "Configuration of CacheManager memory sizes",
        "description": "(I already posted this as comments under JCR-619.)\n\nThe maximum size for all caches in CacheManager is hardcoded to 16 megabytes and there's no way to change that. It would be nice if this as well as other CacheManager parameters were configurable. It's just a waste running Jackrabbit on a server with gigabytes of memory and only using 16 megabytes for cache...\n\nI have created a really simple and straightforward patch (jackrabbit-cachemanager-config.patch) which enables reaching the CacheManager instance through RepositoryImpl object and setting all three of its memory parameters. The memory parameters are no longer static constants, but instance fields getting initial values from constants (so the default behavior of the class remains the same).\n\n(It would be even nicer if these parameters were configurable via configuration files, but that should probably be implemented by someone close to the project.)",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1733",
        "summary": "WebDAV BIND support",
        "description": "I'm tempted to work on implementing the WebDAV BIND protocol, as currently defined in http://greenbytes.de/tech/webdav/draft-ietf-webdav-bind-20.html.\n\nThis issue can be used to collect design proposals and track progress.\n\n1) DAV:resource-id live property\n\nThis can be implemented in terms of the JCR UUID. However, we need to turn this one into a URI for WebDAV. If the JCR UUID happens to *really* use UUID syntax, we *could* use urn:uuid. Otherwise, it would probably useful to mint an HTTP URI, served by the WebDAV servlet. (note that the latter has the disadvantage that moving a node to a different server will affect its resource-id, in case that other server allows importing UUIDs).\n\n2) REBIND and UNBIND methods\n\nSame as MOVE and DELETE, with the excpetion of marshalling.\n\n3) DAV:parent-set property\n\nEither trivial (when node isn't shared), or needs to use the JCR 2.0 shared set functionality.\n\n4) BIND method\n\nEither trivial (when shareable nodes aren't supported), or needs to use the JCR 2.0 shared set functionality.\n\n5) Cycle detection in depth:infinity requests\n\nTBD :-)\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1586",
        "summary": "Create org.apache.jackrabbit.api.jsr283 (in jackrabbit-api) and move future jsr283 interfaces and classes there",
        "description": "(as discussed on mailing list)\n\nas the implementation of the new features for jsr283 have started, i\nsuggest to put the new jsr283 interfaces to jackrabbit-api instead to\ncore (where possible). this way, we can already figure out\ninter-module dependency issues and people can start using experimental\nfeatures through an API than rather through casting objects to core\ninterfaces.\n\nsuggestion: use 'org.apache.jackrabbit.api.jsr283' as base package for\nthe new jsr283 interfaces and classes.\n\nfor example, use\norg.apache.jackrabbit.api.jsr283.nodetype.NodeDefinitionTemplate\nfor the future javax.jcr.nodetype.NodeDefinitionTemplate\n\nonce jcr2.0 is released, we will drop the interim interfaces.\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2798",
        "summary": "JCAManagedConnectionFactory should chain cause exception",
        "description": "In JCAManagedConnectionFactory, methods openSession and createRepository both throw ResourceException without setting the cause exception.  This can result in the actual error being swallowed silently, and only stepping through the running code at this point will reveal the actual error (eg: Persistent Store configuration error will appear as a pool exception).\n\nJukka Zitting on 12-Oct-2010 said:\n\nThis constructor is not available in J2EE version 1.3, so for now\nwe've been using the ResourceException.setLinkedException() method for\nthis (see JCR-761). To address your need we could either upgrade the\nplatform requirement to J2EE 1.4 or start using the J2SE method\nException.initCause() instead of setLinkedException(). Can you file an\nimprovement issue in Jira about this?",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-195",
        "summary": "ArrayIndexOutOfBounds thrown on re-index of repository",
        "description": "I encountered a problem with the Lucene NodeIndexer when forcing the repository to re-index itself.\n\nUsing the default repository.xml file provided with the examples contribution, I loaded a number of PDF files using the sample application FSImport.  In this utility, the \"encoding\" property is set to the empty string \"\" for all the files.  The system appeared to index everything properly.  I then stopped the repository, deleted the index files and then restarted the repositoyr.  Re-indexing was initiated and a \"ArrayIndexOutOfBoundsException\" was thrown from the org.apache.jackrabbit.core.query.lucene.NodeIndexer.java\n\nThe code in question:\n\n                // jcr:encoding is not mandatory\n                String encoding = null;\n                if (node.hasPropertyName(JCR_ENCODING)) {\n                    PropertyState encodingProp =\n                            (PropertyState) stateProvider.getItemState(new PropertyId(node.getUUID(), JCR_ENCODING));\n                    encodingProp.getValues()[0].internalValue().toString();\n\n\n                }\n\nExpects the encodingProperty to be set if the property exists.  However, the node has the property, but the XMLPersistenceManager did not create any entries in the property array.  Either there is a problem in the XMLPersistenceManager (zero length string issues), or the NodeIndexer needs to be altered to verify that there is actually a value for a particular property.\n\nSince the jcr:encoding property is not considered a multi-value property, the requirement to check for an initialized array is probably not the correct route.\n\nLooking at the code for the XMLPersistenceManager readState(DOMWalker walker, PropertyState state) method (line 294), it indicates that if the content length for a property is zero, the property will not have a value added.  However, our encoding property is configured as the empty string and should be created.  Therefore, a suggested alteration is to check if the property is a string, and, even if zero length, add the property value.\n\n        ArrayList values = new ArrayList();\n        if (walker.enterElement(VALUES_ELEMENT)) {\n            while (walker.iterateElements(VALUE_ELEMENT)) {\n                // read serialized value\n                String content = walker.getContent();\n                if ((content.length() > 0) || (PropertyType.STRING == type)) {   // <==== suggested update\n                    if (type == PropertyType.BINARY) {\n                        // special handling required for binary value:\n                        // the value stores the path to the actual binary file in the blob store\n                        try {\n                            values.add(InternalValue.create(new FileSystemResource(blobStore, content)));\n                        } catch (IOException ioe) {\n                            String msg = \"error while reading serialized binary value\";\n                            log.debug(msg);\n                            throw new ItemStateException(msg, ioe);\n                        }\n                    } else {\n                        values.add(InternalValue.valueOf(content, type));\n                    }\n                }\n            }\n            walker.leaveElement();\n        }\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-83",
        "summary": "Text Search Syntax Deviates from Spec",
        "description": "Original JSR 170 EG Email by David B Victor 2005/03/23:\n\nFor Query test XPathQueryLevel2Test.java (src\\java\\org\\apache\\jackrabbit\\test\\api\\query) in the TCK, method getFullTextStatement() (used by testFullTextSearch()) uses the word \"AND\" in the syntax in its test that is not in the spec (/*[jcrfnContains(\"'quick brown' AND -cat\")]...).  Section \"6.6.4.2 contains function\" of v0.16.3, page 100, outlines the EBNF, which does not include the word \"AND\".  Additionally, the paragraphs here go out of their way to explain that AND is implicit.\n\nAt this point, I think it would be best to omit \"AND\" from the TCK method and let it test the implicit AND.\n\n------------------------------------------------------------\nDavid Neuscheler Reply 2005/03/24:\n\nthanks for pointing that out.\n\ni think we should probably track all the tck bugs in jackrabbit jira.\nhttp://issues.apache.org/jira/browse/JCR\n\ncould you open a bug for that?\n\nthis actually is because we used an non-spec compliant query\nparser in the RI, so it actually is even a bug in the RI and the TCK.\n\nthanks again.\n\nregards,\ndavid",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-1571",
        "summary": "DavMethodBase#getResponseException fails if the body is not (valid) XML",
        "description": "I have a set up that uses the JCR Webdav Server from a custom remote client.\nI've noticed one thing, anytime I request a node that doesn't exist the error that comes back from the server is as follows:\n\n[Fatal Error] :1:941: The element type \"HR\" must be terminated by the matching end-tag \"</HR>\".\njavax.jcr.RepositoryException: The element type \"HR\" must be terminated by the matching end-tag \"</HR>\".: The element type \"HR\" must be terminated by the matching end-tag \"</HR>\".\n\nDoesn't really make sense, but that is OK, I can handle that.\n\nMy problem:\nI have a partially populated repository that at the root has a few nodes like\n/edu/....\n/com/ibm/..\n\nSo, I want to create a few nodes of type nt:folder under\n\ncom/myCompany/folder1\n\nI have no problem creating them, but since \"com\" already exists I end up with\ncom[2]/myCompany/folder1.\n\nSo, I went ahead and used the parentNode.hasNode(\"folderName\") method.\n\nThis method returns true for the \"com\" portion, but when I test for the \"myCompany\" folder which should return false I get the error response shown above from the server.\n\nThe webdav request looks as follows:\nPROPFIND /jackrabbit/server/default/jcr%3aroot/com/myCompany\n\nThe snippet of code looks as follows:\n  private Node createFolders (Session session, Node parentNode, List <String> folders)\n\t  throws RepositoryException {\n    Node folderNode = null;\n    for (String folder : folders) {\n\tif (parentNode.hasNode(folder))\n\t    folderNode = parentNode.getNode(folder);\n\telse\n\t    folderNode = parentNode.addNode(folder, \"nt:folder\");\n\tparentNode = folderNode;\n    }\n    session.save();\n    return (folderNode);\n  }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-847",
        "summary": "Provide a Method getCredentialsProvider to the SimpleWebdavServlet",
        "description": "It will be useful to provide a easy way to change the default CredentialsProvider (BasicCredentialsProvider) when the SessionProvider will be created.\nIt makes sense to let the SessionProvider return a other CredentialsProvider so that no BasicAuthentication wil be prompt.\nthanks\nclaus",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1133",
        "summary": "JCR2SPI: VersionHistoryImpl.getQLabels() needs to skip jcr:mixinTypes as well",
        "description": "getQLabels() iterates through the properties on a version labels node to compute the set of labels. Currently it only ignores jcr:primaryType, but it needs to skip jcr:mixinTypes as well.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1477",
        "summary": "Incorrect link on Apache Jackrabbit Welcome homepage",
        "description": "Link to JSR283 in welcome text points to http://jcp.org/en/jsr/detail?id=170 instead of http://jcp.org/en/jsr/detail?id=283",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-3036",
        "summary": "WebDAV/DaveX Servlets susceptible to CSRF Attacks",
        "description": "Both the WebDAV and the remoting (DaveX) servlets are susceptible to CSRF attacks.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2176",
        "summary": "o.a.j.spi.commons.nodetype.NodeTypeDefinitionFactory does not set required type",
        "description": "NodeTypeDefinitionFactory does not set required type for property definitions.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-929",
        "summary": "Under Heavy load in a Cluster HTTP Threads Block and stall requests",
        "description": "Under Heavy load created by mounting both nodes in the cluster in OSX Finder and then uploading large numebers of files to each node at the same time ( a few 1000), eventually one of the nodes stops responding and the Finder mount timesout and disconnects.\n\nOnce that happens that node becomes unusable.\nMore mount attempts will prompt for a password indicating HTTP is still running, but will timeout once the connection is authenticated.\nAccess by the Web Browser will prompt for a password, conenct and provide a once only listing of any collection in the workspace. If you try to refresh that collection, the HTTP request hangs forever.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-767",
        "summary": "Use Maven dependency management",
        "description": "Many of the Jackrabbit components have dependencies to each other and to external libraries,\nwhose versions should ideally be the same for all the Jackrabbit components. To guarantee\nthe use of same depedency versions and to simplify overall depedency management we should\nstart using the Maven depedencyManagement feature in the Jackrabbit parent pom.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1073",
        "summary": "Add getTotalSize() to QueryResults",
        "description": "As discussed in http://www.nabble.com/Total-size-of-a-query-result-and-setLimit%28%29-tf4280909.html#a12185543 a getTotalSize() method should be added to QueryResults.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1717",
        "summary": "Configure occurrence of property value in excerpt",
        "description": "Jackrabbit currently includes all indexed property values as potential content in an excerpt. This is not always desirable because there may be properties that need to be full-text indexed but should not show up in an excerpt.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2650",
        "summary": "don't silently merge session-local transient changes with external changes before save().",
        "description": "currently, external changes (i.e. changes committed by other sessions) are silently merged with transient changes. this might potentially cause concurrency issues/inconsistent transient state (see e.g. JCR-2632).\n\nit would probably be better to isolate transient changes from external changes until they're saved (true copy-on-write). ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-27",
        "summary": "ArrayIndexOutofBoundException while setting a reference property",
        "description": "I have a node whith a multivalued reference property.\nI try to add a reference as follows (the spec is outdated at this point, so I'm not sure if I use the right approach to add a reference):\n\n  ReferenceValue rv = new ReferenceValue(rn.getNode(\"pages/mjo:page\"));\n  Value[] values = {rv};\n  tstN.setProperty(\"mjo:testCon\",values);\n  session.save();\n\nThis results in a \n\n2004-12-09 16:11:43,614 WARN org.apache.jackrabbit.core.ItemManager - node at /pages/mjo:page has invalid definitionId (1512950840)\njava.lang.ArrayIndexOutOfBoundsException: 0\n\tat org.apache.jackrabbit.core.ItemImpl.validateTransientItems(ItemImpl.java:626)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1148)\n\tat org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:633)\n\tat de.freaquac.test.JCRTest.main(JCRTest.java:174)\n\nArrayIndexOutOfBoundsException is never a good sign, so I assume it's a bug. I should say that crx throws the same exception if I try it there.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-976",
        "summary": "Misleading exception message when re-index fails",
        "description": "E.g. the log may say:\n\n19.06.2007 11:25:42 *ERROR* RepositoryImpl: Failed to initialize workspace 'default' (RepositoryImpl.java, line 382)\njavax.jcr.RepositoryException: Error indexing root node: 10022d38-c449-4751-b8f0-9d07ac45ead5:\n[...]\n\nThe mentioned uuid is not the root node and the root cause is missing.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2952",
        "summary": "PrivilegeHandlerTest fails on Windows",
        "description": "The test fails on Windows because there are differences in line breaks between expected and actual results.",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-1143",
        "summary": "NullPointerException in ClassDescriptor",
        "description": "Index: /Users/cziegeler/Developer/workspaces/default/jackrabbit/contrib/jackrabbit-jcr-mapping/jcr-mapping/src/main/java/org/apache/jackrabbit/ocm/mapper/model/ClassDescriptor.java\n===================================================================\n--- /Users/cziegeler/Developer/workspaces/default/jackrabbit/contrib/jackrabbit-jcr-mapping/jcr-mapping/src/main/java/org/apache/jackrabbit/ocm/mapper/model/ClassDescriptor.java\t(revision 579109)\nIf a class descriptor (for whatever reason) does not have a jcr type, a npe is thrown in ClassDescriptor.\nThe following patch solves this issue:\n\n+++ contrib/jackrabbit-jcr-mapping/jcr-mapping/src/main/java/org/apache/jackrabbit/ocm/mapper/model/ClassDescriptor.java\t(working copy)\n@@ -468,7 +468,7 @@\n         while (iterator.hasNext()) {\n             ClassDescriptor descendantClassDescriptor = (ClassDescriptor) iterator.next();\n   \n-            if (descendantClassDescriptor.getJcrType().equals(nodeType)) {\n+            if (nodeType.equals(descendantClassDescriptor.getJcrType())) {\n                 return descendantClassDescriptor;\n             }\n   \n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-242",
        "summary": "registration of new namespace does not respect existing session mappings",
        "description": "consider the following (starting with a default namespace registry):\n\n// remap nt namespace\nSession.setNamespacePrefix(\"foobar\", \"http://www.jcp.org/jcr/nt/1.0\");\n\n// create new namespace\nNamespaceRegistry.registerNamespace(\"foobar\", \"http://www.foo.org/bar/1.0\");\n\nnow the session used above that remapped the nt namespace has an ambigous namespace mapping:\nfoobar --> \"http://www.jcp.org/jcr/nt/1.0\"\n\"http://www.jcp.org/jcr/nt/1.0\" --> foobar\n\"http://www.foo.org/bar/1.0\" --> foobar\n\ni.e. the new foobar namespace is hidden for this session. either the registration should not work, or an automatic prefix is to be defined in all local session mappings.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-366",
        "summary": "Allow o.a.j.jca.JCARepositoryManager to load repository configuration from the classpath.",
        "description": "The current implementation of o.a.j.jca.JCARepositoryManager is only able to load configuration files from the file system. It would be useful to allow the configuration to be loaded from the classpath also.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1120",
        "summary": "RemoveVersionTest.testReferentialIntegrityException assumes availability of ref properties and same name sibilings",
        "description": "This test case:\n\n- assumes availability of Reference properties (should throw NotExecutable when not available), and\n\n- takes advantage if same name siblings (the child node identified by the nodename2 config variable has already been created by the test setup code)",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-758",
        "summary": "QueryResult's RowIterator.getSize returned the wrong size of the results after I implemented my own AccessManager",
        "description": "The background is I have implemented my own AccessManager. After executing a query and get back the RowIterator from the result, if I call rowiterator.getSize, it will return the size of all nodes matching my query (without honoring the access control) . But if I iterate through the result, I find lots of duplicates in the results; and if I filter out those duplicate, the final result is quite off the original number from RowIteartor.getSize()\n\nBTW, I also disabled Doc Order sorting.\n\n ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1046",
        "summary": "Non-versionable children of a versionable node should not be updated when a merge fails",
        "description": "The JCR specification (JSR-170) includes a merge algorithm that is inconsistent with the functionality described elsewhere in the JCR specification. Specifically from JSR-170 section 8.2.10 Merge:\n\n\"In either case, (regardless of whether bestEffort is true or false) for each non-versionable node (including both referenceable and non-referenceable), if the merge result of its nearest versionable ancestor is update, or if it has no versionable ancestor, then it is updated to reflect the state of its corresponding node. Otherwise, it is left unchanged.\"\n\nThe algorithm presented in 8.2.10.1 of the specification goes against the above statement as it does not take into consideration the merge result of the nearest versionable ancestor.\n\nOne solution would be to have the doLeave(n) call that dofail(n, v') calls altered to only perform a merge on the versionable children rather than all of the children. The merging of all children (versionable and non-versionable) should only be done if the nearest parent is not in a failed merge state regardless of whether the failure occurred from the current merge operation or a previous merge operation.\n\nI will attach a patch file that makes what I think is the required change.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3236",
        "summary": "Can not instantiate lucene Analyzer in SearchIndex",
        "description": "In the Lucene 3, the there is no default constructor anymore in Analyzer classes\n\n\n11:46:45.946 [main] WARN  o.a.j.core.query.lucene.SearchIndex - Invalid Analyzer class: org.apache.lucene.analysis.standard.StandardAnalyzer\njava.lang.InstantiationException: org.apache.lucene.analysis.standard.StandardAnalyzer\n        at java.lang.Class.newInstance0(Class.java:340) ~[na:1.6.0_26]\n        at java.lang.Class.newInstance(Class.java:308) ~[na:1.6.0_26]\n        at org.apache.jackrabbit.core.query.lucene.SearchIndex.setAnalyzer(SearchIndex.java:1892) ~[jackrabbit-core-2.4.0.jar:2.4.0]\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.6.0_26]\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) ~[na:1.6.0_26]\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) ~[na:1.6.0_26]\n        at java.lang.reflect.Method.invoke(Method.java:597) ~[na:1.6.0_26]\n        at org.apache.jackrabbit.core.config.BeanConfig.setProperty(BeanConfig.java:255) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.config.BeanConfig.newInstance(BeanConfig.java:203) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.config.RepositoryConfigurationParser$1.getQueryHandler(RepositoryConfigurationParser.java:652) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.config.WorkspaceConfig.getQueryHandler(WorkspaceConfig.java:251) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.SearchManager.<init>(SearchManager.java:171) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getSearchManager(RepositoryImpl.java:1855) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.doPostInitialize(RepositoryImpl.java:2092) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.initialize(RepositoryImpl.java:1997) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.RepositoryImpl.initStartupWorkspaces(RepositoryImpl.java:510) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:318) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:582) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.jndi.BindableRepository.createRepository(BindableRepository.java:141) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.jndi.BindableRepository.init(BindableRepository.java:117) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.jndi.BindableRepository.<init>(BindableRepository.java:106) [jackrabbit-core-2.4.0.jar:2.4.0]\n        at org.apache.jackrabbit.core.jndi.BindableRepositoryFactory.getObjectInstance(BindableRepositoryFactory.java:52) [jackrabbit-core-2.4.0.jar:2.4.0]\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2931",
        "summary": "Compatibility issue if admin impersonates admin session",
        "description": "in revision 1076596 in made some improvements in ImpersonationImpl removing the shortcut for \"AdminPrincipal\" which from my point of view is problematic.\n\nhowever, this introduced the following compatibility issue (detected by tom):\nwhile - according to my tests - a user is allowed to impersonate itself (jcr isn't totally clear about this but states that Session.impersonate is used to \"[...] impersonate\" another [...]\" this was possible for the admin-user due to the shortcut mentioned above.\n\nin order not to break existing code relying on that special case, i would suggest to change the code accordingly.\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2007",
        "summary": "Importing strings with special characters fails",
        "description": "Both Session.importXML and Workspace.importXML don't work correctly in some cases.\n\nImporting very large foreign language (for example, Chinese) text property values could result in incorrect values on some platforms. The reason is, BufferedStringValue (buffers very large string to a temporary file) uses the platform default encoding to read and write the text.\n\nBufferedStringValue is relatively slow on some systems when importing large texts or binary data because of using FD().sync().\n\nIf an exported string value contains a carriage return (\\r), this character was truncated on some platforms.\n\nIf an exported string value contains a characters with code below 32 excluding newline (\\n) and tab (\\t) - for example form feed (\\f) - the imported string value was base64 encoded.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1919",
        "summary": "Update copyright year to 2009",
        "description": "Our normal license headers don't contain copyright years, but the NOTICE.txt files do. We should update the year to 2009 where appropriate.\n",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-695",
        "summary": "Repository requires access to external resource",
        "description": "With the changes from JCR-626 jackrabbit requires access to the resource at the URL http://jackrabbit.apache.org/dtd/repository-1.2.dtd. If no connection to the internet is available jackrabbit will refuse to start. At least that's the case when I run the test cases in the above mentioned environment.\n\nI'm not an XML expert, but shouldn't the doctype declaration use a public identifier? Otherwise the ConfigurationEntityResolver class doesn't make much sense.\n\nThe attached patch solve the issue for me, please comment. I've also targetted this issue for 1.2 because it seems rather serious to me if you can't start jackrabbit when you don't have an internet connection, or am I the only one with this issue?",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1811",
        "summary": "Jcr2Spi: ExportSysViewTest#testExportSysView_handler_session_saveBinary_* occasionally failing",
        "description": "from time to time i saw ExportSysViewTest#testExportSysView_handler_session_saveBinary_* test failing. this doesn't occur consistently and i never managed to reproduce it when running the tests in the idea.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-568",
        "summary": "incorrect jcr:uuid on frozen subnode",
        "description": "The following program:\n\nimport javax.jcr.Repository;\nimport javax.jcr.Session;\nimport javax.jcr.SimpleCredentials;\nimport javax.jcr.Node;\nimport org.apache.jackrabbit.core.TransientRepository;\n\npublic class debug2 {\n    public static void main(String[] args) throws Exception {\n        Repository repository = new TransientRepository();\n        Session session = repository.login(\n                new SimpleCredentials(\"username\", \"password\".toCharArray()));\n        try {\n            Node root = session.getRootNode();\n\n            Node foo = root.addNode(\"foo\");\n            foo.addMixin(\"mix:versionable\");\n\n            Node bar = foo.addNode(\"bar\");\n            bar.addMixin(\"mix:referenceable\");\n            System.out.println(\"bar:            \" + bar.getUUID());\n\n            session.save();\n            foo.checkin();\n\n            Node frozenbar = foo.getBaseVersion().getNode(\"jcr:frozenNode\").getNode(\"bar\");\n            System.out.println(\"frozenbar UUID: \" + frozenbar.getUUID());\n            System.out.println(\"jcr:uuid:       \" + frozenbar.getProperty(\"jcr:uuid\").getValue().getString());\n            System.out.println(\"jcr:frozenUuid: \" + frozenbar.getProperty(\"jcr:frozenUuid\").getValue().getString());\n\n        } finally {\n            session.logout();\n        }\n    }\n}\n\nGives as sample output:\nbar:            fcf0affb-7476-4a64-a480-3039e8c53d53\nfrozenbar UUID: ed9fece9-9837-4ecc-9b7e-55bdfb8284e2\njcr:uuid:       fcf0affb-7476-4a64-a480-3039e8c53d53\njcr:frozenUuid: fcf0affb-7476-4a64-a480-3039e8c53d53\n\nThe jcr:uuid of the frozen bar is incorrect (althoug getUUID() returns the correct value).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-995",
        "summary": "Release the OCM component",
        "description": "The contrib/jackrabbit-jcr-mapping/jcr-mapping should be promoted from contrib into a jackrabbit-jcr-ocm component.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3175",
        "summary": "InputContextImpl: cannot upload file larger than 2GB",
        "description": "If an entity is larger than 2GB, the Content-Length cannot be obtained by using getIntHeader because of integer overflow. One needs to parse the value of the header from string to long. This issue affects InputContextImpl.getContentLength() in org.apache.jackrabbit.webdav.io from webdav/java (the current behavior is that the header is converted from string to int by the servlet API, then from int to long by Jackrabbit)\n\nTestcase: largefile from Litmus. (test 3 - large_put fails when the PUT request is received)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2091",
        "summary": "Searchability settings in PropertyDefinition",
        "description": "Related to JCR-1591, the new JCR 2.0 property definitions contain settings for searchability of properties.\n\nI'm not sure how deeply we want to implement these settings (perhaps we should just hard-code the values), but in any case the relevant methods need to be implemented.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2223",
        "summary": "MSSqlFileSystem - JNDI & several configuration issues",
        "description": "there are several configuration issues using the org.apache.jackrabbit.core.fs.db.MSSqlFileSystem\nmy (working) configuration (repository.xml) looks like:\n\n<FileSystem class=\"org.apache.jackrabbit.core.fs.db.MSSqlFileSystem\">\n <param name=\"driver\" value=\"javax.naming.InitialContext\"/>\n <param name=\"url\" value=\"java:MYDatasource\"/>\n <param name=\"schema\" value=\"mssql\"/>\n <param name=\"schemaObjectPrefix\" value=\"MYPREFIX_\"/>\n <param name=\"user\" value=\"MYUSERNAME\"/> \n <param name=\"password\" value=\"MYPASSWORD\"/>\n <param name=\"tableSpace\" value=\"\"/>\n</FileSystem>\n\ni have to unnecessarily specify username & password, because the MSSqlFileSystem presets them to an empty string instead of null. funnily enough  the tableSpace is preset to null, which leads to a nullpointer in createSchemaSql\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-222",
        "summary": "incompatible with newers versions of xml-apis",
        "description": "Apparently the newer version of the xml-api does not play nice with file objects passed in via a streamresult. So to get around this, I have modified the jackrabbit code RepositoryConfig.java:311 to read:\n \n               transformer.transform(\n                    //new DOMSource(template), new StreamResult(xml)); COMMENTED OUT! \n                    new DOMSource(template), new StreamResult(directory+\"\\\\\"+WORKSPACE_XML));\n\nA similar issue can be found here: http://forum.java.sun.com/thread.jspa?forumID=34&threadID=563077 and a somewhat similar issue can be found logged as a bug at sun: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5077403",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3177",
        "summary": "Remove jdk 1.4 restriction for jcr-tests",
        "description": "This restriction only exist because these tests form the TCK for JSR-283 which needed to support JDK 1.4. If maintenance on the JSR-283 TCK is needed, it can happen in a previous branch (2.3?).\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-348",
        "summary": "Add automatic default configuration",
        "description": "We should provide a simple way to start a Jackrabbit repository with default configuration. The current First Hops document exposes too much configuration details to be really friendly to first-time users.\n\nI'd like to provide a default TransientRepository constructor that looks for \"repository.xml\" as the configuration file and \"repository\" as the repository home directory. If either of these does not exist, it is automatically created using default settings. This way the repository setup would boil down to:\n\n    Repository repository = new TransientRepository();\n\nAs an added feature I'm planning to support system properties \"org.apache.jackrabbit.repository.conf\" and \"org.apache.jackrabbit.repository.home\" for overriding the defaults.\n\nThis improvement would make it easier to write and set up \"Hello, World!\" -type applications, thus helping interested people to try out Jackrabbit. This feature will also make it easier to provide a standard template for test classes that exhibit some error condition. Like this:\n\n    import javax.jcr.*;\n    import org.apache.jackrabbit.core.TransientRepository;\n    public Example {\n        public static void main(String[] args) {\n            try {\n                Repository repository = new TransientRepository();\n                Session session = repository.login();\n                try {\n                    // YOUR CODE HERE\n                } finally {\n                    session.close();\n                }\n            } catch (Exception e) {\n                e.printStackTRace();\n            }\n        }\n    }\n\nI'm targetting this for inclusion in 1.0 as it affects none of the existing code and it will probably be very helpful for the expected number of new users we are going to see after 1.0 is out.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1744",
        "summary": "PROPFIND response to a request for a property that does not exist reports an empty DAV:prop element  ",
        "description": "A PROPFIND response to a request for a property that does not exist reports an empty DAV:prop element:\n\nRequest:\n\n<propfind xmlns=\"DAV:\"><prop><doesnotexist/></prop></propfind>\n\nResponse:\n\n<D:multistatus xmlns:xml='http://www.w3.org/XML/1998/namespace' xmlns:D='DAV:'>\n  <D:response>\n    <D:href>...</D:href>\n    <D:propstat>\n      <D:prop/>\n      <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n    <D:propstat>\n      <D:prop><D:doesnotexist/></D:prop>\n      <D:status>HTTP/1.1 404 Not Found</D:status>\n    </D:propstat>\n  </D:response>\n</D:multistatus>\n\n  ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-70",
        "summary": "Expose registered node types below /jcr:system/jcr:nodeTypes",
        "description": "spec says:\n\n6.8 System Node\n[...]\nFor example, if a repository exposes node type definitions in content, then those node type definitions should be located at /jcr:system/jcr:nodeTypes.\n",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-228",
        "summary": "[jcr-rmi] workspace.copy doesn't work",
        "description": "swapped parameters in org/apache/jackrabbit/rmi/client/ClientWorkspace/ClientWorkspace. \n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1148",
        "summary": "NullPointerException in ItemState",
        "description": "The following happens quite regularly when multiple threads are adding, retrieving and removing nodes simultaneously. Looking at the code of the pull method, this seems due to under-synchronization somewhere as overlayedState was tested at line 153 for null.\n\njava.lang.NullPointerException\n        at org.apache.jackrabbit.core.state.ItemState.pull(ItemState.java:156)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.stateModified(LocalItemStateManager.java:421)\n        at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyStateModified(StateChangeDispatcher.java:85)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.stateModified(SharedItemStateManager.java:434)\n        at org.apache.jackrabbit.core.state.ItemState.notifyStateUpdated(ItemState.java:241)\n        at org.apache.jackrabbit.core.state.ChangeLog.persisted(ChangeLog.java:271)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:741)\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:937)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:327)\n        at org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:313)\n        at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:303)\n        at org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:307)\n        at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1374)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2036",
        "summary": "Set_property permission not checked when saving a new node",
        "description": "When a new node is saved, the add_node permission is checked, but not the set_property permission on it's properties in ItemImpl.validateTransientItems(). This is already fixed in trunk where the implementation is slightly different.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-547",
        "summary": "SimpleSelectionTest assumes RowIterator.getSize() not to return -1",
        "description": "Test case \"testSingleProperty\" assumes that RowIterator.getSize() will not return -1. This is an incorrect assumption, according to the JavaDoc for RangeIterator.\n\nSuggested change:\n\n        long size = result.getRows().getSize();\n        if (size != -1) {\n            assertEquals(\"Should have only 1 result\", 1, size);\n        }\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2447",
        "summary": "RepositoryConfig created by Jcr2spiRepositoryFactory should always return same RepositoryService instance",
        "description": "The Jcr2spiRepositoryFactory uses a default implementation of RepositoryConfig if none is passed to it by the user. Currently this default implementation returns a new RepositoryService instance on each call to getRepositoryService(). This is not correct since the consumer of the RepositoryConfig instance expects the same RepositoryService instance on every call. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1087",
        "summary": "Maintain the cluster revision table",
        "description": "The revision table in which cluster nodes write their changes can potentially become very large. If all cluster nodes are up to date to a certain revision number, then it seems unnecessary to keep the revisions with a lower number.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2940",
        "summary": "PrivilegeDefinition should implement equals and hashcode",
        "description": "",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2921",
        "summary": "URIResolverImpl: use of bitwise instead of logical AND operator",
        "description": "URIResolverImpl, line 111: \n\n                if (path != null & cache.containsItemId(uuidId)) {\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2392",
        "summary": "[patch] QValueFactoryImpl.equals doesn't do compare correctly",
        "description": "equals compares it's uri to it's own uri, as poosed to the other one.\n\n                 // for both the value has not been loaded yet\n                 if (!initialized) {\n                     if (other.uri != null) {\n-                        return uri.equals(uri);\n+                        return other.uri.equals(uri);\n                     } else {\n                         // need to load the binary value in order to be able\n                         // to compare the 2 values.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2115",
        "summary": "JSR 283 Property Types",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1066",
        "summary": "Exclude system index for queries that restrict the result set to nodetypes not availble in the \"jcr:system\" subtree",
        "description": "We already have code that is able to decide whether the system index needs to be included in a search or not (see JCR-967). If I execute a query like \"my:app//element(*, my:doc)\" this will only search the workspace index. Unfortunately this is slower than \"//element(*, my:doc)\", since the first query can not be optimized as the second. In our case both queries return the same result set because we use application specific node types. Even though the second query includes the system index it is still faster than the first one. But it could be even faster because it doesn't need to search the system index because nodes with the application specific node type can't be added to the \"jcr:system\"-tree and are therefore are added never to the system index (am I right?).",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1286",
        "summary": "FilterImpl.getStringValue() does not use custom converter class specified in @Field annotation",
        "description": "I have a POJO with the following field:\n\n    @Field(converter = LocaleConverter.class)\n    private Locale                locale;\n\nWhen I attempt to query for objects based on this field, I get a NullPointerException:\n\njava.lang.NullPointerException\n        at org.apache.jackrabbit.ocm.query.impl.FilterImpl.getStringValue(FilterImpl.java:281)\n        at org.apache.jackrabbit.ocm.query.impl.FilterImpl.addEqualTo(FilterImpl.java:129)\n\nFilterImpl should preferentially use the atomic type converter defined in the @Field annotation to convert the value, then fallback to the global converters.  Converting the Locale to a string for use in the query is a workaround, but the logic for string conversion should only reside in my LocaleConverter class.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3232",
        "summary": "Improve FileRevision extensibility",
        "description": "It'd be nice to make FileRevision more extensible by chaning some of its private variables to protected so it can be extended easier when needed.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-117",
        "summary": "Test cases not fully initialized at first run",
        "description": "It seems that some test cases in o.a.j.test.api.query and o.a.j.test.api do not properly initialized the test repository before running tests against it. The repository gets initialized by other test cases, and later runs of the troublesome tests report no errors.\n\nThus the problem appears right after a fresh checkout and a tree cleanup. The command sequence below illustrates this problem. The error messages reported by the initial test runs are \"Workspace does not contain test data at: /testdata/query\" and \"Workspace does not contain test data at: /testdata\".\n\nI tried tracing the cause of this problem, but couldn't find it easily as I'm not yet too familiar with the test setup.\n\n$ svn co\n$ maven test\n\n    [junit] Running org.apache.jackrabbit.test.api.query.TestAll\n    [junit] Tests run: 77, Failures: 30, Errors: 0, Time elapsed: 5,333 sec\n    [junit] [ERROR] TEST org.apache.jackrabbit.test.api.query.TestAll FAILED\n    [junit] Running org.apache.jackrabbit.test.api.TestAll\n    [junit] Tests run: 534, Failures: 181, Errors: 0, Time elapsed: 16,105 sec\n    [junit] [ERROR] TEST org.apache.jackrabbit.test.api.TestAll FAILED\n\n$ maven test\n\n    [junit] Running org.apache.jackrabbit.test.api.query.TestAll\n    [junit] Tests run: 77, Failures: 0, Errors: 0, Time elapsed: 5,887 sec\n    [junit] Running org.apache.jackrabbit.test.api.TestAll\n    [junit] Tests run: 534, Failures: 0, Errors: 0, Time elapsed: 18,427 sec\n\n$ maven clean\n$ maven test\n\n    [junit] Running org.apache.jackrabbit.test.api.query.TestAll\n    [junit] Tests run: 77, Failures: 30, Errors: 0, Time elapsed: 13,185 sec\n    [junit] [ERROR] TEST org.apache.jackrabbit.test.api.query.TestAll FAILED\n    [junit] Running org.apache.jackrabbit.test.api.TestAll\n    [junit] Tests run: 534, Failures: 181, Errors: 0, Time elapsed: 40,42 sec\n    [junit] [ERROR] TEST org.apache.jackrabbit.test.api.TestAll FAILED\n\n$ maven test\n\n    [junit] Running org.apache.jackrabbit.test.api.query.TestAll\n    [junit] Tests run: 77, Failures: 0, Errors: 0, Time elapsed: 5,942 sec\n    [junit] Running org.apache.jackrabbit.test.api.TestAll\n    [junit] Tests run: 534, Failures: 0, Errors: 0, Time elapsed: 17,797 sec\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-3138",
        "summary": "Skip sync delay when changes are found",
        "description": "The cluster synchronization on a slave does always wait for some time (as specified in the sync delay) before fetching changes. If a lot of changes are being written to the master, a slave will considerably fall behind the master in term of revisions, which may endanger the integrity of the cluster if the master will crash. I therefore suggest that a slave should rather immediately contact the master again after some changes have been found, until it sees no more changes.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-524",
        "summary": "TCK: PredicatesTest does not respect testroot configuration property",
        "description": "Test does not respect testroot configuration property.\n\nProposal: use testroot configuration property in constructing the test queries.\n\n--- PredicatesTest.java (revision 422074)\n+++ PredicatesTest.java (working copy)\n@@ -78,7 +78,7 @@\n      * @throws RepositoryException\n      */\n     public void testEquality() throws RepositoryException {\n-        String stmt = \"/\" + jcrRoot + \"/*[@\" + jcrPrimaryType + \"='\" + nodeTypeName + \"']\";\n+        String stmt = \"/\" + jcrRoot + \"/\" + testPath + \"/*[@\" + jcrPrimaryType + \"='\" + nodeTypeName + \"']\";  \n         try {\n             qm.createQuery(stmt, Query.XPATH);\n@@ -93,7 +93,7 @@\n      * @throws RepositoryException\n      */\n     public void testCombinedOr() throws RepositoryException {\n-        String stmt = \"/\" + jcrRoot + \"/*[@\" + jcrPrimaryType + \"='\" + nodeTypeName + \"' or @\" + jcrPrimaryType + \"='\" + ntBase + \"']\";\n+        String stmt = \"/\" + jcrRoot  + \"/\" + testPath + \"/*[@\" + jcrPrimaryType + \"='\" + nodeTypeName + \"' or @\" + jcrPrimaryType + \"='\" + ntBase + \"']\";\n  \n         try {\n             qm.createQuery(stmt, Query.XPATH);\n@@ -108,7 +108,7 @@\n      * @throws RepositoryException\n      */\n     public void testOr() throws RepositoryException {\n-        String stmt = \"/\" + jcrRoot + \"/*[@\" + jcrPrimaryType + \" or @\" + jcrMixinTypes + \"]\";\n+        String stmt = \"/\" + jcrRoot  + \"/\" + testPath + \"/*[@\" + jcrPrimaryType + \" or @\" + jcrMixinTypes + \"]\";\n  \n         try {\n             qm.createQuery(stmt, Query.XPATH);\n@@ -123,7 +123,7 @@\n      * @throws RepositoryException\n      */\n     public void testAnd() throws RepositoryException {\n-        String stmt = \"/\" + jcrRoot + \"/*[@\" + jcrPrimaryType + \" and @\" + jcrMixinTypes + \"]\";\n+        String stmt = \"/\" + jcrRoot  + \"/\" + testPath + \"/*[@\" + jcrPrimaryType + \" and @\" + jcrMixinTypes + \"]\";\n  \n         try {\n             qm.createQuery(stmt, Query.XPATH);\n@@ -138,7 +138,7 @@\n      * @throws RepositoryException\n      */\n     public void testCombinedAnd() throws RepositoryException {\n-        String stmt = \"/\" + jcrRoot + \"/*[@\" + jcrPrimaryType + \"='\" + nodeTypeName + \"' and @\" + jcrPrimaryType + \"='\" + ntBase + \"']\";\n+        String stmt = \"/\" + jcrRoot  + \"/\" + testPath + \"/*[@\" + jcrPrimaryType + \"='\" + nodeTypeName + \"' and @\" + jcrPrimaryType + \"='\" + ntBase + \"']\";\n  \n         try {\n             qm.createQuery(stmt, Query.XPATH);\n\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-3037",
        "summary": "Add getPath method to Authorizable interface",
        "description": "currently the only way to retrieve the path of the item associated with an authorizable is to check if the\nprincipal obtained through Authorizable#getPrincipal() is an ItemBasedPrincipal.\n\nhaving a getPath method would provide a convenient shortcut and would in addition allow\nto determine of there is really an item associated with a authorizable that is accessible for the editing\nsession (which is not necessarily the case for ItemBasedPrincipal#getPath",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-319",
        "summary": "Improve docs for deployment Models 1 and 2 on Tomcat 5.5.x and provide an example webapp.",
        "description": "New users would find a small webapp and associated documentation that walks them through the process of setting up a model 1 or model 2 (or both) deployment scheme.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-969",
        "summary": "better error for unknown date formats",
        "description": "This small patch improves the exception message you get when the date format is unknown.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2897",
        "summary": "Remove jcr-commons dependency from jackrabbit-webdav",
        "description": "while looking at JCR-2896 i just happen to see that jackrabbit-webdav contains a dependency to jcr-commons.\nthis was never intended to be and i want to get rid of it again... the webdav library should not have any dependency to JCR.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2301",
        "summary": "CND support in jackrabbit-jcr-commons",
        "description": "It would be nice if the CND parsing functionality in spi-commons could be made available in jcr-commons for use by JCR clients that shouldn't have to know anything about the SPI.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2027",
        "summary": "Remove background initialization of hierarchy cache",
        "description": "This is a follow up to JCR-1998.\n\nRethinking the initialization in a background thread again, I now come to the conclusion that it should be initialized either completely on startup or not at all. A background thread puts additional load on the process, possibly fighting for I/O with other startup procedures.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-596",
        "summary": "Keep jackrabbit jar/pom's updated at ibiblio",
        "description": "Please keep jackrabbit updated on ibiblio or some other maven repository.  jackrabbit-1.1 needs to be added.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "TASK"
    },
    {
        "key": "JCR-3033",
        "summary": "Provide a method for writing name space declarations in CompactNodeTypeDefWriter",
        "description": "Currently CompactNodeTypeDefWriter includes (when configured to do so) only name space declarations from name spaces actually used in the node type definitions written. In some situations it is necessary to write additional name space declarations. I thus propose to add a method writeNamespaceDelclaration.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-977",
        "summary": "jcr:deref and parent axis in xpath predicates",
        "description": "Currently, the jcr:deref() function is not allowed in a xpath query predicate. Example :\nbook holds a reference property on its author(s)\nauthors have a name\n\nWe want all books from a specific author :\n\n/jcr:root/element(*, bookType)[jcr:deref(@author, 'authorType')/@name = 'King']\n\nThis fails with an InvalidQueryException currently (not supported).\n\nThe error is raised in the XPathQueryBuilder class, in function : private QueryNode createFunction(SimpleNode node, QueryNode queryNode), in the block :\nelse if (NameFormat.format(JCR_DEREF, resolver).equals(fName))\n\nProblem is that with this query, when evaluating the jcr:deref() function, then in this method at this point, queryNode.getType() is 0 and tests raise the exception if queryNode.getType() is neither QueryNode.TYPE_LOCATION nor QueryNode.TYPE_PATH.\n\nI think this is a useful place to put a deref function in a query, as I don't know how we could test the referenced node properties another way.\n\nFrederic Esnault",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2651",
        "summary": "Add a OnWorkspaceInconsistency with logging only",
        "description": "If a Workspace performs a re-index on startup with  a inconsistency in it the process will fail now.\nThe new OnWorkspaceInconsistency \"log\" will only log the inconsistency but the reindex-process will not fail",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2628",
        "summary": "registerNodeType is not implemented in the CLI",
        "description": "registernodetype is listed in the standalone client but not implemented. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1222",
        "summary": "Index nodes in parallel",
        "description": "CPUs with multiple cores are now standard and Jackrabbit should make use of it where it makes sense. Analyzing content while a node is indexed is quite costly, but can be broken easily into task that can be executed in parallel. E.g. index multiple nodes in parallel.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-353",
        "summary": "TransientRepository does not shutdown if first login fails",
        "description": "The TransientRepository.login() method initializes the underlying repository when it is first called (initially or after the repository has previously been shut down) bug doesn't shut down the initialized repository if the login fails. If the application then decides to exit or otherwise not start another session, then the repository remains in an initialized state with no active sessions.\n\nThis issue should be fixed by properly handling login failures in the TransientRepository.login() method.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2174",
        "summary": "Remove redundant RepositoryService.executeQuery() method ",
        "description": "There are currently two executeQuery() methods on RepositoryService. For simplicity we should remove the one that assumes default values for limit, offset and bind variable values.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1588",
        "summary": "JSR 283: Access Control",
        "description": "container issue for JSR 283 access control functionality",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1041",
        "summary": "Avoid using BitSets in ChildAxisQuery to minimize memory usage",
        "description": "When doing ChildAxisQueries on large indexes the internal BitSet instance (hits) may consume a lot of memory because the BitSet is always as large as IndexReader.maxDoc(). In our case we had a query consisting of 7 ChildAxisQueries which combined to a total of 14MB. Since we have multiple users executing this query simultaneously this caused an out of memory error.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1734",
        "summary": "Generated cluster node id should be persisted",
        "description": "If no cluster node id is specified in the configuration, a cluster node id is automatically generated. This id is never persisted, so after another startup a new, probably different cluster node id is used. Instead, an automatically generated cluster id should be persisted inside the repository home.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1870",
        "summary": "jcr2spi: reloading of invalidated nodes doesn't benefit from batch-read",
        "description": "issue reported by stefan:\n\nupon reloading of an invalidated node, jcr2spi doesn't use batch-read but only retrieves the NodeInfo.\n\nbasically, WorkspaceItemStateFactory ll 92 needs to be changed to omit the extra handling of \ninvalidated node entries and always use RepositoryService.getItemInfos when build the NodeState.\n\ni will try it out as soon as possible.\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2259",
        "summary": "Remove unused method RedoLog.clear()",
        "description": "This method is not used anymore and can be removed.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-884",
        "summary": "DatabaseJournal assigns same revision id to different revisions",
        "description": "Running a transaction that updates multiple workspaces (e.g. a versioning operation) will fail in DatabaseJournal, because every individual update will ultimately be assigned the same revision id. An indication of this failure when e.g. using Oracle as backend for journaling will look as follows::\n\njava.sql.SQLException: ORA-00001: unique constraint (JOURNAL_IDX) violated\n at oracle.jdbc.dbaccess.DBError.throwSqlException(DBError.java:134)\n at oracle.jdbc.ttc7.TTIoer.processError(TTIoer.java:289)\n at oracle.jdbc.ttc7.Oall7.receive(Oall7.java:590)\n at oracle.jdbc.ttc7.TTC7Protocol.doOall7(TTC7Protocol.java:1973)\n at oracle.jdbc.ttc7.TTC7Protocol.executeFetch(TTC7Protocol.java:977)\n at oracle.jdbc.driver.OracleStatement.executeNonQuery(OracleStatement.java:2205)\n at oracle.jdbc.driver.OracleStatement.doExecuteOther(OracleStatement.java:2064)\n at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:2989)\n at oracle.jdbc.driver.OraclePreparedStatement.executeUpdate(OraclePreparedStatement.java:658)\n at oracle.jdbc.driver.OraclePreparedStatement.execute(OraclePreparedStatement.java:736)\n at org.apache.jackrabbit.core.journal.DatabaseJournal.append(DatabaseJournal.java:293)\n ... 24 more\n\nThis bug has been reported by Rafa\u0142 Kwiecie\u0144.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3172",
        "summary": "implement PERSIST events for the EventJournal",
        "description": "See <http://www.day.com/specs/jcr/2.0/12_Observation.html#12.6.3%20Event%20Bundling%20in%20Journaled%20Observation>\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-783",
        "summary": "TCK: SerializationTest.helpTestSaxException casts ContentHandler to DefaultHandler",
        "description": "the JSR170 defines import with ContentHandler (see Session.getImportContentHandler, Workspace.getImportContentHandler)\n\nthe mentioned helper method within the TCK casts the ContentHandler returned by those methods to DefaultHandler without testing if the contenthandler is a DefaultHandler (line 273)",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1993",
        "summary": "UserManagement: Missing assertion that Principal name isn't \"\"",
        "description": "Creating users/groups with a Principal having an empty name should not be allowed.",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-2336",
        "summary": "Automatic type conversion no longer works",
        "description": "String values are no longer converted to binary when required. Example:\n\nNode n = testRootNode.addNode(\"testConvert\", \"nt:file\");\nNode content = n.addNode(\"jcr:content\", \"nt:resource\");\ncontent.setProperty(\"jcr:lastModified\", Calendar.getInstance());\ncontent.setProperty(\"jcr:mimeType\", \"text/html\");\ncontent.setProperty(\"jcr:data\", \"Hello\");\nn.getSession().save();\n\nThis used to work in a previous 2.0 build, but now throws:\n\njavax.jcr.nodetype.ConstraintViolationException: no matching property definition found for {http://www.jcp.org/jcr/1.0}data\nat org.apache.jackrabbit.core.nodetype.EffectiveNodeType.getApplicablePropertyDef(EffectiveNodeType.java:782)\nat org.apache.jackrabbit.core.NodeImpl.getApplicablePropertyDefinition(NodeImpl.java:747)\nat org.apache.jackrabbit.core.ItemManager.getDefinition(ItemManager.java:241)\nat org.apache.jackrabbit.core.ItemData.getDefinition(ItemData.java:101)\nat org.apache.jackrabbit.core.ItemManager.canRead(ItemManager.java:409)\nat org.apache.jackrabbit.core.ItemManager.getItemData(ItemManager.java:383)\nat org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:316)\nat org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:595)\nat org.apache.jackrabbit.core.NodeImpl.removeChildProperty(NodeImpl.java:554)\nat org.apache.jackrabbit.core.NodeImpl.removeChildProperty(NodeImpl.java:534)\nat org.apache.jackrabbit.core.NodeImpl.setProperty(NodeImpl.java:2303)\nat org.apache.jackrabbit.core.nodetype.ConvertDataTypeTest.testStringToBinary(ConvertDataTypeTest.java:36)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2276",
        "summary": "org.apache.jackrabbit.server.remoting.davex.JsonWriter: wrong value type for ::NodeIteratorSize attribute",
        "description": "the ::NodeIteratorSize attribute is serialized as string value whereas the client expects a long value.\nthis causes unnecessery server-roundtrips since the client doesn't detect this hint.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2852",
        "summary": "Support multi-selector OR constraints in join queries",
        "description": "Our current join implementation doesn't support OR constraints that refer to more than one selector. For example the following query is not possible:\n\n    SELECT a.* FROM [my:type] AS a INNER JOIN [my:type] as b ON a.foo = b.bar WHERE a.baz = 'x' OR b.baz = 'y'\n\nThis limitation is a result of the way the join execution splits the query into per-selector components and merges the result based on the given join condition.\n\nA simple but often inefficient solution would be to process such OR constraints as post-processing filters like we already do for some other more complex constraint types.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2583",
        "summary": "Occasional testDataStoreGarbageCollection test failures",
        "description": "In the past few days our Hudson build started failing every now and then with the following jackrabbit-core test failure:\n\njavax.jcr.NoSuchWorkspaceException: security\n\tat org.apache.jackrabbit.core.RepositoryImpl.getWorkspaceInfo(RepositoryImpl.java:786)\n\tat org.apache.jackrabbit.core.RepositoryImpl.getSystemSession(RepositoryImpl.java:985)\n\tat org.apache.jackrabbit.core.RepositoryImpl.getSecurityManager(RepositoryImpl.java:471)\n\tat org.apache.jackrabbit.core.RepositoryImpl.login(RepositoryImpl.java:1496)\n\tat org.apache.jackrabbit.core.TransientRepository.login(TransientRepository.java:380)\n\tat org.apache.jackrabbit.commons.AbstractRepository.login(AbstractRepository.java:123)\n\tat org.apache.jackrabbit.core.data.DataStoreAPITest.testDataStoreGarbageCollection(DataStoreAPITest.java:55)",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2398",
        "summary": "AdministratorTest.testAdminNodeCollidingWithRandomNode failure",
        "description": "I see the following test failure with the latest trunk. It seems to affect also S\u00e9bastien as commented in JCR-2389. However, it doesn't break the Hudson build or Angela's checkout.\n\nI'm filing this as a bug and will disable the test for now to be able to cut the 2.0-beta3 release. We can look at this later in more detail.\n\nThe detailed failure message is:\n\n-------------------------------------------------------------------------------\nTest set: org.apache.jackrabbit.core.security.user.TestAll\n-------------------------------------------------------------------------------\nTests run: 144, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 4.078 sec <<< FAILURE!\ntestAdminNodeCollidingWithRandomNode(org.apache.jackrabbit.core.security.user.AdministratorTest)  Time elapsed: 0.072 sec  <<< FAILURE!\njunit.framework.AssertionFailedError\n        at junit.framework.Assert.fail(Assert.java:47)\n        at junit.framework.Assert.assertTrue(Assert.java:20)\n        at junit.framework.Assert.assertFalse(Assert.java:34)\n        at junit.framework.Assert.assertFalse(Assert.java:41)\n        at org.apache.jackrabbit.core.security.user.AdministratorTest.testAdminNodeCollidingWithRandomNode(AdministratorTest.java:205)\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1758",
        "summary": "Improvement to UndefinedTypeConverterImpl to map super types effectively",
        "description": "Improvement to org.apache.jackrabbit.ocm.manager.atomictypeconverter.impl.UndefinedTypeConverterImpl's implementation of \npublic Value getValue(ValueFactory valueFactory, Object propValue) , used equality check of class names to decide whether Object propValue is worthy of any attempt to map to an apropriate property.  Since the purpose of the class is to provide a 'best effort' attempt to map an Object of type java.lang.Object it will be better to use 'instanceof'.  This approach will convert the specific class as well as any inherited objects.  For example using instanceof will let us map a BufferedInputStream, and any other sub classes of InputStream to a Binary Property.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1342",
        "summary": "Create OSGi Bundle Manifest Headers",
        "description": "To be able to easily uses libraries from Jackrabbit inside an OSGi framework, for example in Apache Sling, it would be very helpfull if some of the Jackrabbit libraries include OSGi Bundle Manifest headers. It will of course not be possible to define such manifest header definition for all libraries, but jackrabbit-api, jackrabbit-jcr-commons and jackrabbit-jcr-rmi are certainly good candidates.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1778",
        "summary": "BindableRepositoryFactory doesn't handle repository shutdown",
        "description": "The BindableRepositoryFactory class keeps a cached reference to a repository even after the repository has been shut down.\n\nThis causes the following code snippet to fail with an IllegalStateException:\n\n        Hashtable environment = new Hashtable();\n        environment.put(\n                Context.INITIAL_CONTEXT_FACTORY,\n                DummyInitialContextFactory.class.getName());\n        environment.put(Context.PROVIDER_URL, \"http://jackrabbit.apache.org/\");\n        Context context = new InitialContext(environment);\n\n        JackrabbitRepository repository;\n        String xml = \"src/test/repository/repository.xml\";\n        String dir = \"target/repository\";\n        String key = \"repository\";\n\n        // Create first repository\n        RegistryHelper.registerRepository(context, key, xml, dir, true);\n        repository = (JackrabbitRepository) context.lookup(key);\n        repository.login().logout();\n        repository.shutdown();\n\n        // Create second repository with the same configuration\n        RegistryHelper.registerRepository(context, key, xml, dir, true);\n        repository = (JackrabbitRepository) context.lookup(key);\n        repository.login().logout(); // throws an IllegalStateException!\n        repository.shutdown();\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2761",
        "summary": "add shortcut method to CndImporter which makes it easier to rereigster node types",
        "description": "CndImporter has a two argument registerNodeTypes method which is a nice shortcut, but in order to rereigster node types, you have to use the non-shortcut method. Attached patch adds a three-argument method which provide a shortcut for doing reregistration.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3128",
        "summary": "Problem with formerly escaped JCR node names when upgrading to Jackrabbit 2.2.9",
        "description": "The following unit test fails:\n\n{code}\nimport static org.junit.Assert.*;\n\nimport org.apache.jackrabbit.util.Text;\nimport org.junit.Test;\n\npublic class TestEscaping\n{\n   @Test\n   public void testEscaping() throws Exception\n   {\n      // expect this as an escaped string (e.g. formerly escaped with jackrabbit 1.6)\n      String escaped = \"nam%27e\";\n      String unescaped = Text.unescapeIllegalJcrChars(escaped);\n      assertEquals(escaped, Text.escapeIllegalJcrChars(unescaped));\n   }\n}\n{code}\n\nThis is a major problem when upgrading from 1.6.x to 2.2.9. The node names that were escaped in jackrabbit 1.6 are not longer escaped and that breaks the backward compatibility. I think the problem comes in with JCR-2198. ",
        "label": "NUG",
        "classified": "BACKPORT",
        "type": "BUG"
    },
    {
        "key": "JCR-82",
        "summary": "Query for all node fails after restart",
        "description": "The query handler initially indexes the node type definitions exposed at /jcr:system/jcr:nodetypes. However after a restart or a node type registration the UUIDs of those nodes will change because they consist of VirtualNodeStates. The index will still use the UUIDs of the initial indexing and will return a query result that refers to UUIDs that do not exist in the workspace anymore.\n\nAs an short term solution we should disable indexing of VirtualNodeStates.\n\nPlease note, this does not only apply to xpath queries but also sql queries of course.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2475",
        "summary": "Test failures when running \"mvn cobertura:check\"",
        "description": "It looks like the bytecode instrumentation done by Cobertura interferes with the rather complex XPathTokenManager class produced by JavaCC.\n\nThe easiest workaround seems to be to simply exclude XPathTokenManager from being instrumented by Cobertura.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-2117",
        "summary": "JSR 283: adopt CND syntax changes",
        "description": "the CND syntax has changed from Public Review Draft to Public Final Draft.\n\nold and new syntax are incompatible.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2321",
        "summary": "ZombieHierarchyManager can return wrong child node entries for replaced nodes",
        "description": "The ZombieHierarchyManager currently implements the two getChildNodeEntry methods like this:\n\n1) look up child node in old, overlayed state, which might contain removed child nodes\n2) if not found, ask the super implementation (ie. get the child node from the up-to-date list)\n\nThe purpose of the ZombieHM is to be able to return removed item ids from the attic. However, the behavior above is IMO wrong, as it should first find an existing child node with the given name (or id):\n\n1) look up child node in super implementation (ie. get the child node from the up-to-date list)\n2) if not found, look in the old, overlayed state if it might have been removed\n\nI was able to reproduce this issue when replacing a node (but note the custom access manager in 1.4.x used as explained below): create /replaced/subnode structure, save the session, remove the replaced node and add /replaced and then /replaced/subnode again:\n\n        Node rootNode = session.getRootNode();\n        \n        // 1. create structure /replaced/subnode\n        Node test = rootNode.addNode(\"replaced\", NT);\n        test.addNode(\"subnode\", NT);\n        // 2. persist changes\n        session.save();\n\n        // 3. remove node and recreate it\n        test.remove();\n        test = rootNode.addNode(\"replaced\", NT);\n        \n        // 4. create previous child with same name\n        test.addNode(\"subnode\", NT);\n        \n        // 5. => gives exception\n        test.getNode(\"subnode\").getNodes();\n\nTo complicate things further, this was only triggered by a custom access manager, and all based upon Jackrabbit 1.4.x. Back then (pre-1.5 and new security stuff era), the access manager would get a ZombieHM as its hierarchy manager. If its implementation called resolvePath() on the HM for checking read-access in the final getNodes() call, where the tree will be traversed using the getChildNdeEntry(NodeState, Name, int) method, it would get the old node id and hence fail if it would try to retrieve it from the real item state manager.\n\nThus with a Jackrabbit >= 1.5 and 2.0 the above code will work fine, because the ZombieHM is not used.\n\nHowever, we might want to fix it for 1.4.x and also check the other uses of the ZombieHM in the current trunk, which I couldn't test. These are (explicit and implicit): ChangeLogBasedHierarchyMgr, SessionItemStateManager.getDescendantTransientItemStates(NodeId), ItemImpl.validateTransientItems(Iterable<ItemState>, Iterable<ItemState>) and SessionItemStateManager.getDescendantTransientItemStatesInAttic(NodeId).\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2083",
        "summary": "BLOB Store: only open a stream when really necessary",
        "description": "Currently, PropertyImpl.getValue() opens a FileInputStream if the BLOBStore is used.\nIf the application doesn't use the value, this stream is never closed. \n\nSee also JCR-2067 (FileDataStore)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2108",
        "summary": "JSR 283 Observation",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2322",
        "summary": "Fix NOTICE files to match consensus from legal team",
        "description": "As discussed in LEGAL-62 and the related legal-discuss@ threads, the Jackrabbit NOTICE files currently contain information that doesn't really need to be there. A simple \"Copyright (c) ...\" statement is not a required attribution notice.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1152",
        "summary": "SPI implementations currently need to provide implementations of both ValueFactory and QValueFactory",
        "description": "This should be simplified so that an implementation of QValueFactory is sufficient.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2387",
        "summary": "Use executor service from repository for index merging",
        "description": "The index merger currently starts its own threads for index merges. Using the repository wide executor service would simplify things and make configuration easier.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1857",
        "summary": "jcr2spi: NPE with SessionImporter#checkIncludesMixReferenceable if NodeInfo doesn't contain mixin names",
        "description": "issue reported by tobi:\n\njava.lang.NullPointerException\n\tat java.util.Arrays$ArrayList.<init>(Arrays.java:2355)\n\tat java.util.Arrays.asList(Arrays.java:2341)\n\tat org.apache.jackrabbit.jcr2spi.xml.SessionImporter.checkIncludesMixReferenceable(SessionImporter.java:637)\n\tat org.apache.jackrabbit.jcr2spi.xml.SessionImporter.startNode(SessionImporter.java:209)\n\nincluding test case:\n\n    public void testEmptyMixins() throws Exception {\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\"\\n\" +\n                \"         xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\"\\n\" +\n                \"         xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\"\\n\" +\n                \"         xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\"\\n\" +\n                \"         sv:name=\\\"testnode1\\\">\\n\" +\n                \"    <sv:property sv:name=\\\"jcr:primaryType\\\"\nsv:type=\\\"Name\\\">\\n\" +\n                \"        <sv:value>nt:unstructured</sv:value>\\n\" +\n                \"    </sv:property>\\n\" +\n                \"    <sv:property sv:name=\\\"jcr:title\\\" sv:type=\\\"String\\\">\\n\" +\n                \"        <sv:value>Test Node</sv:value>\\n\" +\n                \"    </sv:property>\\n\" +\n                \"    <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\">\\n\" +\n                \"        <sv:value>1234</sv:value>\\n\" +\n                \"    </sv:property>\\n\" +\n                \"</sv:node>\";\n\n        InputStream in = new ByteArrayInputStream(xml.getBytes());\n        session.importXML(\"/\", in,\nImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);\n        session.save();\n    }",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1210",
        "summary": "WebDAV: pack AbstractWebdavServlet with the jackrabbit-webdav project",
        "description": "suggestion posted by alan cabrera on the dev list:\n\n\"Quite a handy servlet.  Too bad it's in jackrabbit-server.  Would this not be better placed in jackrabbit-webdav?  I'm writing my own server bits under WEBDAV and would prefer not to have JCR/Jackrabbit stuff.  I realize that this is a fussy preference.\"\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1044",
        "summary": "NTCollectionConverterImpl throws a null pointer exception on update",
        "description": "When calling update on a node which has no child nodes stored (but which can have child nodes) the code can generate a null pointer exception. In the case where one goes to remove JCR nodes which are not present in the current objects collection of child objects the code is calling getCollectionNodes().iterator(). However, since is not checking for the case where getCollectionNodes() returns null if there are no child nodes present a null pointer exception will be generated. ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-892",
        "summary": "XML export (stream) doesn't initialize TransformerHandler properly",
        "description": "For instance, in SessionImpl.java:\n\n    public void exportSystemView(String absPath, OutputStream out,\n                                 boolean skipBinary, boolean noRecurse)\n            throws IOException, PathNotFoundException, RepositoryException {\n\n        SAXTransformerFactory stf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();\n        try {\n            TransformerHandler th = stf.newTransformerHandler();\n            th.setResult(new StreamResult(out));\n            th.getTransformer().setParameter(OutputKeys.METHOD, \"xml\");\n            th.getTransformer().setParameter(OutputKeys.ENCODING, \"UTF-8\");\n            th.getTransformer().setParameter(OutputKeys.INDENT, \"no\");\n\n            exportSystemView(absPath, th, skipBinary, noRecurse);\n        } catch (TransformerException te) {\n            throw new RepositoryException(te);\n        } catch (SAXException se) {\n            throw new RepositoryException(se);\n        }\n    }\n\n(1) It should be \"setOutputProperty()\", not \"setParameter()\",\n\n(2) My tests show that setting the parameters only has an effect when done before calling setResult()\n\nThat being said, the effect is minor, as the default settings for the TransformerHandler seem to be correct anway.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2401",
        "summary": "OSGi bundle symbolic names changed due to changes in maven-bundle-plugin",
        "description": "See FELIX-1886 - I have noticed this with jackrabbit-jcr-commons 2.0-beta3 but I assume all modules which use maven-bundle-plugin are affected.\n\nHaving bundle symbolic name changes is problematic as OSGi frameworks then consider the old a new bundles to be different components, instead of different versions of the same component.\n\nThe simplest way to go back to the previous symbolic names is probably to use the maven-bundle-plugin config workaround described in FELIX-1886, in the jackrabbit parent pom (or whever that plugin is configured).\n\nI'll try that and supply a patch.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-1773",
        "summary": "shareable nodes: wrong path returned, causes remove() to delete wrong node",
        "description": "It seems that for shareable nodes it can happen that getPath() returns the wrong path (one of another node in the shared set):\n\n/**\n* Verify that shared nodes return correct paths.\n*/\npublic void testPath() throws Exception {\n   Node a1 = testRootNode.addNode(\"a1\");\n   Node a2 = a1.addNode(\"a2\");\n   Node b1 = a1.addNode(\"b1\");\n   b1.addMixin(\"mix:shareable\");\n   testRootNode.save();\n\n   //now we have a shareable node N with path a1/b1\n\n   Session session = testRootNode.getSession();\n   Workspace workspace = session.getWorkspace();\n   String path = a2.getPath() + \"/b2\";\n   workspace.clone(workspace.getName(), b1.getPath(), path, false);\n\n   //now we have another shareable node N' in the same shared set as N with path a1/a2/b2\n\n   //using the path a1/a2/b2, we should get the node N' here\n   Item item = session.getItem(path);\n   String p = item.getPath();\n   assertFalse(\"unexpectedly got the path from another node from the same shared set \", p.equals(b1.getPath()));\n} \n\nNote that when this happens, a subsequent remove() deletes the wrong node.\n\n(Thanks Manfred for spotting this one).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1623",
        "summary": "Typo in the DeltaVConstants class in constant XML_CHECKOUT_CHECKIN value",
        "description": "Just spotted a typo in the http://svn.apache.org/repos/asf/jackrabbit/trunk/jackrabbit-webdav/src/main/java/org/apache/jackrabbit/webdav/version/DeltaVConstants.java\n(same is in released 1.4 version)\n\nThere's line\n    public static final String XML_CHECKOUT_CHECKIN = \"checkin-checkout\";\nProbably should be\n    public static final String XML_CHECKOUT_CHECKIN = \"checkout-checkin\";\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3116",
        "summary": "Cluster Node ID should be trimmed",
        "description": "If the cluster node ID is not configured in repository.xml, it is read from the file cluster_node.id instead. In case this file is edited by hand, some editors (e.g. vi) insert a trailing newline character (\"\\n\"). This leads to the cluster node ID to contain a blank character. While I don't expect this to cause any issues, it is inconvenient for debugging and also introduces line-breaks in log files. I suggest to trim the cluster node ID, so only non-blank characters are used.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1764",
        "summary": "Occasional IndexingQueueTest failures",
        "description": "Every now and then, when doing a clean build of the latest jackrabbit trunk I see the following test failure in jackrabbit-core:\n\n-------------------------------------------------------------------------------\nTest set: org.apache.jackrabbit.core.query.lucene.TestAll\n-------------------------------------------------------------------------------\nTests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 1.665 sec <<< FAILURE!\ntestQueue(org.apache.jackrabbit.core.query.lucene.IndexingQueueTest)  Time elapsed: 1.654 sec  <<< FAILURE!\njunit.framework.AssertionFailedError\n        at junit.framework.Assert.fail(Assert.java:47)\n        at junit.framework.Assert.assertTrue(Assert.java:20)\n        at junit.framework.Assert.assertTrue(Assert.java:27)\n        at org.apache.jackrabbit.core.query.lucene.IndexingQueueTest.testQueue(IndexingQueueTest.java:69)\n\nTypically the problem disappears when I rebuild, but the test should still not have failed.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1421",
        "summary": "Backport JCR-1111: Access to version history results in reading all versions of versionable node",
        "description": "Backport issue JCR-1111 (Accesss to version history results in reading all versions of versionable node) to 1.3 branch for 1.3.4 (separate issue to avoid re-opening JCR-1111 which was already released with 1.4).",
        "label": "NUG",
        "classified": "BACKPORT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1527",
        "summary": "Support for MaxDB / SapSB Databases",
        "description": "I admit that MaxDB / SapSB are a bit exotic but support is easy to achieve when providing the correct ddls. \n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1775",
        "summary": "Transaction-safe versioning",
        "description": "I've been working on a partial fix to JCR-630. Instead of implementing fully transactional versioning (i.e. a checkin will disappear when a transactin is rolled back), I'm ensuring that all versioning operations within a transaction will leave the version store in a consistent state even if the transaction otherwise fails at any point.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1599",
        "summary": "LuceneQueryBuilder assumes readability of root-Node to be granted in any case.",
        "description": "Have a User U. \nHave the User U denied to read \"/\".\nHave the User U allowed to read \"/home/u\".\n\nAny query of User U on this workspace fails with an AccessDeniedException.\n\nThe exception is caused by a call insided LuceneQueryBuilder on ln212:\nNodeId id = ((NodeImpl) session.getRootNode()).getNodeId(); \n\nI couldn't find a specification that imposes the readability of root-node as a precondtion for query.\nTherefore I consider this behavior as a bug.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2812",
        "summary": "Allow whitespaces in base64 encoded binary fields of XML import files",
        "description": "When importing files using Session.importXML(), the Binary property values are Base64 encoded.  However you cannot put whitespaces in them, and XML files with binaries in them become very long lines.  The files are more manageable if whilespaces could be put in them, as is common to do in base base64 encoded files.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-299",
        "summary": "errors in text filters can cause indexing to fail without warning the client",
        "description": "i've opened this issue to track the discussion at <http://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/5086>. briefly, exceptions thrown by text filters are logged and swallowed by jackrabbit; there's no way for a text filter to signal to the jcr client that indexing failed.\n\nsome solutions have been proposed, including throwing an unchecked exception, which doesn't allow jackrabbit to maintain transactional integrity, and giving filters veto power over the observed repository operation. depending on the difficulty of the solution that is eventually determined to be correct, it may be sufficient for 1.0 to document the issue and perhaps improve the warning/error logging.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3073",
        "summary": "Explicit management of public API",
        "description": "I'd like to start using the Clirr Maven plugin [1] to make sure that we don't accidentally break backwards compatibility in our public APIs, most notably in jackrabbit-api and jackrabbit-jcr-commons.\n\nAlso, we should start explicitly managing the API versions exposed as a part of the OSGi package metadata. Currently all our public packages simply get the latest project version as their version number, but it would be better if the version was explicitly managed and only updated if the API actually changes. To do this I propose we use @Version annotations from the bnd tool on the package-info.java files in all packages considered a part of our public API.\n\nThe Clirr plugin should flag all changes made in the API, so we have an easy way to tell which packages need to have their version numbers updated.\n\n[1] http://mojo.codehaus.org/clirr-maven-plugin/",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-40",
        "summary": "Node merge method doesnt seems to recurse thru childs of the right source node",
        "description": "I checked the NodeImpl.merge(...)\n\nit seems the way it process the childs nodes is wrong\nas it calls the merge on the childs of the src node that come from the source workspace.\nplus in the case srcNode is null it would end on a NullPointerException as\n\nit does  NodeIterator ni = srcNode.getNodes(); in the second statment of the if condition\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1200",
        "summary": "allow SPI implementation to compute default values for autocreated properties",
        "description": "Currently, when creating nodes in transient space, JCR2SPI uses hard-wired logic trying to populate system generated properties such as jcr:created, jcr;uuid and so on.\n\nThis is problematic as\n\n- it doesn't scale -- it fails for autocreated properties not known to JCR2SPI, and\n\n- the syntax for the defaults may be dependant on the back end, such as legal syntax for (UU)IDs.\n\nProposal:\n\n- extend QValueFactory with something like\n\n  QValue computeDefaultValue(QPropertyDefinition)\n\n- use that in JCR2SPI, getting rid of the currently hard-wired logic.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-471",
        "summary": "Create resource sensitive cache for item states",
        "description": "there is currently a lru-caching strategy for the itemstates in the shared ism, with a hardcoded limit of 1000 entries. the problem is that the size of the states is not respected in the caching strategy; this poses a problem, if the\nstates are large (i.e. large values in property states, or large number of childnode entries).",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-288",
        "summary": "inconsistent session state after Item/Session.save() throwing ReferentialIntegrityException",
        "description": "issue reported by Tomasz.Dabrowski@cognifide.com on jackrabbit dev list.\n\ncode fragment to reproduce issue:\n\n// setup test case\n\nNode parent = root.addNode(\"a\", \"nt:unstructured\");\nNode child1 = parent.addNode(\"b\", \"nt:unstructured\");\nchild1.addMixin(\"mix:referenceable\");\nNode child2 = parent.addNode(\"c\", \"nt:unstructured\");\nchild2.setProperty(\"ref\", child1);\nroot.save();\n\n// perform test\n\ntry {\n    child1.remove();\n    parent.save();\n} catch (ReferentialIntegrityException rie) {\n    // expected since child1 is still being referenced by property \"ref\" of child2\n}\n\nparent.remove();     // ==> should succeed but throws ItemNotFoundException \n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2788",
        "summary": "Provide a JackrabbitNode#setMixins(String[] mixinNames) method",
        "description": "assume the following scenario:\n\n- mixin A declares the mandatory property p\n- mixin A' extends from A\n- node n has mixin A'\n- we'd like to migrate/downgrade node n from mixin A' to A\n\ncurrently there's no easy way of replacing the assigned mixins.\n\nassigning A first results in a NOP since A would be redundant.\nremoving A' first removes the mandatory property p.\n\na new method setMixins(String[]) would allow to migrate\na node from mixin A' to A while preserving 'shared' content.\nthe semantics of setMixins(String[]) would be similar to\nNode.setPrimaryType(String).",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1309",
        "summary": "Refactor DBMS support for JNDI datasources",
        "description": "Our shop currently uses Oracle for most projects, most commonly in an application server (Tomcat, WebSphere, etc.), and use configured J2EE datasources. Unfortunately, many of the classes that fix quirks on specific DBMS force you to configure a JDBC connection (look at org.apache.jackrabbit.core.fs.db.OracleFileSystem for instance), which is a \"bad idea\" on an application server -- the application server should be managing resources like DB connections, etc.  If you want to use an DbFileSystem based on an Oracle database, you can't use a datasource from a JNDI lookup.  This in effect makes Jackrabbit unusable in clustered enterprise environments.\n\nIt would be much better to refactor the current database support to separate the method that an implementation obtains its connection from its functionality.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1632",
        "summary": "Mixin type loss",
        "description": "When using a bundle persistence manager, the mixin type information may be corrupted in the lucene index, causing queries like '//element(*, my:mixin)' to fail.\n\n\n\nThe problem is that the 'jcr:mixinTypes' may be stored in the bundle. Here is how this could happen :\n\n\nFirst step: Create a node and add a mixin 'A'.\n\nEverything's fine. The query '//element(*, 'A')' works.\n\n\nSecond step : Select the node and add a second mixin 'B'.\n\nWhen the second mixin is added, the AbstractBundlePersistenceManager#load(PropertyId) is called to get the current mixins for the node. This method will store the PropertyState for 'jcr:mixinTypes' in the bundle (containing only the mixin 'A'). Then the NodeImpl#setMixinTypesProperty() will set the PropertyState for 'jcr:mixinTypes' in the node state (containing the mixins 'A' and 'B').\nWhen the session is saved, the ChangeLog in AbstractBundlePersistenceManager#store() contains a modification for the 'jcr:mixinTypes' but it's being ignored, leaving the bundle with only mixin 'A'. The NodeIndexer looks into the node state to get the mixin types and indexes the node correctly. The queries '//element(*, 'A')' and '//element(*, 'B')' work.\n\n\nThrid step : Select the node and update a property. \n\nWhen the session is saved, the NodeIndexer asks again for the 'jcr:mixinTypes' property, by calling the AbstractBundlePersistenceManager#load(PropertyId) to load it. The bundle contains this property and returns only mixin 'A' (as it was stored in the second step), causing the index to use only mixin 'A'. The query '//element(*, 'A')' still works but '//element(*, 'B') doesn't work anymore.\n\n\n\nA simple solution to this would be to not store the PropertyState for the 'jcr:mixinTypes' (and 'jcr:uuid' and 'jcr:primaryType', as the class description states) in the bundle when the PropertyState is loaded. It would fix the issue but not the contents on existing repositories. One way to allow the repositories to fix themselves is to not read or write these 3 properties in the BundleBinding#readBundle and BundleBinding#writeBundle methods, but I'm not sure wether or not it would have a performance impact.\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1739",
        "summary": "Do not use deletable anymore",
        "description": "The query handler implementation currently uses a deletable file to keep track of index segments that are not needed anymore and can be deleted. In general index segments are deleted right away when they are not needed anymore, but it may happen that index readers are still open (because of a time consuming query) and the index segment cannot be deleted at the moment. In this case the index segment name is written to the deletable file and the index periodically tries to delete the segment later.\n\nThe implementation should rather infer from the indexes file on startup, which segments are still needed and in use.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-167",
        "summary": "Add maven-eclipse-plugin properties to project.xml for easier configuration in IDE",
        "description": "- add the maven.eclipse.resources.addtoclasspath=true property to project.properties (make the eclipse plugin create source dirs also for resources). \n\n- add the <eclipse.dependency>true</eclipse.dependency> property to all the jackrabbit internal dependencies in all the POMs (all the dependencies with \"jackrabbit\" groupId) so internal dependencies becomes project dependencies in eclipse.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-529",
        "summary": "New versions added after a restore have bad version name",
        "description": "I add several versions to a node (1.0, 1.1, 1.2, 1.3, 1.4). Perform a restore to version 1.2 and add more versions. After that VersionHistory is like this:\n\n- 1.0\n- 1.1\n- 1.2\n- 1.3\n- 1.4\n- 1.3.1\n- 1.3.2\n- 1.3.3\n- 1.3.4\n- 1.3.5\n\nNew versions should be 1.2.x no 1.3.x, isn't it?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1757",
        "summary": "OCM: translate-project goal not found",
        "description": "The jackrabbit-ocm POM doesn't specify the required version of the Retrotranslator plugin it uses. In some cases this causes the build to use an older version of the plugin that doesn't come with the translate-plugin goal.\n\nThe goal is included in the latest version (1.0-alpha-4) of the plugin.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1797",
        "summary": "SPI: RepositoryService.getItemInfos should be allowed to return entries outside of the requested tree.",
        "description": "michael duerig asked for for that extension of the semantic of RepositoryService.getItemInfos.\ncurrently this doesn't work and leads to an inconsistent hierarchy.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1113",
        "summary": "Refactor the Mapper & DescriptotReader classes",
        "description": "I would like to refactor the mappers and the descriptor readers  in order to : \n* Create an abstract mapper impl because both Mapper classes have a lot of code in common (AnnotedObjectMapper & DigesterMapperImpl). Only the readers are different. The Mappers can make exactly the same process. \n* The Mapper classes should not have the responsibility to create the jcr node types. This can be done outside the mapper and it should be an optional operation. There are certainly some use cases where node type creation is not necessary. Right now, the annotated object mapper creates jcr node types. ",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2996",
        "summary": "QOM to SQL2 doesn't cast numeric literals",
        "description": "SQL2 statements generated by the QueryObjectModel.getStatement() don't contain CAST(... AS ...) for numeric literals of types DECIMAL, DOUBLE, and LONG. The type information is lost, which can result in incorrect query results (depending on the query engine) if the generated SQL2 statement is executed.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-295",
        "summary": "Jcr-Server: Usage of Cache-Control header",
        "description": "DeltaV-methods (except for Version-Control and Report) require the Cache-Control header to be present in the response.\nIn turn, RFC 2518 only requires the Cache-Control header to be present in the request  when dealing with the If header.\n\nCurrently the Cache-Control header is always present in the response and not specific for DeltaV methods.\nProblems may arise with IE  and a couple of mimetypes such as zip-files",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-810",
        "summary": "Typos in method names in test classes (SetPropertyAssumeTypeTest)",
        "description": "Misspelled: \"ConstraintVioloationException\".\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-266",
        "summary": "Denying a primaryType does not work in XPath",
        "description": "The following query does not work:\n\n//element(*, my:type)[jcr:contains(.,'foo') and @jcr:primaryType != 'nt:frozenNode')\n\nThe jcr:primaryType predicate does not respect the 'not equal' operation.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3119",
        "summary": "Improve aggregate node indexing code",
        "description": "Currently the aggregate nodes indexing code uses a sub-optimal way of copying and sorting the aggregated fields.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-112",
        "summary": "add target jvm in maven properties for compilation",
        "description": "actually the compatibility level for sources/binaries is not defined in project.properties, so if you compile jackrabbit with a 1.5 jdk it will not run on older vm.\n\nIt would be nice to add the following properties to assure that the generated jar will work on different jvms:\nmaven.compile.target=1.4\nmaven.compile.source=1.4\n\n(or 1.3 if you are targetting also java 1.3)",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1913",
        "summary": "Use configured credentials in RepositoryFactoryImplTest ",
        "description": "The test currently uses hard coded credentials. It should rather use configured credentials like all other tests do.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-756",
        "summary": "Concurrent add/remove child node operations in a cluster may corrupt repository.",
        "description": "Concurrent add/remove child node operations in a cluster may store an inconsistent list of child node entries, i.e. an entry in the list may appear that has no associated node. This eventually results in an ItemNotFoundException, the next time one of these bogus entries is accessed.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2461",
        "summary": "Item retrieval inefficient after refresh",
        "description": "When RepositoryService#getItemInfos() returns a sufficiently large batch for a path, then the second invocation of getItem() below is significantly slower than the first. \n\nString path = ...\nItem i = session.getItem(path);\ni.refresh(false); // same for refresh(true)\nsession.getItem(path);\n\nIn my test setup RepositoryService#getItemInfos() returns 3946 elements. The first invocation takes approx. 800ms, the second 3000ms.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2191",
        "summary": "IndexingAggregateTest#testNtFileAggregate fails occasionally",
        "description": "It may happen that the text extraction from a plain/text resource times out due to the tough extractor time out set on the indexing-test workspace.\n\nThe test should check if the indexing queue is empty before it executes a query.",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-88",
        "summary": "jcr:path in QueryResult is only tested with SQL",
        "description": "The TCK should also include a test case for XPath query syntax.",
        "label": "NUG",
        "classified": "TEST",
        "type": "TEST"
    },
    {
        "key": "JCR-2528",
        "summary": "spi2dav: ItemInfoCache causes failure of (Workspace)RestoreTest#testRestoreWithUUIDConflict and variants",
        "description": "while running the API version tests i found the (Workspace)RestoreTest.testRestoreWithUUIDConfict and variants failing. to be precise the test passes but\ntransiently removing the versionableNode2 in the teardown fails upon removal of the jcr:uuid property of the moved childnode.\n\nhaving a closer look at it revealed that the problem is caused in the WorkspaceItemStateFactory where the property entry is retrieved from the\ncache and subsequently checking if the path really matches fails. for test purposes i prevented the usage of the cached entry by returning false in WorkspaceItemStateFactory.isUpToDate  => the tests passed. \n\nas far as i know the same tests pass with spi2jcr.\nmichael, could it be that this is caused by a flaw in the iteminfo-cache logic? or is there something specific that needs to be adjusted in spi2dav?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-254",
        "summary": "Repository lock file is not removed on shutdown",
        "description": "The repository lock file is not removed when Jackrabbit runs on a windows platform:\n\n*ERROR* [Thread-4] RepositoryImpl: Unable to release repository lock (RepositoryImpl.java, line 283)\n\nI assume this problem does not occur on unix based platforms, because they allow to delete a file while another process still uses it.",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2074",
        "summary": "JSR 283: New Event Types",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1287",
        "summary": "jackrabbit-webapp facelift",
        "description": "Still before 1.4, I meant to make the jackrabbit-webapp look a bit nicer. I'm taking the skin from JCR-1236 and applying it to jackrabbit-webapp.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2330",
        "summary": "Restore mix:referenceable check to SessionImpl.getNodeByUUID",
        "description": "In revision 504623 we commented out the mix:referenceable check in the SessionImpl.getNodeByUUID() method:\n\n    // since the uuid of a node is only exposed through jcr:uuid declared\n    // by mix:referenceable it's rather unlikely that a client can possibly\n    // know the internal uuid of a non-referenceable node; omitting the\n    // check for mix:referenceable seems therefore to be a reasonable\n    // compromise in order to improve performance.\n    /*\n    if (node.isNodeType(Name.MIX_REFERENCEABLE)) {\n        return node;\n    } else {\n        // there is a node with that uuid but the node does not expose it\n        throw new ItemNotFoundException(uuid.toString());\n    }\n    */\n\nThis solved a minor performance issue issue with client code that used the node UUID as a quick way to access a node. The downside was a slight incompatibility with the spec that says that the getNodeByUUID method is only supposed to work with mix:referenceable nodes.\n\nNow with JCR 2.0 clients can (and should) use the Session.getNodeByIdentifier method that does not have the mix:referenceable limitation. Thus we can restore the original and correct functionality of the getNodeByUUID method.",
        "label": "NUG",
        "classified": "BACKPORT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2296",
        "summary": "Consolidate ItemDef/QItemDefinition",
        "description": "There is a great deal of duplicate code in ItemDef (jackrabbit-core) and QItemDefinition (jackrabbit-spi) and their implementing classes.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-491",
        "summary": "TCK: PredefinedNodeTypeTest does not allow additions to the predefined node types hierarchy",
        "description": "As explained in section 6.7.22.2 (page 147) of the JSR 170 specification, an implementation is allowed to customize a predefined noe type definition with additional supertypes. The tests in PredefinedNodeTypeTest do not account for that and expect an exact match with the predefined node types.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-545",
        "summary": "New method on NodeTypeManagerImpl to reregister nodetypes",
        "description": "Add a method to NodeTypeManagerImpl to allow reregistering of existing nodetypes. The method takes an inputstream in either XML or CND format and registers all new nodetypes and reregisters existing nodetypes.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-185",
        "summary": "filter jcr properties in jcr-server",
        "description": "attached is a patch that implements jcr property filtering in jcr-server in the same way that nodes and resources are filtered. with the default filter configuration, this has the effect of filtering jcr:created, jcr:mixinTypes, and jcr:primaryType from nt:folder and nt:file nodes. \n\nthis is likely the expected default behavior for most webdav servers - they want to return the normal dav properties, live properties defined themselves, and dead properties defined by clients, but not jcr-internal properties which are for all intents and purposes implementation-specific.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1388",
        "summary": "Jackrabbit does not allow concurrent reads to the data store if copyWhenReading=false",
        "description": "Jackrabbit does not allow concurrent reads to the data store if copyWhenReading=false, even if maxConnections>1.\nSee JCR-1184 for a test for this problem (run it with copyWhenReading=false).\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-659",
        "summary": "import of multivalue properties with single value results in incorrect property creation",
        "description": "When importing a file exported with system view, a value of a multivalued property is stored as a singlevalue property. The bug seems to be that for some reason, even if PropDef.isMultiple() is true for a given property, no ValueFormatException is thrown when setting the property as single value.\n\nWorkaround:\n\nIt works if I change PropInfo.apply() line 136 to \n\nif (va.length == 1 && !def.isMultiple()) {\n...\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-9",
        "summary": "Version.isSame(Object) not working",
        "description": "Version interface is implemented (on the frontend) by the VersionImpl class (extending NodeWrapper), which delegates to an internal NodeImpl class, which in turn extends ItemImpl.\n\nSay you have :\n      Node node = // at Version 1.0\n      Version version = // retrieved as 1.0 for the node\n      Version baseVersion = node.getBaseVersion()\n\nYou now expect\n      baseVersion.isSame(version)\neven if\n      baseVersion != version\n\nThis fails, because VersionImpl delegates the isSame call to its delegatee, thus above call becomes\n      ((VersionImpl) baseVersion).delegatee.isSame(version)\nwhere this method is implemented by the ItemImpl class from which the delegatee NodeImpl extends.\n\nThat latter implementation ItemImpl.isSame() only returns true if the other is an ItemImpl, too. But this is not the case because VersionImpl is a Version, NodeWrapper, Node but not an ItemImpl.\n\nProbably the best solution would be for NodeImpl.isSame() to check whether the otherItem is a NodeWrapper und use ((NodeWrapper) otherItem).delegatee as the otherItem for the delegatee call.\n\nOn another track: ItemImpl.isSame() should probably do a fast check whether the otherItem is actually the same instance to prevent type checks...",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2614",
        "summary": "Include the WebDAV litmus tests in the Jackrabbit integration tests",
        "description": "It would be great to integrate the litmus tests (http://www.webdav.org/neon/litmus/) to our integration test suite.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2411",
        "summary": "Replace commons-logging with jcl-over-slf4j in jackrabbit-webdav",
        "description": "In JCR-1631 we moved the exclusion rule against the transitive commons-logging dependency from commons-httpclient to higher level components like jackrabbit-jca and jackrabbit-webapp.\n\nHowever, I'm having some trouble with commons-logging showing up in other downstream projects that depend directly on jackrabbit-webapp or jackrabbit-jcr-server. Thus I'd like to revert the JCR-1631 solution and push the exclusion rule back to jackrabbit-webapp and replace the commons-logging dependency with jcl-over-slf4j. Downstream projects that already use commons-logging can still exclude the jcl-over-slf4j dependency.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1068",
        "summary": "NamespaceRegistryTest.testRegisterNamespace test assumptions",
        "description": "NamespaceRegistryTest.testRegisterNamespace() makes the assumption that it is possible to create arbitrarily nodes inside the root folder.\n\nThis is not required to be the case.\n\nProposal: \n\n- get the name of the test node from the config, and\n\n- use a property rather than a child node for the test (as far as I can tell, many repositories will not allow node names in namespaces other than the empty one).\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1533",
        "summary": "Update POI dependency to 3.0.2-FINAL",
        "description": "3.0.2-FINAL is the most recent POI release.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2486",
        "summary": "Promote ItemInfo builder classes from GetItemsTest to top level classes",
        "description": "org.apache.jackrabbit.jcr2spi.GetItem test contains builders for ItemInfo and NodeInfo instances. These should be generalized and promoted to spi-commons. ",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2989",
        "summary": "Support for embedded index aggregates",
        "description": "Index aggregates could contain other index aggregates. JR should be able to handle a complete hierarchy of aggregates. \n\nI'm working on a patch.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2323",
        "summary": "InputStream.read return value is ignored.",
        "description": "RepositoryImpl.loadRootNodeId reads from an InputStreamReader using read(...) and ignores the return values.\n\nThis results in a problem if the input stream doesn't read all bytes.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1392",
        "summary": "[PATCH] Exception not thrown where it appears it should have been",
        "description": "Code creates an expection in an apparent error state, but doesn't throw it when it looks like it should\n\nclass: org.apache.jackrabbit.webdav.jcr.search.SearchResultProperty\nctor: public SearchResultProperty(DavProperty property, ValueFactory valueFactory) throws RepositoryException\naround line 96\n\n        } else {\n            new IllegalArgumentException(\"SearchResultProperty requires a list of 'dcr:column' xml elements.\");\n        }\n\nPatch fixes this",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1770",
        "summary": "RFC4918 feature: absolute paths in \"Destination\" and \"If\" headers",
        "description": "RFC4918 allows absolute paths (instead of absolute URIs) in the \"Destination\" and \"If\" headers (<http://greenbytes.de/tech/webdav/rfc4918.html#rfc.section.14.8>). This makes it simpler to deal with situations where reverse proxies are involved (because those usually are not aware of WebDAV request headers and do not rewrite them).",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3032",
        "summary": "QDefinitionBuilderFactory should auto-subtype from nt:base",
        "description": "Similar to JCR-2066, the QNodeTypeDefinitions build by QDefinitionBuilderFactory should auto subtype from nt:base. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1315",
        "summary": "Add Google Analytics to Jackrabbit web site",
        "description": "I'd like to add Google Analytics to our web site to better track how the site is used and how much traffic we are generating.\n\nCurrently the best stats we have are at http://people.apache.org/~vgritsenko/stats/projects/jackrabbit.html, which is nice but not nearly as good as we could have.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "TASK"
    },
    {
        "key": "JCR-2207",
        "summary": "XATest error: commit from different thread but same XID must not block",
        "description": "I'm seeing the following test error quite often in the CI server at work:\n\ntestDistributedThreadAccess(org.apache.jackrabbit.core.XATest)  Time elapsed: 0.213 sec  <<< ERROR!\njavax.transaction.SystemException: commit from different thread but same XID must not block\n\tat org.apache.jackrabbit.core.UserTransactionImpl.commit(UserTransactionImpl.java:147)\n\tat org.apache.jackrabbit.core.XATest.testDistributedThreadAccess(XATest.java:1637)\n\nIt seems to be a system-specific issue, as I've never seen the same error locally or on Hudson.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1675",
        "summary": "Provide names for constants in QueryConstants",
        "description": "For debugging, logging, and user interaction purposes QueryConstants should include descriptive names for the constants it provides.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1371",
        "summary": "[PATCH] unnecessary synchronized collections used only in thread safe way",
        "description": "NodeTypeReader uses Vector in only a local variable thread safe way. Thus the synchronized value of Vector is not needed, and just slowing the code down for nothing. this patch switches the collections to ArrayLists.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1280",
        "summary": "Path.equals does not work for other Path implementations",
        "description": "PathImpl.equals does not take other path implementations into account (likely a typo).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2032",
        "summary": "Jcr-Server: BasicCredentialsProviderTest throws NPE if defaultAuthHeader init param misses the password",
        "description": "issue reported by dominique jaeggi:\n\na missing-auth-header init param that has the form \"uid\" instead of \"uid:pw\" or \"uid:\" results in NPE upon SimpleCredentials creation.\n\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-54",
        "summary": "Remove JDOM dependency",
        "description": "Proposed by Sylvain Wallez on the dev mailing list.\n\nReplace the JDOM code in the config, nodetype, and xml persistence manager code with equivalent standard DOM code. This change introduces some extra lines of code, but would remove an external dependency and avoid unnecessary deployment problems.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1548",
        "summary": "Several bugs in last SVN commit",
        "description": "Just a few bugs in the last SVN commit, but since I work with it, i thought useful to mention them :\n1) org.apache.jackrabbit.ocm.reflection.ReflectionUtils should handle Set --> just add it in defaultImplementation\n2) in org.apache.jackrabbit.ocm.manager.collectionconverter.ManageableObjectsUtil.getManageableObjects, correct defaultImplementation test :\n        \t\tif (defaultImplementation == null)\n        \t\t{\n        \t\t\tthrow new JcrMappingException(\"No default implementation for the interface \" + manageableObjectsClass);\n\nThank you and keep up the good work!\n\nSincerely yours,\n\nStephane",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2272",
        "summary": "Errors during concurrent session import of nodes with same UUIDs",
        "description": "21.08.2009 16:22:14 *ERROR* [Executor 0] ConnectionRecoveryManager: could not execute statement, reason: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL090821042140130' defined on 'DEFAULT_BUNDLE'., state/code: 23505/20000 (ConnectionRecoveryManager.java, line 453)\n21.08.2009 16:22:14 *ERROR* [Executor 0] BundleDbPersistenceManager: failed to write bundle: 6c292772-349e-42b3-8255-7729615c67de (BundleDbPersistenceManager.java, line 1212)\nERROR 23505: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by 'SQL090821042140130' defined on 'DEFAULT_BUNDLE'.\n\tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.IndexChanger.insertAndCheckDups(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.IndexChanger.doInsert(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.IndexChanger.insert(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.IndexSetChanger.insert(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.RowChangerImpl.insertRow(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)\n\tat org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute(Unknown Source)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:371)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:298)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:261)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:239)\n\tat org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.storeBundle(BundleDbPersistenceManager.java:1209)\n\tat org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.putBundle(AbstractBundlePersistenceManager.java:709)\n\tat org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.storeInternal(AbstractBundlePersistenceManager.java:651)\n\tat org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.store(AbstractBundlePersistenceManager.java:527)\n\tat org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.store(BundleDbPersistenceManager.java:563)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:724)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:1101)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:351)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:354)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:326)\n\tat org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:326)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1098)\n\tat org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:925)\n\tat org.apache.jackrabbit.core.ConcurrentImportTest$1.execute(ConcurrentImportTest.java:73)\n\tat org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:209)\n\tat java.lang.Thread.run(Thread.java:637)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-267",
        "summary": "temporary files created by some jUnit test are not automatically removed",
        "description": "",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-3063",
        "summary": "NullPointerException in ItemManager",
        "description": "We have a lot of these occurring:\njava.lang.NullPointerException\n\tat org.apache.jackrabbit.core.ItemManager.getDefinition(ItemManager.java:206)\n\tat org.apache.jackrabbit.core.ItemData.getDefinition(ItemData.java:99)\n\tat org.apache.jackrabbit.core.AbstractNodeData.getNodeDefinition(AbstractNodeData.java:73)\n\tat org.apache.jackrabbit.core.NodeImpl.getDefinition(NodeImpl.java:2430)\n\tat org.apache.jackrabbit.core.ItemValidator.isProtected(ItemValidator.java:373)\n\tat org.apache.jackrabbit.core.ItemValidator.checkCondition(ItemValidator.java:273)\n\tat org.apache.jackrabbit.core.ItemValidator.checkRemove(ItemValidator.java:254)\n\tat org.apache.jackrabbit.core.ItemRemoveOperation.perform(ItemRemoveOperation.java:63)\n\tat org.apache.jackrabbit.core.session.SessionState.perform(SessionState.java:200)\n\tat org.apache.jackrabbit.core.ItemImpl.perform(ItemImpl.java:91)\n\tat org.apache.jackrabbit.core.ItemImpl.remove(ItemImpl.java:322)\n\tat org.apache.jackrabbit.core.NPEandCMETest$TestTask.run(NPEandCMETest.java:87)\n\tat java.lang.Thread.run(Thread.java:679)\n\nI'll attach a junit test to reproduce this exception.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2258",
        "summary": "Unclosed sessions in test cases",
        "description": "Some tests may throw exceptions in the setUp() method and leave the session open that was opened in the super class setUp() method. For jackrabbit-core, this is not really a problem, because the memory footprint of a session is quite small, but in jcr2spi the memory footprint is considerable higher, which may lead to out of memory errors when running the tests.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1250",
        "summary": "When adding a large (100MB) binary to the DbDataStore, it fails with an insufficient memory exception",
        "description": "Attached is a small test case. It fails during save(). I think this is related to what I mentioned in http://mail-archives.apache.org/mod_mbox/jackrabbit-dev/200711.mbox/%3c00fc01c832b9$f1f08730$7309240a@goku%3e\n\nThe full stacktrace is the following:\n\njavax.jcr.RepositoryException: /: unable to update item.: failed to write property state: cafebabe-cafe-babe-cafe-babecafebabe/{}bin: failed to write property state: cafebabe-cafe-babe-cafe-babecafebabe/{}bin\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1252)\n\tat org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:858)\n\tat org.apache.jackrabbit.core.data.BigBinaryTest.testBigBinary(BigBinaryTest.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat org.apache.jackrabbit.test.AbstractJCRTest.run(AbstractJCRTest.java:404)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\nCaused by: org.apache.jackrabbit.core.state.ItemStateException: failed to write property state: cafebabe-cafe-babe-cafe-babecafebabe/{}bin\n\tat org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.store(DatabasePersistenceManager.java:487)\n\tat org.apache.jackrabbit.core.persistence.AbstractPersistenceManager.store(AbstractPersistenceManager.java:75)\n\tat org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.store(DatabasePersistenceManager.java:282)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:687)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:856)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:324)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:313)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:300)\n\tat org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:306)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1244)\n\t... 21 more\nCaused by: org.apache.jackrabbit.core.data.DataStoreException: Can not read identifier a2ada2d96d0b05214288efa03be9005a5bb98c9b: Memoria insuficiente. Utilice cursores del servidor para result sets grandes:Java heap space. Tama\u00f1o de result set:104.857.723. Tama\u00f1o memoria total JVM:66.650.112.: Memoria insuficiente. Utilice cursores del servidor para result sets grandes:Java heap space. Tama\u00f1o de result set:104.857.723. Tama\u00f1o memoria total JVM:66.650.112.\n\tat org.apache.jackrabbit.core.data.db.DbDataStore.convert(DbDataStore.java:438)\n\tat org.apache.jackrabbit.core.data.db.DbDataStore.getInputStream(DbDataStore.java:481)\n\tat org.apache.jackrabbit.core.data.db.DbDataRecord.getStream(DbDataRecord.java:61)\n\tat org.apache.jackrabbit.core.value.BLOBInDataStore.getStream(BLOBInDataStore.java:93)\n\tat org.apache.jackrabbit.core.persistence.util.Serializer.serialize(Serializer.java:198)\n\tat org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.store(DatabasePersistenceManager.java:476)\n\t... 30 more\nCaused by: com.microsoft.sqlserver.jdbc.SQLServerException: Memoria insuficiente. Utilice cursores del servidor para result sets grandes:Java heap space. Tama\u00f1o de result set:104.857.723. Tama\u00f1o memoria total JVM:66.650.112.\n\tat com.microsoft.sqlserver.jdbc.SQLServerException.makeFromDriverError(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.DBComms.receive(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement.doExecutePreparedStatement(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement$PreparedStatementExecutionRequest.executeStatement(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.CancelableRequest.execute(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerConnection.executeRequest(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement.execute(Unknown Source)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:362)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:292)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:257)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:237)\n\tat org.apache.jackrabbit.core.data.db.DbDataStore.getInputStream(DbDataStore.java:474)\n\t... 34 more\norg.apache.jackrabbit.core.state.ItemStateException: failed to write property state: cafebabe-cafe-babe-cafe-babecafebabe/{}bin\n\tat org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.store(DatabasePersistenceManager.java:487)\n\tat org.apache.jackrabbit.core.persistence.AbstractPersistenceManager.store(AbstractPersistenceManager.java:75)\n\tat org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.store(DatabasePersistenceManager.java:282)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:687)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:856)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:324)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:313)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:300)\n\tat org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:306)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1244)\n\tat org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:858)\n\tat org.apache.jackrabbit.core.data.BigBinaryTest.testBigBinary(BigBinaryTest.java:16)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat org.apache.jackrabbit.test.AbstractJCRTest.run(AbstractJCRTest.java:404)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\nCaused by: org.apache.jackrabbit.core.data.DataStoreException: Can not read identifier a2ada2d96d0b05214288efa03be9005a5bb98c9b: Memoria insuficiente. Utilice cursores del servidor para result sets grandes:Java heap space. Tama\u00f1o de result set:104.857.723. Tama\u00f1o memoria total JVM:66.650.112.: Memoria insuficiente. Utilice cursores del servidor para result sets grandes:Java heap space. Tama\u00f1o de result set:104.857.723. Tama\u00f1o memoria total JVM:66.650.112.\n\tat org.apache.jackrabbit.core.data.db.DbDataStore.convert(DbDataStore.java:438)\n\tat org.apache.jackrabbit.core.data.db.DbDataStore.getInputStream(DbDataStore.java:481)\n\tat org.apache.jackrabbit.core.data.db.DbDataRecord.getStream(DbDataRecord.java:61)\n\tat org.apache.jackrabbit.core.value.BLOBInDataStore.getStream(BLOBInDataStore.java:93)\n\tat org.apache.jackrabbit.core.persistence.util.Serializer.serialize(Serializer.java:198)\n\tat org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.store(DatabasePersistenceManager.java:476)\n\t... 30 more\nCaused by: com.microsoft.sqlserver.jdbc.SQLServerException: Memoria insuficiente. Utilice cursores del servidor para result sets grandes:Java heap space. Tama\u00f1o de result set:104.857.723. Tama\u00f1o memoria total JVM:66.650.112.\n\tat com.microsoft.sqlserver.jdbc.SQLServerException.makeFromDriverError(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.DBComms.receive(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement.doExecutePreparedStatement(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement$PreparedStatementExecutionRequest.executeStatement(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.CancelableRequest.execute(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerConnection.executeRequest(Unknown Source)\n\tat com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement.execute(Unknown Source)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:362)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:292)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:257)\n\tat org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:237)\n\tat org.apache.jackrabbit.core.data.db.DbDataStore.getInputStream(DbDataStore.java:474)\n\t... 34 more\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1554",
        "summary": "StaleItemStateException with distributed transactions",
        "description": "There seams to be a serious bug in jackrabbit when used in distributed transactions. It does not occur with local transactions! And it seams to be related to JCR-566.\n\nThere are 2 scenarios where a StaleItemStateException occurs reproducible that causes transactions to fail. All my operations (implemented in a custom ServiceBean) such as setProperty() or deleteNode() run in separate transactions. The transactions are configured through Spring Annotations (@Transactional).\n\nScenario A (setProperty):\n(1) multiple setProperty() with same property name on the same node (newly created or already existent)\n=> With the 3. setProperty() (and sometimes also the 5.), a StaleItemStateException for the property state is raised when the transaction is commited. Following setProperty invocations will not fail!\n\nScenario B (deleteNode):\n(1) iterate 10 times:\n(1.1) create new node n and a subnode for n\n(1.2) delete node n\n=> Deletion of node n raises a StaleItemStateException for node n in iteration 1, 3 and (6 or 7), when the related transaction is commited. Following deletions of node n will also fail with a predictable pattern.\n\nThe Exception trace for scenario A (it's the same for scenario B, with one difference: StaleItemStateException is raised for the node and not for the property):\n\norg.springframework.transaction.UnexpectedRollbackException: JTA transaction unexpectedly rolled back (maybe due to a timeout); nested exception is javax.transaction.RollbackException: Error during one-phase commit\n\tat org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1031)\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:709)\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:678)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:321)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:116)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)\n\tat $Proxy9.setNodeProperty(Unknown Source)\n\tat de.zeb.control.prototype.jrTxBug.test.TestJackrabbitTxBug.testTransactionBug001(TestJackrabbitTxBug.java:97)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat org.testng.internal.MethodHelper.invokeMethod(MethodHelper.java:580)\n\tat org.testng.internal.Invoker.invokeMethod(Invoker.java:478)\n\tat org.testng.internal.Invoker.invokeTestMethod(Invoker.java:607)\n\tat org.testng.internal.Invoker.invokeTestMethods(Invoker.java:874)\n\tat org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:125)\n\tat org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)\n\tat org.testng.TestRunner.runWorkers(TestRunner.java:689)\n\tat org.testng.TestRunner.privateRun(TestRunner.java:566)\n\tat org.testng.TestRunner.run(TestRunner.java:466)\n\tat org.testng.SuiteRunner.runTest(SuiteRunner.java:301)\n\tat org.testng.SuiteRunner.runSequentially(SuiteRunner.java:296)\n\tat org.testng.SuiteRunner.privateRun(SuiteRunner.java:276)\n\tat org.testng.SuiteRunner.run(SuiteRunner.java:191)\n\tat org.testng.TestNG.createAndRunSuiteRunners(TestNG.java:808)\n\tat org.testng.TestNG.runSuitesLocally(TestNG.java:776)\n\tat org.testng.TestNG.run(TestNG.java:701)\n\tat org.testng.remote.RemoteTestNG.run(RemoteTestNG.java:73)\n\tat org.testng.remote.RemoteTestNG.main(RemoteTestNG.java:124)\nCaused by: javax.transaction.RollbackException: Error during one-phase commit\n\tat org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:281)\n\tat org.apache.geronimo.transaction.manager.TransactionManagerImpl.commit(TransactionManagerImpl.java:143)\n\tat org.apache.geronimo.transaction.context.InheritableTransactionContext.complete(InheritableTransactionContext.java:196)\n\tat org.apache.geronimo.transaction.context.InheritableTransactionContext.commit(InheritableTransactionContext.java:146)\n\tat org.apache.geronimo.transaction.context.OnlineUserTransaction.commit(OnlineUserTransaction.java:80)\n\tat org.jencks.factory.UserTransactionFactoryBean$GeronimoUserTransaction.commit(UserTransactionFactoryBean.java:118)\n\tat org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1028)\n\t... 30 more\nCaused by: javax.transaction.xa.XAException\n\tat org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:155)\n\tat org.apache.jackrabbit.core.XASessionImpl.commit(XASessionImpl.java:337)\n\tat org.apache.jackrabbit.jca.TransactionBoundXAResource.commit(TransactionBoundXAResource.java:39)\n\tat org.apache.geronimo.transaction.manager.WrapperNamedXAResource.commit(WrapperNamedXAResource.java:47)\n\tat org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:272)\n\t... 36 more\nCaused by: org.apache.jackrabbit.core.TransactionException: Unable to prepare transaction.\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:150)\n\tat org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:138)\n\t... 40 more\nCaused by: org.apache.jackrabbit.core.state.StaleItemStateException: bef3c056-bc91-4195-a35c-aa184182b5ad/{}TEST_PROPERTY has been modified externally\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:620)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:843)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:144)\n\t... 41 more\n\n\nWhen debugging into jackrabbit you will see, that the cause of the StaleItemStateException is, that the local state und the overlayed state differ in the value of the 'modCount' attribute: modCount of local state is lower than modCount of overlayed state. Perhaps its a state caching problem...\n\t\nI'm attaching a simple java application configured with maven and ready to run standalone. The JCA container of JBoss is therefore replaced with jencks in order to support distributed transactions. The configured repository uses the InMemPersistenceManager. Both scenarios are implemented in a TestNG - test, that catches the occuring TransactionExceptions and prints out the stacktrace. Therefore you will see the exceptions, but the tests will not fail.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3078",
        "summary": "Add CopyMoveHanlder so that the copy/move behavior can be customized (as this is the case for the IOHandler and PropertyHandler)",
        "description": "The IOHandler impls let you define a specific import/export behavior either for specific nodetypes/locations/etc which is just great. this works well while you create or modify a web dav resource but does not work for the copy/move use case.\nthe attached patch provides a proposal for an additional CopyMoveHandler.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2620",
        "summary": "Authorizable#getProperty and #setProperty should deal with relativePath ",
        "description": "Authorizable#getProperty and #setProperty defines the property to be identified by a name.\n\nThe JCR item based implementation could easily deal with relative paths instead and also retrieve or write properties below child\nnodes of the rep:Authorizable node.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1449",
        "summary": "Registering nodetypes with empty namespace prefix causes a namespace exception in sync node",
        "description": "Registering a nodetype with empty namespace prefix causes a namespace exception in sync node. Stacktrace looks as follows:\n\n03.03.2008 15:33:50 *ERROR* ClusterNode: Unable to read revision '10618'. (ClusterNode.java, line 1051)\no.a.j.core.journal.JournalException: Parse error while reading node type definition.\n        at o.a.j.core.journal.AbstractRecord.readNodeTypeDef(AbstractRecord.java:256)\n        at o.a.j.core.cluster.ClusterNode.consume(ClusterNode.java:1026)\n        at o.a.j.core.journal.AbstractJournal.doSync(AbstractJournal.java:198)\n        at o.a.j.core.journal.AbstractJournal.sync(AbstractJournal.java:173)\n        at o.a.j.core.cluster.ClusterNode.sync(ClusterNode.java:303)\n        at o.a.j.core.cluster.ClusterNode.run(ClusterNode.java:274)\n        at java.lang.Thread.run(Thread.java:595)\nCaused by: o.a.j.core.nodetype.compact.ParseException: Error while parsing 'bla' ((internal), line 3)\n        at o.a.j.core.nodetype.compact.Lexer.fail(Lexer.java:152)\n        at o.a.j.core.nodetype.compact.CompactNodeTypeDefReader.toQName(CompactNodeTypeDefReader.java:653)\n        at o.a.j.core.nodetype.compact.CompactNodeTypeDefReader.doNodeTypeName(CompactNodeTypeDefReader.java:265)\n        at o.a.j.core.nodetype.compact.CompactNodeTypeDefReader.parse(CompactNodeTypeDefReader.java:215)\n        at o.a.j.core.nodetype.compact.CompactNodeTypeDefReader.<init>(CompactNodeTypeDefReader.java:178)\n        at o.a.j.core.nodetype.compact.CompactNodeTypeDefReader.<init>(CompactNodeTypeDefReader.java:162)\n        at o.a.j.core.journal.AbstractRecord.readNodeTypeDef(AbstractRecord.java:248)\n        ... 6 more\nCaused by: javax.jcr.NamespaceException: No URI for pefix '' declared.\n        at o.a.j.spi.commons.namespace.NamespaceMapping.getURI(NamespaceMapping.java:74)\n        at o.a.j.spi.commons.conversion.NameParser.parse(NameParser.java:116)\n        at o.a.j.spi.commons.conversion.ParsingNameResolver.getQName(ParsingNameResolver.java:62)\n        at o.a.j.spi.commons.conversion.DefaultNamePathResolver.getQName(DefaultNamePathResolver.java:61)\n        at o.a.j.core.nodetype.compact.CompactNodeTypeDefReader.toQName(CompactNodeTypeDefReader.java:646)\n        ... 11 more\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2410",
        "summary": "ChainedTermEnum omits initial terms",
        "description": "This is a regression caused by JCR-2393.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3062",
        "summary": "Move FilterIterator and SizedIterator from package flat to package iterator",
        "description": "I suggest to move said classes from package org.apache.jackrabbit.commons.flat to package org.apache.jackrabbit.commons.iterator. ",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-625",
        "summary": "Memory is not freed up when jackrabbit-server war is redeployed in tomcat",
        "description": "This bug was introduced with the new CacheManager feature. See JCR-619.\n\nThe CacheManager starts a new background thread which optimizes memory distribution every second accross the various caches. When a jackrabbit repository is shutdown, this background thread is still running and prevents the GC from collecting the classloader when jackrabbit is deployed in a web application.\n\nSteps to reproduce:\n1) build jackrabbit and jcr-server from trunk and deploy into a tomcat\n2) touch the web.xml file of the jcr-server web app (this will force a redeployment)\n\nAfter step 2 two things may happen. Either:\n- The memory consumption increases because the CacheManager thread is not shutdown\nor\n- The CacheManager thread dies unexpectedly with a NullPointerException:\n\nException in thread \"org.apache.jackrabbit.core.state.CacheManager\" java.lang.NullPointerException\n        at org.apache.jackrabbit.core.state.CacheManager.run(CacheManager.java:90)\n        at java.lang.Thread.run(Unknown Source)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-895",
        "summary": "Registering node type names with spaces fails in clustered environment",
        "description": "Registering a node type name that contains at least one space in a clustered environment will cause a JournalException in cluster nodes trying to read that change back from the journal. The stack trace observed is:\n\nJournalException: Parse error while reading node type definition.\n       at AbstractRecord.readNodeTypeDef(AbstractRecord.java:245)\n       ...\nCaused by: ParseException: Missing '[' delimiter for beginning of node type name ((internal), line 47)\n       at Lexer.fail(Lexer.java:148)\n       ...\n\n(package names and intermediate frames omitted for brevity).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1631",
        "summary": "Replace commons-logging dependency with SLF4J",
        "description": "The poi dependency in jackrabbit-text-extractors brings in a transitive dependency to commons-logging. Since we use SLF4J for all logging, we should exclude the commons-logging dependency and replace it with jcl104-over-slf4j.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-438",
        "summary": "Improve handling for missing text filter dependency",
        "description": "Using a LazyReader in a TextFilter implementation will not always throw a NoClassDefFoundError if a depending jar file is missing.\n\nThe text filter implementations should therefore include a static block that forces an initialization of a depending class.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2834",
        "summary": "Make DefaultSecurityManager the default security manager (instead of SimpleSecurityManager)",
        "description": "JCR-2164 made DefaultSecurityManager the default security manager for test runs. However the repository.xml included in jackrabbit core and the one for cluster tests still refer to the SimpleSecurityManager. For consistency reasons I think it makes sense to change these places to DefaultSecurityManager.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1677",
        "summary": "Allow workspace creation over cluster",
        "description": "When workspace is created on cluster node A and then node added to that workspace, the proper event is sent to the journal, but other cluster nodes are not able to process it because they don't have the workspace.\n\nIt would be nice to have a configuration option for the cluster to create such workspace automatically (instead of just logging an error)",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-66",
        "summary": "refactoring of DavSession acquisition in jcr-server",
        "description": "i'm subclassing WebdavServer, and i want to use my own logic for finding credentials in the request, logging into the repository and instantiating a DavSession.\n\nunfortunately, WebdavServlet.getSession and its friend the inner class DavSessionImpl are declared private. i changed WebdavServlet.getSession to be protected so that i could override it, but even so, i have no access to DavSessionImpl, so for now, i've copied and pasted it as an inner class in my subclass. yuck.\n\nhere's a proposal for making this more extensible:\n\n1) create the interface DavSessionProvider in org.apache.jackrabbit.server with these methods:\n\n  public void acquireSession(WebdavRequest request) throws DavException;\n  public void releaseSession(WebdavRequest request);\n\n2) make JCRWebdavServer implement DavSessionProvider (it already includes the above methods)\n\n3) move WebdavServlet$DavSessionImpl to DavSessionImpl in org.apache.jackrabbit.server.simple\n\n4) create a DavSessionProviderImpl in org.apache.jackrabbit.server.simple implementing DavSessionProvider which returns instances of DavSessionImpl\n\n5) change WebdavServlet to use a DavSessionProvider rather than its own getSession method, and use a DavSessionProviderImpl by default. subclasses can override with setDavSessionProvider().\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1128",
        "summary": "XML import always throws ItemExistsException when trying to overwrite existing nodes",
        "description": "According to the JCR-API, it should be possible to govern the import of XML serialized referenceable nodes in case of UUID collision. Unfortunately, the UUID conflict is handled too late during import, an ItemExistsException is always thrown beforehand due to not allowed same-name-siblings.\n\nSimply try to import a previously exported referenceable node twice, providing either\n\n- ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING or\n- ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING.\n\nThis will fail and result in an ItemExistsException.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2973",
        "summary": "ItemInfoBuilder should not include PropertyInfos in ChildInfos",
        "description": "When building a NodeInfo instance using the ItemInfoBuilder, getChildInfos() returns entries for the PopertyInfos. This is wrong: getChildInfos should only include entries for the child nodes. ",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-2736",
        "summary": "Exception messages in AuthorizableImpl include full tracebacks at warn level.",
        "description": "In a number of places in AuthourizableImpl there are log.warn with tracebacks.\nThis would be fine, however in production with Sling its quite easy to attempt to set a property on the Authorizable and generate the traceback in the logs, which soon fill up. \n\nWe could block all logging from the user manager, but that feels wrong.\nWould it be possible to have the log message at warn level put out a single log line and at debug level put out the full traceback ?",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2705",
        "summary": "Reduce log level in MultiIndex for deleting obsolete index",
        "description": "The MultiIndex class issues a logging message (with info level) that the obsolete index cannot be deleted (quite often).\nAs the segments are deleted later (with a retry) and this \"warning\" can be ignored (http://dev.day.com/kb/content/wiki/kb/Crx/Troubleshooting/UnableToDeleteObsoleteIndex.html ), it would be nice to reduce the logging level to debug. People, who are maintaining projects, are not aware of Jackarabbit details and are sometimes scared about this \"warning\" :-)\n\nThank you in advance!\n\nKind regards\nSergiy",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-898",
        "summary": "Improve excerpt fragments",
        "description": "Improve the excerpt fragments:\n\n- If a fragment starts at the very beginning of a text, the first Word is cut off\n- If a fragment does not start with the beginning of a sentence a '...' should be prepended\n- If matching terms in a fragment are within range of 75 characters the fragment is extended too far and may produce a larger fragment than requested",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2238",
        "summary": "Binary throws NullPointerException ",
        "description": "Precondition: repository with datastore disabled!\n\nSteps to reproduce:\n\n1) create binary from stream\n2) set binary on property\n3) dispose binary\n4) get binary from property and dispose it immediately\n5) go to 4)\n\nBinary.dispose() will throw a NullPointerException when 4) is executed the second time.\n\nThe exception is not thrown if the property is saved after 2).\n\nSee also attached test.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-120",
        "summary": "Jackrabbit fails to shutdown properly when tomcat is shutting down",
        "description": "This is the same issue already discudded in http://issues.apache.org/jira/browse/JCR-57\n\nThe problem only occurs when Jackrabbit is deployed in the WEB-INF/lib directory of a web application in Tomcat.\nDuring dispose() jackrabbit tries to instantiate a few objects from classes which were not previously loaded by the webapp classloader, but tomcat doesn't allow to load new classes while shutting down.\nThis causes the repository not to be closed properly, and an annoying set of stack traces are written to the log.\n\nIt seems that there are only two classes which are loaded in this situation: org.apache.jackrabbit.core.observation.EventListenerIteratorImpl and org.apache.jackrabbit.core.fs.FileSystemPathUtil. This is the log from the server standard output:\n\norg.apache.catalina.loader.WebappClassLoader loadClass\nINFO: Illegal access: this web application instance has been stopped already.  Could not load org.apache.jackrabbit.core.observation.EventListenerIteratorImpl.  The eventual following stack trace is caused by an error thrown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functional impact.\n[repeaded more times at each shutdown]\n\norg.apache.catalina.loader.WebappClassLoader loadClass\nINFO: Illegal access: this web application instance has been stopped already.  Could not load org.apache.jackrabbit.core.fs.FileSystemPathUtil.  The eventual following stack trace is caused by an error thrown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functional impact.\n\n\nA quick fix is to force preloading of classes normally needed only during shutdown, simply adding a static block to caller classes. The following patch makes tomcat happy, causing classes to be loaded by the webapp classloaded when still allowed  (probably not really elegant, but perfectly working...)\n\n\n\n\nIndex: org/apache/jackrabbit/core/fs/FileSystemResource.java\n===================================================================\n--- src\\java\\org\\apache\\jackrabbit\\core\\fs\\FileSystemResource.java\t(revision 169503)\n+++ src\\java\\org\\apache\\jackrabbit\\core\\fs\\FileSystemResource.java\t(working copy)\n@@ -30,6 +30,11 @@\n \n     protected final String path;\n \n+    static {\n+        // preload FileSystemPathUtil to prevent classloader issues during shutdown\n+        FileSystemPathUtil.class.hashCode();\n+    }\n+\n     /**\n      * Creates a new <code>FileSystemResource</code>\n      *\nIndex: org/apache/jackrabbit/core/observation/ObservationManagerImpl.java\n===================================================================\n--- src\\java\\org\\apache\\jackrabbit\\core\\observation\\ObservationManagerImpl.java\t(revision 169503)\n+++ src\\java\\org\\apache\\jackrabbit\\core\\observation\\ObservationManagerImpl.java\t(working copy)\n@@ -54,6 +54,11 @@\n      */\n     private final ObservationManagerFactory obsMgrFactory;\n \n+    static {\n+        // preload EventListenerIteratorImpl to prevent classloader issues during shutdown\n+        EventListenerIteratorImpl.class.hashCode();\n+    }\n+\n     /**\n      * Creates an <code>ObservationManager</code> instance.\n      *\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-387",
        "summary": "NPE in classes of OJB-PM",
        "description": "NPE occurs while accessing the Id of the parent of the root node which is null.\n\nPatch follows",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-306",
        "summary": "repositoryConfig should use setter for its internal components",
        "description": "From the mailing list (not archived at the moment):\n--- Jukka's reply ---\nI refactored the config classes last year but didn't change the way\nthe config instances are being used by Jackrabbit. In general I think\nthat a IoC approach (use setters to configure the Jackrabbit\ncomponents) would be better than passing config objects around and\nletting the components to instantiate any subcomponents based on the\nconfiguration. This is why I didn't really want to make the config\nconstructors public, otherwise we'd easily up with backwards\ncompatibility issues if we were to change the way configuration is\nhandled.\n---\n\n",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1142",
        "summary": "ocm fails with NPE when a ClassDescriptor isn't found",
        "description": "ObjectConverterImpl#getObject(Session session, Class clazz, String path) should validate whether there's a suitable mapping in order to throw a more descriptive exception as ObjectConverterImpl#getObject(Session session, String path) does.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2676",
        "summary": "FileDataStore should check for lastModified error result",
        "description": "According to javadoc for File.lastModified(), the return value may indicate error: \"...or 0L if the file does not exist or if an I/O error occurs\".\n\nAccordingly, FileDataStore should be checking for this return value, rather than treating it as an actual modification time of \"0\".\n\nPatch to follow.\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2293",
        "summary": "PathNotFoundException but item exists",
        "description": "The following test case (for jcr2spi) throws a PathNotFoundException for an item which exists. It does not throw if the marked line below is commented out. \n\npublic void testBug24687() throws RepositoryException {\n    String parentPath = testNode.getPath();\n    String folderName = \"folder_\" + System.currentTimeMillis();\n    Session session = getHelper().getReadWriteSession();\n\n    Session session2 = getHelper().getReadOnlySession();\n    session2.getItem(parentPath);  // removing this line makes the failure go away\n\n    Node parent = (Node) session.getItem(parentPath);\n    Node toDelete = parent.addNode(folderName, \"nt:folder\");\n    parent.save();\n\n    try {\n        Item item2 = session2.getItem(parentPath + \"/\" + folderName);  // wrongly throws PathNotFoundException\n        assertEquals(parentPath + \"/\" + folderName, item2.getPath());\n    }\n    finally {\n        toDelete.remove();\n        parent.save();\n        assertFalse(parent.hasNode(folderName));\n    }\n}\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-460",
        "summary": "Add RAR META-INF/ra.xml descriptor to be used with JCA1.5",
        "description": "I added ra.xml that lets jackrabbit jca to be used with JCA1.5 like in JBoss",
        "label": "NUG",
        "classified": "TASK",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-175",
        "summary": "Contrib JCR-Server: enable PROPPATCH for simple-davresource",
        "description": "implement as suggested:\n\n- jcr-properties are exposed as webdav properties\n- PROPPATCH is forwarded to javax.jcr.Property.setValue() and Item.remove()",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2298",
        "summary": "NPE in EventStateCollection",
        "description": "When removing a Version with a versionlabel and restoring an other Version from the same containing history within 1 transaction, a NPE occured. When debugging I noticed the method createEventStates was entered with an UUID from a versionLabel. The ChangeLog.get(id) returned null.\n\nCaused by: java.lang.NullPointerException\n\tat org.apache.jackrabbit.core.observation.EventStateCollection.getNodeType(EventStateCollection.java:614)\n\tat org.apache.jackrabbit.core.observation.EventStateCollection.createEventStates(EventStateCollection.java:381)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:697)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:1085)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:163)\n\tat org.apache.jackrabbit.core.version.XAVersionManager.prepare(XAVersionManager.java:509)\n\tat org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:154)\n\tat org.apache.jackrabbit.core.XASessionImpl.prepare(XASessionImpl.java:331)\n\tat org.springmodules.jcr.jackrabbit.support.JackRabbitUserTransaction.commit(JackRabbitUserTransaction.java:100)\n\tat org.springmodules.jcr.jackrabbit.LocalTransactionManager.doCommit(LocalTransactionManager.java:192)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2820",
        "summary": "FineGrainedISMLocking problems",
        "description": "The FineGrainedISMLocking strategy suffers from the same deadlock issue as was reported in JCR-2753 against DefaultISMLocking. Additionally the FineGrainedISMLocking class will also fail to function properly with XA transactions since it uses the current thread instead of the current transaction id to track re-entrancy.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-311",
        "summary": "Unnecessary parameter in NodeTypeRegistry.persistCustomNodeTypeDefs(NodeTypeDefStore store)",
        "description": "The parameter \"store\" is not used within this method. I suggest to delete the parameter to make the code more readable.\n\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "TASK"
    },
    {
        "key": "JCR-2052",
        "summary": "XPath QueryFormat may produce malformed XPath statement",
        "description": "When the query tree contains select properties *and* an order by clause, then the XPath QueryFormat will produce a malformed XPath statement.\n\nE.g.:\n\n//element(*, foo)/(@a|@b) order by @bar\n\nround trips to:\n\n//element(*, foo) order by @bar/(@a|@b)\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2724",
        "summary": "Wrong argument check in BTreeManager constructor",
        "description": "In the constructor of BTreeManager the argument check on maxChildren and minChildren is wrong. Instead of\n\n        if (2 * minChildren < maxChildren) {\n            throw new IllegalArgumentException(\"maxChildren must be at least twice minChildren\");\n        }\n\nit should be\n\n        if (2 * minChildren > maxChildren) {\n            throw new IllegalArgumentException(\"maxChildren must be at least twice minChildren\");\n        }\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-128",
        "summary": "Deleting binary property does not remove 'blob file' in filesystem",
        "description": "when deleting a binary property or its containing node, the 'blob-file' sometime does not get removed.\n\nthe reason for this, is an open FileInputStream, that gets referenced in the property value.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2680",
        "summary": "Cannot move a first-level node",
        "description": "Given /nodeA,\nsession.move(\"/nodeA\", \"/nodeB\")\n\nthrows this exception:\n\njavax.jcr.PathNotFoundException: no ancestor at degree 1: {}\n\tat org.apache.jackrabbit.spi.commons.name.PathFactoryImpl$PathImpl.getAncestor(PathFactoryImpl.java:481)\n\tat org.apache.jackrabbit.core.retention.RetentionRegistryImpl.hasEffectiveRetention(RetentionRegistryImpl.java:291)\n\tat org.apache.jackrabbit.core.ItemValidator.hasRetention(ItemValidator.java:426)\n\tat org.apache.jackrabbit.core.ItemValidator.checkCondition(ItemValidator.java:328)\n\tat org.apache.jackrabbit.core.ItemValidator.checkRemove(ItemValidator.java:281)\n\tat org.apache.jackrabbit.core.SessionImpl.move(SessionImpl.java:1075)\n\tat org.apache.jackrabbit.core.MoveAtRootTest.testMoveAtRoot(MoveAtRootTest.java:54)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat org.apache.jackrabbit.test.AbstractJCRTest.run(AbstractJCRTest.java:456)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2128",
        "summary": "Adding DerbyDataStore to handle proper close of the embedded database",
        "description": "When using embedded Derby in conjunction with DbDataStore, the Derby database is never shutdown, as it requires special code to be executed (creating a Connection with \";shutdown=true\")\nWe may provide a DerbyDataStore extending standard DbDataStore for handling that.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2269",
        "summary": "Possible concurrency bug with Workspace.copy() ",
        "description": "Hi,\n\nEnclosed below is a test case that can be used to reproduce a\nconcurrency bug. This test case uses two con-current threads to\nexecute Workspace.copy() to copy a node to same destination. The\nparent node has set its allowSameNameSiblings to false. According to\nthe javadoc of Workspace.copy(String srcAbsPath, String destAbsPath) :\n\"This method copies the node at srcAbsPath to the new location at\ndestAbsPath. If successful, the change is persisted immediately, there\nis no need to call save.\".  \"An ItemExistException is thrown if a\nproperty already exists at destAbsPath or a node already exist there,\nand same name siblings are not allowed. \"\n\nHowever in reality this is not the case.  The test case can end up\nwith two child nodes with same names. Please note, not every run can\nreproduce the problem, but generally I can get the problem within 3 to\n10 iterations. I also got an InvalidItemStateException once (only\nonce).  Can someone kindly help to confirm if this is a bug in\nJackrabbit or maybe I am using JackRabbit in a wrong way? The test\ncase has been tested on Jackrabbit 1.6 branch\n(http://svn.apache.org/repos/asf/jackrabbit/tags/1.6.0), Windows\nVista, JDK 1.5.0_14.\n\nThe test case is also attached for your convenience.\n\nThanks,\nJervis Liu\n\npackage org.apache.jackrabbit.core;\n\nimport org.apache.jackrabbit.test.AbstractJCRTest;\nimport javax.jcr.ItemExistsException;\nimport javax.jcr.Node;\nimport javax.jcr.Session;\nimport javax.jcr.Value;\nimport javax.jcr.NodeIterator;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport javax.jcr.nodetype.NodeType;\n\nimport org.apache.jackrabbit.test.NotExecutableException;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.nodetype.NodeTypeManager;\n\n\npublic class ConcurrentCopyTest extends AbstractJCRTest {\n\n    private static final int NUM_ITERATIONS = 40;\n    private static final int NUM_SESSIONS = 2;\n\n    String sourcePath;\n    String destPath;\n\n    public void testConcurrentCopy() throws Exception {\n        for (int n = 0; n < NUM_ITERATIONS; n++) {\n            System.out.println(\"---Iteration---- \" + n);\n\n            // clean up testRoot first\n            if (testRootNode.hasNode(\"ConcurrentCopyTestNode\")) {\n                Node testNode = testRootNode.getNode(\"ConcurrentCopyTestNode\");\n                testNode.remove();\n                testRootNode.save();\n                System.out.println(\"---old node removed---\");\n            }\n\n            // create a parent node where allowSameNameSiblings is set to false\n            Node snsfNode = testRootNode.addNode(\"ConcurrentCopyTestNode\",\n                    \"nt:folder\");\n            testRootNode.save();\n            sourcePath = snsfNode.getPath();\n            destPath = sourcePath + \"/\" + \"CopiedFromConcurrentCopyTestNode\";\n            System.out.println(\"---sourcePath-----------------\" + sourcePath);\n            System.out.println(\"---destPath-----------------\" + destPath);\n\n            // firstly we verify it works with single thread.\n            Session rootSession = helper.getSuperuserSession();\n            rootSession.getWorkspace().copy(sourcePath, destPath + \"test\");\n\n            // copy again to same destPath, expect an ItemExistsException\n            try {\n                rootSession.getWorkspace().copy(sourcePath, destPath + \"test\");\n                fail(\"Node exists below '\" + destPath + \"'. Test should fail.\");\n            } catch (ItemExistsException e) {\n            }\n\n            Thread[] threads = new Thread[NUM_SESSIONS];\n            for (int i = 0; i < threads.length; i++) {\n                // create new session\n                Session session = helper.getSuperuserSession();\n                TestSession ts = new TestSession(\"s\" + i, session);\n                Thread t = new Thread(ts);\n                t.setName((NUM_ITERATIONS - n) + \"-s\" + i);\n                t.start();\n                log.println(\"Thread#\" + i + \" started\");\n                threads[i] = t;\n                // Thread.yield();\n                // Thread.sleep(100);\n            }\n            for (int i = 0; i < threads.length; i++) {\n                threads[i].join();\n            }\n\n            NodeIterator results = testRootNode.getNode(\n                    \"ConcurrentCopyTestNode\").getNodes(\n                    \"CopiedFromConcurrentCopyTestNode\");\n            while (results.hasNext()) {\n                Node node = results.nextNode();\n                System.out.println(\"--result node- \" + node.getName());\n            }\n\n            assertEquals(1, results.getSize());\n        }\n    }\n\n    // --------------------------------------------------------< inner classes >\n    class TestSession implements Runnable {\n\n        Session session;\n        String identity;\n        Random r;\n\n        TestSession(String identity, Session s) {\n            session = s;\n            this.identity = identity;\n            r = new Random();\n        }\n\n        private void randomSleep() {\n            long l = r.nextInt(90) + 20;\n            try {\n                Thread.sleep(l);\n            } catch (InterruptedException ie) {\n            }\n        }\n\n        public void run() {\n\n            log.println(\"started.\");\n            String state = \"\";\n            try {\n                this.session.getWorkspace().copy(sourcePath, destPath);\n                session.save();\n                Node newNode =\ntestRootNode.getNode(\"ConcurrentCopyTestNode/CopiedFromConcurrentCopyTestNode\");\n                System.out.println(\"--Added node- \" + newNode.getName());\n\n                session.save();\n                randomSleep();\n            } catch (Exception e) {\n                log.println(\"Exception while \" + state + \": \" + e.getMessage());\n                e.printStackTrace();\n            } finally {\n                session.logout();\n            }\n\n            log.println(\"ended.\");\n        }\n    }\n\n}\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-958",
        "summary": "Use jackrabbit-jcr-commons in jackrabbit-jcr-rmi",
        "description": "The jackrabbit-jcr-rmi component should leverage the general-purpose classes in jackrabbit-jcr-commons even at the expense of introducing an extra dependency.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-423",
        "summary": "Node.restore() fails for existing non-versioned OPV=Version child nodes",
        "description": "I have a node whose definition has properties and child nodes.  The\ndefinitions of the nodetypes for the node and the child include\nmix:versionable.  The properties definitions have onParentVersion=COPY and\nthe child nodes have onParentVersion=VERSION.  When I create a node with\nchild nodes and checkin and then restore the node, I get a\n\"....VersionException: Restore of root node not allowed\"  This is\noccurring on the restore of the child node.\n\nAccording to the spec:\n\nChild Node\nOn checkin of N, the node VN will get a subnode of type nt:versionedChild\nwith the same name as C. The single property of this node,\njcr:childVersionHistory is a REFERENCE to the version history of C (not to\nC or any actual version of C). This also requires that C itself be\nversionable (otherwise it would not have a version history).\n.\n.\n.\nOn restore of VN, if the workspace currently has an already existing node\ncorresponding to C?s version history and the removeExisting flag of the\nrestore is set to true, then that instance of C becomes the child of the\nrestored N. If the workspace currently has an already existing node\ncorresponding to C?s version history and the removeExisting flag of the\nrestore is set to false then an ItemExistsException is thrown.\n\n\nI'm restoring the node using\n\n   node.restore(version, true);\n\nIs this expected behavior?",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-46",
        "summary": "Provider org.apache.xalan.processor.TransformerFactoryImpl not found",
        "description": "\"maven jar\" fails with the following error message on a fresh Jackrabbit source tree:\n\nBUILD FAILED\nFile...... /home/hukka/tmp/jackrabbit/maven.xml\nElement... ant:xslt\nLine...... 146\nColumn.... 25\nProvider org.apache.xalan.processor.TransformerFactoryImpl not found\nTotal time: 4 seconds\nFinished at: Sun Feb 13 10:09:03 EET 2005\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-168",
        "summary": "Observation events are not triggered for intermediate nodes in version storage",
        "description": "When a new version history is created no observation events are triggered for the intermediate nodes.\n\nE.g. for the VersionHistory d94d4b41-f68e-4586-9e88-96e6790981d8 the following events are triggered (with a node filter applied, property events are not visible):\n\nNode added: /jcr:system/jcr:versionStorage/d9/4d/4b/d94d4b41-f68e-4586-9e88-96e6790981d8\nNode added: /jcr:system/jcr:versionStorage/d9/4d/4b/d94d4b41-f68e-4586-9e88-96e6790981d8/jcr:versionLabels\nNode added: /jcr:system/jcr:versionStorage/d9/4d/4b/d94d4b41-f68e-4586-9e88-96e6790981d8/jcr:rootVersion\nNode added: /jcr:system/jcr:versionStorage/d9/4d/4b/d94d4b41-f68e-4586-9e88-96e6790981d8/jcr:rootVersion/jcr:frozenNode\n\nObservation should also trigger node added events for:\n/jcr:system/jcr:versionStorage/d9\n/jcr:system/jcr:versionStorage/d9/4d\n/jcr:system/jcr:versionStorage/d9/4d/4b",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-337",
        "summary": "Jcr-Server: remove jcr depedency from dav-library",
        "description": "",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-598",
        "summary": "DateValue.equals() relies on Calendar.equals()",
        "description": "JSR170 states regarding Date values:\n\"The text format of dates must follow the following ISO 8601:2000-compliant format\".\n\nWhile DateValue.valueOf(String) and DateValue.getString() both rely on the functionality provided by the org.apache.jackrabbit.util.ISO8601, DateValue.equals() compares the equality of the internal Calendar object (DateValue line 89). This may return false even if the Iso-format of both values are equal.\n\nIn other words: Creating a new DateValue using the ValueFactory from the String representation of an existing DateValue will return an object, that is not equal to the original DateValue. The reason for this is, that the String does not contain all infomation, that is used during Calendar.equals.\n\nregards\nangela\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3184",
        "summary": "extend ConsistencyChecker API to allow adoption of orphaned nodes to a to-be-specified parent node",
        "description": "The optional ConsistencyChecker API on persistence managers allows analyzing and fixing storage inconsistencies. The current fixup code though does not attempt to \"adopt\" orphaned nodes.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1443",
        "summary": "Make JCAManagedConnectionFactory non final, so it can be extended",
        "description": "Hello,\n\nIs there a reason why JCAManagedConnectionFactory is final?\nI need to build my own one and I'd rather reuse some code of yours.\n",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1932",
        "summary": "Session.getAttributes( ) call always returns an empty array",
        "description": "Repository repository = new RMIRemoteRepository(\"//localhost:1099/jackrabbit.repository\");\nSimpleCredentials c = new SimpleCredentials(\"alex\",\"ok\".toCharArray());\nc.setAttribute(\"anAttribute\", \"aValue\");\nSession s = repository.login(c, \"aWorkspace\");\nString[]attr=s.getAttributeNames();\n\narray attr is empty.\naccording to docs it should contains attributes from the SimpleCredentials object.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-520",
        "summary": "Contributed ClassLoader project still uses commons-logging for logging.",
        "description": "As of JCR-215 Jackrabbit core code has been migrated from Log4J to SLF4J. The ClassLoader contribution always used commons-logging. It is about time, to also migrate that project to proper SLF4J.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-202",
        "summary": "Add configuration options for search manager",
        "description": "Right now, if the search manager is active, everything is indexed, even the system branch of a workspace with the versions.\n\ntake parameters / conditions into account whether a node should be indexed:\n- path\n- node type\n- property type\n- property name\n\n\nsee also http://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/3343",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-654",
        "summary": "Some implementations require a save() after a mixin has been assigned",
        "description": "Some test cases do not call save() after a mixin has been added.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-285",
        "summary": "Line-separator differences cause PredefinedNodeTypeTest to fail on different operating systems.",
        "description": "In testPredefinedNodeType(), the test reads in a test file from the file system and then performs a string comparison, which may fail due to line-separator differences:\n\n    private void testPredefinedNodeType(String name)\n            throws NotExecutableException {\n        try {\n            StringBuffer spec = new StringBuffer();\n            String resource =\n                \"org/apache/jackrabbit/test/api/nodetype/spec/\"\n                + name.replace(':', '-') + \".txt\";\n            Reader reader = new InputStreamReader(\n                    getClass().getClassLoader().getResourceAsStream(resource));\n            for (int ch = reader.read(); ch != -1; ch = reader.read()) {\n                spec.append((char) ch);\n            }\n\n            NodeType type = manager.getNodeType(name);\n\n            assertEquals(\n                    \"Predefined node type \" + name,\n                    spec.toString(),\n                    getNodeTypeSpec(type));\n...\n\nThe above works when the file being read in has line-separators that match the operating system the test is being run on.  However, if there is a mismatch, the string comparison will fail.\n\nThe fix is to replace line-separators in both strings being compared:\n\nHelper method to replace line separators\n\n    /** Standardize line separators around \"\\n\". */\n    public String replaceLineSeparators(String stringValue) {\n        // Replace \"\\r\\n\" (Windows format) with \"\\n\" (Unix format) \n        stringValue = stringValue.replaceAll(\"\\r\\n\", \"\\n\");\n        // Replace \"\\r\" (Mac format) with \"\\n\" (Unix format)\n        stringValue = stringValue.replaceAll(\"\\r\", \"\\n\");\n        \n        return stringValue;\n    }\n    \nUpdated test method:\n\n    private void testPredefinedNodeType(String name)\n            throws NotExecutableException {\n        try {\n            StringBuffer spec = new StringBuffer();\n            String resource =\n                \"org/apache/jackrabbit/test/api/nodetype/spec/\"\n                + name.replace(':', '-') + \".txt\";\n            Reader reader = new InputStreamReader(\n                    getClass().getClassLoader().getResourceAsStream(resource));\n            for (int ch = reader.read(); ch != -1; ch = reader.read()) {\n                spec.append((char) ch);\n            }\n\n            NodeType type = manager.getNodeType(name);\n            \n            String nodeTypeSpecValue = replaceLineSeparators(getNodeTypeSpec(type));\n            String specValue = replaceLineSeparators(spec.toString());\n            \n            assertEquals(\n                    \"Predefined node type \" + name,\n                    specValue,\n                    nodeTypeSpecValue);\n...",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1472",
        "summary": "extend security config -> repository-1.5.dtd",
        "description": "along with issue #JCR-1171 i'd like to extend the configuration. \n\nthis requires a new version (repository-1.5.dtd) of the repository dtd to be present in jackrabbit-site/src/site/resources/dtd in order to have the new versions of repository.xml work properly.\n\nsee attached diff that shows the difference to the most recent repository-1.4.dtd\n\nif nobody objects i would put the proposed repository-1.5.dtd to the site.\nonce this is done i can properly adjust the repository.xml files (uncommenting the DOCTYPE tag) and start committing the new security functionality.\n\nangela",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2972",
        "summary": "Allow name to be set in PropertyInfoBuilder and NodeInfoBuilder",
        "description": "Currently the property name for new Properties and Nodes can only be set when their builder is created. I suggest to add methods for setting the names by themselves. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-395",
        "summary": "Using transactions leads to memory leak",
        "description": "There is global static map in XASessionImpl class which stores all Xids and TransactionContexts\n\n    /**\n     * Global transactions\n     */\n    private static final Map txGlobal = new HashMap();\n\nIt looks like this map is never cleared, even after end of transaction. It leads to memory leak because TransactionContexts and all nested objects (including XASessionImpl) are still referenced and couldn't be freed.\n\nProposed solution : Is it posssible to add just single line which will remove TransactionContext from static map at the end of transaction ?\n\n      if (flags == TMSUCCESS || flags == TMFAIL) {\n            associate(null);\n-->       txGlobal.remove(xid);\n        } else  if (flags == TMSUSPEND) {\n            associate(null);\n        } else {\n            throw new XAException(XAException.XAER_INVAL);\n        }\n\nIf this is not acceptable, then we have to unreference TransactionContext in another way.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-862",
        "summary": "unsynchronized access on 'itemCache' map in ItemManager ",
        "description": "the access 'itemCache' map in ItemManager is mostly synchronized by not via the ItemStateListener methods:\n[...]\n    public void stateCreated(ItemState created) {\n        ItemImpl item = retrieveItem(created.getId());\n        if (item != null) {\n            item.stateCreated(created);\n        }\n    }\n[...]\n    private ItemImpl retrieveItem(ItemId id) {\n        return (ItemImpl) itemCache.get(id);\n    }\n[...]\n\nthis can result in a corruption of a map (eg subsequent accesses may result in a endless loop).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2727",
        "summary": "Add user manager performance tests ",
        "description": "We should add some performance tests for validating JCR-2710 and related. That is we should measure performance for creating users and groups and adding/removing users to/from groups. This should be done for both repository configurations: one with the old content model (group membership in property) and one with the new content model introduced with JCR-2710 (group membership in b-tree like node structure). ",
        "label": "NUG",
        "classified": "TEST",
        "type": "RFE"
    },
    {
        "key": "JCR-3220",
        "summary": "simple webdav server does not support lock timeouts",
        "description": "The \"simple\" WebDAV server still does not support lock timeouts (HTTP trace shows MS word requests 3600s timeout but gets infinity).",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-1879",
        "summary": "\"Directory was previously created with a different LockFactory\" when open, close, delete a repository in a loop",
        "description": "Opening a TransientRepository in a loop throws the exception \"Directory was previously created with a different LockFactory instance\".\n\nTest case:\n\nfor (int i = 0; i < 3; i++) {\n\tFileUtils.deleteDirectory(new File(\"repository\"));\n\tRepository rep = new TransientRepository();\n\tSession session = rep.login(new SimpleCredentials(\"\", new char[0]));\n\tsession.logout();\n}\n\nThe problem seems to be that org.apache.lucene.store.FSDirectory.DIRECTORIES is not cleared (FSDirectory.close() is not called?).\n\nStack trace:\n\nException in thread \"main\" javax.jcr.RepositoryException: Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it: Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it: Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it\n\tat org.apache.jackrabbit.core.SearchManager.initializeQueryHandler(SearchManager.java:555)\n\tat org.apache.jackrabbit.core.SearchManager.<init>(SearchManager.java:239)\n\tat org.apache.jackrabbit.core.RepositoryImpl.getSystemSearchManager(RepositoryImpl.java:688)\n\tat org.apache.jackrabbit.core.RepositoryImpl.access$3(RepositoryImpl.java:681)\n\tat org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getSearchManager(RepositoryImpl.java:1780)\n\tat org.apache.jackrabbit.core.RepositoryImpl.initWorkspace(RepositoryImpl.java:667)\n\tat org.apache.jackrabbit.core.RepositoryImpl.initStartupWorkspaces(RepositoryImpl.java:480)\n\tat org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:321)\n\tat org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:618)\n\tat org.apache.jackrabbit.core.TransientRepository$2.getRepository(TransientRepository.java:241)\n\tat org.apache.jackrabbit.core.TransientRepository.startRepository(TransientRepository.java:261)\nCaused by: java.io.IOException: Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it\n\tat org.apache.lucene.store.FSDirectory.getDirectory(FSDirectory.java:192)\n\tat org.apache.jackrabbit.core.query.lucene.directory.FSDirectoryManager.getDirectory(FSDirectoryManager.java:64)\n\tat org.apache.jackrabbit.core.query.lucene.MultiIndex.<init>(MultiIndex.java:227)\n\tat org.apache.jackrabbit.core.query.lucene.SearchIndex.doInit(SearchIndex.java:477)\n\tat org.apache.jackrabbit.core.query.AbstractQueryHandler.init(AbstractQueryHandler.java:59)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2532",
        "summary": "spi2davex: session-scoped lock tokens not included in if-header",
        "description": "detected while running API lock tests.\norg.apache.jackrabbit.test.api.lock.DeepLockTest#testParentChildDeepLock failed though it used to work with spi2dav.\n\nfix is simple: SessionInfoImpl.getAllLockTokens must be used to populate the if-header as it is done in spi2dav.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-891",
        "summary": "Add import-export tool",
        "description": "We at <GX> creative online development would like to contribute our command-line import-export tool to the Apache Jackrabbit project. This tool is capable of exporting and importing all kinds of repository content (including custom nodetypes and namespace mappings) in a persistence-layer independent way. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1334",
        "summary": "Deadlock due different Thread access while prepare and commit in same Transaction",
        "description": "Since we have configured a j2c resource adapter any modification to the repository ends\nwith a deadlock.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2909",
        "summary": "EntryCollectorTest failure on certain Java versions",
        "description": "The testCache test case in the EntryCollectorTest class uses array comparison for a set of permissions, which causes test failures on certain Java versions where the ordering of permissions is different than expected.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2881",
        "summary": "Deadlock on version operations in a clustered environment",
        "description": "Version operations in a cluster may end up in a deadlock: a write operation in the version store will acquire the version manager's write lock (N1.VW) and subsequently the cluster journal's write lock (N1.JW). Another cluster node's write operation in some workspace will acquire the journal's write lock (N2.JW) and first process the journal record log: if some of these changes concern the version store, the version manager's read lock (N2.VR) has to be acquired in order to deliver them. If the first cluster node reaches N1.VW, and the second reaches N2.JW, we have a deadlock. The same scenario takes place when the second cluster node synchronizes to the latest journal changes and reaches N2.JR, when the first cluster node is in N1.VW.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-638",
        "summary": "Support lower-/upper-case functions",
        "description": "The query languages should support lower- and upper-case functions when matching property values to string literals.\n\nExample 1: find all nodes with a string property foo with a lower-cased value that equals 'bar':\n\nIn XPath that's:\n\n//*[fn:lower-case(@foo) = 'bar']\n\nAn in SQL:\nSELECT * FROM nt:base WHERE LOWER(foo) = 'bar'\n\nExample 2: find all nodes with a string property foo with an upper-cased value that matches '%JCR%'\n\nXPath: //*[jcr:like(fn:upper-case(@foo), '%JCR%')]\n\nSQL: SELECT * FROM nt:base WHERE UPPPER(foo) LIKE '%JCR%'",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3048",
        "summary": "Upgrade to latest Apache parent POM",
        "description": "We're quite a bit behind the latest and greatest of the Apache parent POMs (org.apache:apache), mostly since we're inheriting it through the now mostly unused org.apache.jackrabbit:parent POM.\n\nI'd like to move things back from the o.a.j:parent POM to the jackrabbit-parent POM that's located inside trunk. This will allow us to upgrade to the latest Apache parent POM without the trouble of an extra release of the o.a.j:parent POM.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2719",
        "summary": "Incorrect outer join TCK tests",
        "description": "The TCK test cases for outer joins seem to be incorrect. More specifically the expected result sets for the testRightOuterJoin1() and testLeftOuterJoin2() test cases in EquiJoinConditionTest are invalid, as shown below:\n\n* testRightOuterJoin1() result set {{null, n1}, {n1, n2}, {n2, n2}} --> The n1 node does not have the propertyName2 property set, so the first tuple can never occur regardless of the join type. And since n2 already matches existing nodes, even {null, n2} can not be included in the result set. The correct result set for this query seems to be {{n1, n2}, {n2, n2}}.\n\n* testLeftOuterJoin2() result set {{n1, null}, {n2, n1}, {n2, n2}} --> Same as above, a tuple with n1 as the leftmost node is not possible. The correct result set would be {{n2, n1}, {n2, n2}}.\n\nUnfortunately the correct result sets here don't actually exercise the outer join functionality, i.e. none of the nodes in the returned tuples are null. We'll need to modify the test case setup to fix this.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1063",
        "summary": "Disable consistency check per default",
        "description": "There should be a way to disable the consistency check entirely. Currently a consistency check is performed on startup whenever the redo log is applied. For large workspaces this may take a long time and should only be performed when 'requested'.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2247",
        "summary": "Remove duplicate code in QValueFactoryImpl (spi2dav)",
        "description": "QValueFactoryImpl in spi2dav contains code duplicated from spi-commons QValueFactoryImpl. Once JCR-2245 has been applied the spi2dav variant can extend from the factory in spi-commons and we can simply the first.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1176",
        "summary": "MemoryFileSystem is different from other FileSystems",
        "description": "JCR-1175 uncovered inconsistencies in how the deleteFolder() and list() methods are implemented. The MemoryFileSystem class acts differently from the LocalFileSystem and DatabaseFileSystem classes. MemoryFileSystem and the related incorrect test cases should be fixed.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-3110",
        "summary": "QNodeTypeDefinitionImpl.getSerializablePropertyDefs() might return non serializable property definitions ",
        "description": "QNodeTypeDefinitionImpl.getSerializablePropertyDefs() returns a set-version of the passed in parameter, irrespective of whether the property defs are serializable or not.\n\nSee http://markmail.org/thread/65ngqvyxnu4nn3su",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-81",
        "summary": "Implement anonymous login with credentials",
        "description": "Jackrabbit currently implements anonymous login by detecting a null credentials argument on login. This is actually not compliant to the specification.\n\n<spec>\nIf credentials is null, it is assumed that authentication is handled by a mechanism external to the repository itself (for example, through the JAAS framework) and that the repository implementation exists within a context (for example, an application server) that allows it to handle authorization of the request for access to the specified workspace.\n</spec>\n\nJackrabbit should rather support anonymous login with a defined credential, either some subclass of SimpleCredentials or a predefined / known userId that has read-only access.",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-2344",
        "summary": "ClassCastException org.apache.xerces.parsers.XIncludeAwareParserConfiguration cannot be cast to org.apache.xerces.xni.parser.XMLParserConfiguration when deploying in JBoss 5.1",
        "description": "I tried to follow the steps given on http://wiki.apache.org/jackrabbit/JackrabbitOnJBoss\nTo get over an exception I had to use jcr-2.0.jar (instead of jcr-1.0.jar)\nThe following exception happens when the jboss server is started.\n=======================================================================\n\n2009-10-02 11:49:05,630 ERROR [org.jboss.web.tomcat.service.deployers.JBossContextConfig] (main) XML error parsing: context.xml\norg.jboss.xb.binding.JBossXBRuntimeException: Failed to create a new SAX parser\n\tat org.jboss.xb.binding.UnmarshallerFactory$UnmarshallerFactoryImpl.newUnmarshaller(UnmarshallerFactory.java:100)\n\tat org.jboss.web.tomcat.service.deployers.JBossContextConfig.processContextConfig(JBossContextConfig.java:549)\n\tat org.jboss.web.tomcat.service.deployers.JBossContextConfig.init(JBossContextConfig.java:536)\n\tat org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:279)\n\tat org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)\n\tat org.apache.catalina.core.StandardContext.init(StandardContext.java:5436)\n\tat org.apache.catalina.core.StandardContext.start(StandardContext.java:4148)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeployInternal(TomcatDeployment.java:310)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeploy(TomcatDeployment.java:142)\n\tat org.jboss.web.deployers.AbstractWarDeployment.start(AbstractWarDeployment.java:461)\n\tat org.jboss.web.deployers.WebModule.startModule(WebModule.java:118)\n\tat org.jboss.web.deployers.WebModule.start(WebModule.java:97)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157)\n\tat org.jboss.mx.server.Invocation.dispatch(Invocation.java:96)\n\tat org.jboss.mx.server.Invocation.invoke(Invocation.java:88)\n\tat org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:264)\n\tat org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:668)\n\tat org.jboss.system.microcontainer.ServiceProxy.invoke(ServiceProxy.java:206)\n\tat $Proxy38.start(Unknown Source)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:42)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:37)\n\tat org.jboss.dependency.plugins.action.SimpleControllerContextAction.simpleInstallAction(SimpleControllerContextAction.java:62)\n\tat org.jboss.dependency.plugins.action.AccessControllerContextAction.install(AccessControllerContextAction.java:71)\n\tat org.jboss.dependency.plugins.AbstractControllerContextActions.install(AbstractControllerContextActions.java:51)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.system.microcontainer.ServiceControllerContext.install(ServiceControllerContext.java:286)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.ServiceController.doChange(ServiceController.java:688)\n\tat org.jboss.system.ServiceController.start(ServiceController.java:460)\n\tat org.jboss.system.deployers.ServiceDeployer.start(ServiceDeployer.java:163)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:99)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:46)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractSimpleRealDeployer.internalDeploy(AbstractSimpleRealDeployer.java:62)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractRealDeployer.deploy(AbstractRealDeployer.java:50)\n\tat org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:171)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1439)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1157)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1178)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1098)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:781)\n\tat org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:702)\n\tat org.jboss.system.server.profileservice.repository.MainDeployerAdapter.process(MainDeployerAdapter.java:117)\n\tat org.jboss.system.server.profileservice.repository.ProfileDeployAction.install(ProfileDeployAction.java:70)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileAction.install(AbstractProfileAction.java:53)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.install(AbstractProfileService.java:361)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.activateProfile(AbstractProfileService.java:306)\n\tat org.jboss.system.server.profileservice.ProfileServiceBootstrap.start(ProfileServiceBootstrap.java:271)\n\tat org.jboss.bootstrap.AbstractServerImpl.start(AbstractServerImpl.java:461)\n\tat org.jboss.Main.boot(Main.java:221)\n\tat org.jboss.Main$1.run(Main.java:556)\n\tat java.lang.Thread.run(Thread.java:619)\nCaused by: org.jboss.xb.binding.JBossXBException: Failed to create a new SAX parser\n\tat org.jboss.xb.binding.parser.sax.SaxJBossXBParser.<init>(SaxJBossXBParser.java:97)\n\tat org.jboss.xb.binding.UnmarshallerImpl.<init>(UnmarshallerImpl.java:56)\n\tat org.jboss.xb.binding.UnmarshallerFactory$UnmarshallerFactoryImpl.newUnmarshaller(UnmarshallerFactory.java:96)\n\t... 73 more\nCaused by: java.lang.ClassCastException: org.apache.xerces.parsers.XIncludeAwareParserConfiguration cannot be cast to org.apache.xerces.xni.parser.XMLParserConfiguration\n\tat org.apache.xerces.parsers.SAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.parsers.SAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserImpl.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserFactoryImpl.newSAXParser(Unknown Source)\n\tat org.jboss.xb.binding.parser.sax.SaxJBossXBParser.<init>(SaxJBossXBParser.java:92)\n\t... 75 more\n2009-10-02 11:49:05,645 ERROR [org.jboss.web.tomcat.service.deployers.JBossContextConfig] (main) XML error parsing: jboss.web/localhost/context.xml.default\norg.jboss.xb.binding.JBossXBRuntimeException: Failed to create a new SAX parser\n\tat org.jboss.xb.binding.UnmarshallerFactory$UnmarshallerFactoryImpl.newUnmarshaller(UnmarshallerFactory.java:100)\n\tat org.jboss.web.tomcat.service.deployers.JBossContextConfig.processContextConfig(JBossContextConfig.java:549)\n\tat org.jboss.web.tomcat.service.deployers.JBossContextConfig.init(JBossContextConfig.java:537)\n\tat org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:279)\n\tat org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)\n\tat org.apache.catalina.core.StandardContext.init(StandardContext.java:5436)\n\tat org.apache.catalina.core.StandardContext.start(StandardContext.java:4148)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeployInternal(TomcatDeployment.java:310)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeploy(TomcatDeployment.java:142)\n\tat org.jboss.web.deployers.AbstractWarDeployment.start(AbstractWarDeployment.java:461)\n\tat org.jboss.web.deployers.WebModule.startModule(WebModule.java:118)\n\tat org.jboss.web.deployers.WebModule.start(WebModule.java:97)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157)\n\tat org.jboss.mx.server.Invocation.dispatch(Invocation.java:96)\n\tat org.jboss.mx.server.Invocation.invoke(Invocation.java:88)\n\tat org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:264)\n\tat org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:668)\n\tat org.jboss.system.microcontainer.ServiceProxy.invoke(ServiceProxy.java:206)\n\tat $Proxy38.start(Unknown Source)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:42)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:37)\n\tat org.jboss.dependency.plugins.action.SimpleControllerContextAction.simpleInstallAction(SimpleControllerContextAction.java:62)\n\tat org.jboss.dependency.plugins.action.AccessControllerContextAction.install(AccessControllerContextAction.java:71)\n\tat org.jboss.dependency.plugins.AbstractControllerContextActions.install(AbstractControllerContextActions.java:51)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.system.microcontainer.ServiceControllerContext.install(ServiceControllerContext.java:286)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.ServiceController.doChange(ServiceController.java:688)\n\tat org.jboss.system.ServiceController.start(ServiceController.java:460)\n\tat org.jboss.system.deployers.ServiceDeployer.start(ServiceDeployer.java:163)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:99)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:46)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractSimpleRealDeployer.internalDeploy(AbstractSimpleRealDeployer.java:62)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractRealDeployer.deploy(AbstractRealDeployer.java:50)\n\tat org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:171)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1439)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1157)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1178)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1098)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:781)\n\tat org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:702)\n\tat org.jboss.system.server.profileservice.repository.MainDeployerAdapter.process(MainDeployerAdapter.java:117)\n\tat org.jboss.system.server.profileservice.repository.ProfileDeployAction.install(ProfileDeployAction.java:70)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileAction.install(AbstractProfileAction.java:53)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.install(AbstractProfileService.java:361)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.activateProfile(AbstractProfileService.java:306)\n\tat org.jboss.system.server.profileservice.ProfileServiceBootstrap.start(ProfileServiceBootstrap.java:271)\n\tat org.jboss.bootstrap.AbstractServerImpl.start(AbstractServerImpl.java:461)\n\tat org.jboss.Main.boot(Main.java:221)\n\tat org.jboss.Main$1.run(Main.java:556)\n\tat java.lang.Thread.run(Thread.java:619)\nCaused by: org.jboss.xb.binding.JBossXBException: Failed to create a new SAX parser\n\tat org.jboss.xb.binding.parser.sax.SaxJBossXBParser.<init>(SaxJBossXBParser.java:97)\n\tat org.jboss.xb.binding.UnmarshallerImpl.<init>(UnmarshallerImpl.java:56)\n\tat org.jboss.xb.binding.UnmarshallerFactory$UnmarshallerFactoryImpl.newUnmarshaller(UnmarshallerFactory.java:96)\n\t... 73 more\nCaused by: java.lang.ClassCastException: org.apache.xerces.parsers.XIncludeAwareParserConfiguration cannot be cast to org.apache.xerces.xni.parser.XMLParserConfiguration\n\tat org.apache.xerces.parsers.SAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.parsers.SAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserImpl.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserFactoryImpl.newSAXParser(Unknown Source)\n\tat org.jboss.xb.binding.parser.sax.SaxJBossXBParser.<init>(SaxJBossXBParser.java:92)\n\t... 75 more\n2009-10-02 11:49:05,645 ERROR [org.jboss.web.tomcat.service.deployers.JBossContextConfig] (main) XML error parsing: WEB-INF/context.xml\norg.jboss.xb.binding.JBossXBRuntimeException: Failed to create a new SAX parser\n\tat org.jboss.xb.binding.UnmarshallerFactory$UnmarshallerFactoryImpl.newUnmarshaller(UnmarshallerFactory.java:100)\n\tat org.jboss.web.tomcat.service.deployers.JBossContextConfig.processContextConfig(JBossContextConfig.java:549)\n\tat org.jboss.web.tomcat.service.deployers.JBossContextConfig.init(JBossContextConfig.java:540)\n\tat org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:279)\n\tat org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)\n\tat org.apache.catalina.core.StandardContext.init(StandardContext.java:5436)\n\tat org.apache.catalina.core.StandardContext.start(StandardContext.java:4148)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeployInternal(TomcatDeployment.java:310)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeploy(TomcatDeployment.java:142)\n\tat org.jboss.web.deployers.AbstractWarDeployment.start(AbstractWarDeployment.java:461)\n\tat org.jboss.web.deployers.WebModule.startModule(WebModule.java:118)\n\tat org.jboss.web.deployers.WebModule.start(WebModule.java:97)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157)\n\tat org.jboss.mx.server.Invocation.dispatch(Invocation.java:96)\n\tat org.jboss.mx.server.Invocation.invoke(Invocation.java:88)\n\tat org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:264)\n\tat org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:668)\n\tat org.jboss.system.microcontainer.ServiceProxy.invoke(ServiceProxy.java:206)\n\tat $Proxy38.start(Unknown Source)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:42)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:37)\n\tat org.jboss.dependency.plugins.action.SimpleControllerContextAction.simpleInstallAction(SimpleControllerContextAction.java:62)\n\tat org.jboss.dependency.plugins.action.AccessControllerContextAction.install(AccessControllerContextAction.java:71)\n\tat org.jboss.dependency.plugins.AbstractControllerContextActions.install(AbstractControllerContextActions.java:51)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.system.microcontainer.ServiceControllerContext.install(ServiceControllerContext.java:286)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.ServiceController.doChange(ServiceController.java:688)\n\tat org.jboss.system.ServiceController.start(ServiceController.java:460)\n\tat org.jboss.system.deployers.ServiceDeployer.start(ServiceDeployer.java:163)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:99)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:46)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractSimpleRealDeployer.internalDeploy(AbstractSimpleRealDeployer.java:62)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractRealDeployer.deploy(AbstractRealDeployer.java:50)\n\tat org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:171)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1439)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1157)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1178)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1098)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:781)\n\tat org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:702)\n\tat org.jboss.system.server.profileservice.repository.MainDeployerAdapter.process(MainDeployerAdapter.java:117)\n\tat org.jboss.system.server.profileservice.repository.ProfileDeployAction.install(ProfileDeployAction.java:70)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileAction.install(AbstractProfileAction.java:53)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.install(AbstractProfileService.java:361)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.activateProfile(AbstractProfileService.java:306)\n\tat org.jboss.system.server.profileservice.ProfileServiceBootstrap.start(ProfileServiceBootstrap.java:271)\n\tat org.jboss.bootstrap.AbstractServerImpl.start(AbstractServerImpl.java:461)\n\tat org.jboss.Main.boot(Main.java:221)\n\tat org.jboss.Main$1.run(Main.java:556)\n\tat java.lang.Thread.run(Thread.java:619)\nCaused by: org.jboss.xb.binding.JBossXBException: Failed to create a new SAX parser\n\tat org.jboss.xb.binding.parser.sax.SaxJBossXBParser.<init>(SaxJBossXBParser.java:97)\n\tat org.jboss.xb.binding.UnmarshallerImpl.<init>(UnmarshallerImpl.java:56)\n\tat org.jboss.xb.binding.UnmarshallerFactory$UnmarshallerFactoryImpl.newUnmarshaller(UnmarshallerFactory.java:96)\n\t... 73 more\nCaused by: java.lang.ClassCastException: org.apache.xerces.parsers.XIncludeAwareParserConfiguration cannot be cast to org.apache.xerces.xni.parser.XMLParserConfiguration\n\tat org.apache.xerces.parsers.SAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.parsers.SAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserImpl.<init>(Unknown Source)\n\tat org.apache.xerces.jaxp.SAXParserFactoryImpl.newSAXParser(Unknown Source)\n\tat org.jboss.xb.binding.parser.sax.SaxJBossXBParser.<init>(SaxJBossXBParser.java:92)\n\t... 75 more\n2009-10-02 11:49:05,786 ERROR [org.apache.catalina.startup.ContextConfig] (main) Marking this application unavailable due to previous error(s)\n2009-10-02 11:49:05,786 ERROR [org.apache.catalina.core.StandardContext] (main) Context [/jackrabbit-webapp-2.0-alpha9] startup failed due to previous errors\n2009-10-02 11:49:06,473 ERROR [org.jboss.kernel.plugins.dependency.AbstractKernelController] (main) Error installing to Start: name=jboss.web.deployment:war=/jackrabbit-webapp-2.0-alpha9 state=Create mode=Manual requiredState=Installed\norg.jboss.deployers.spi.DeploymentException: URL file:/C:/applications/jboss-5.1.0.GA/server/default/tmp/ahn1p-6tv4p6-g0bacatm-1-g0bageil-9t/jackrabbit-webapp-2.0-alpha9.war/ deployment failed\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeployInternal(TomcatDeployment.java:331)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeploy(TomcatDeployment.java:142)\n\tat org.jboss.web.deployers.AbstractWarDeployment.start(AbstractWarDeployment.java:461)\n\tat org.jboss.web.deployers.WebModule.startModule(WebModule.java:118)\n\tat org.jboss.web.deployers.WebModule.start(WebModule.java:97)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157)\n\tat org.jboss.mx.server.Invocation.dispatch(Invocation.java:96)\n\tat org.jboss.mx.server.Invocation.invoke(Invocation.java:88)\n\tat org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:264)\n\tat org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:668)\n\tat org.jboss.system.microcontainer.ServiceProxy.invoke(ServiceProxy.java:206)\n\tat $Proxy38.start(Unknown Source)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:42)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:37)\n\tat org.jboss.dependency.plugins.action.SimpleControllerContextAction.simpleInstallAction(SimpleControllerContextAction.java:62)\n\tat org.jboss.dependency.plugins.action.AccessControllerContextAction.install(AccessControllerContextAction.java:71)\n\tat org.jboss.dependency.plugins.AbstractControllerContextActions.install(AbstractControllerContextActions.java:51)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.system.microcontainer.ServiceControllerContext.install(ServiceControllerContext.java:286)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.ServiceController.doChange(ServiceController.java:688)\n\tat org.jboss.system.ServiceController.start(ServiceController.java:460)\n\tat org.jboss.system.deployers.ServiceDeployer.start(ServiceDeployer.java:163)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:99)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:46)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractSimpleRealDeployer.internalDeploy(AbstractSimpleRealDeployer.java:62)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractRealDeployer.deploy(AbstractRealDeployer.java:50)\n\tat org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:171)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1439)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1157)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1178)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1098)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:781)\n\tat org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:702)\n\tat org.jboss.system.server.profileservice.repository.MainDeployerAdapter.process(MainDeployerAdapter.java:117)\n\tat org.jboss.system.server.profileservice.repository.ProfileDeployAction.install(ProfileDeployAction.java:70)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileAction.install(AbstractProfileAction.java:53)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.install(AbstractProfileService.java:361)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.activateProfile(AbstractProfileService.java:306)\n\tat org.jboss.system.server.profileservice.ProfileServiceBootstrap.start(ProfileServiceBootstrap.java:271)\n\tat org.jboss.bootstrap.AbstractServerImpl.start(AbstractServerImpl.java:461)\n\tat org.jboss.Main.boot(Main.java:221)\n\tat org.jboss.Main$1.run(Main.java:556)\n\tat java.lang.Thread.run(Thread.java:619)\n2009-10-02 11:49:06,598 ERROR [org.jboss.kernel.plugins.dependency.AbstractKernelController] (main) Error installing to Real: name=vfszip:/C:/applications/jboss-5.1.0.GA/server/default/deploy/jackrabbit-webapp-2.0-alpha9.war/ state=PreReal mode=Manual requiredState=Real\norg.jboss.deployers.spi.DeploymentException: URL file:/C:/applications/jboss-5.1.0.GA/server/default/tmp/ahn1p-6tv4p6-g0bacatm-1-g0bageil-9t/jackrabbit-webapp-2.0-alpha9.war/ deployment failed\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeployInternal(TomcatDeployment.java:331)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeploy(TomcatDeployment.java:142)\n\tat org.jboss.web.deployers.AbstractWarDeployment.start(AbstractWarDeployment.java:461)\n\tat org.jboss.web.deployers.WebModule.startModule(WebModule.java:118)\n\tat org.jboss.web.deployers.WebModule.start(WebModule.java:97)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157)\n\tat org.jboss.mx.server.Invocation.dispatch(Invocation.java:96)\n\tat org.jboss.mx.server.Invocation.invoke(Invocation.java:88)\n\tat org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:264)\n\tat org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:668)\n\tat org.jboss.system.microcontainer.ServiceProxy.invoke(ServiceProxy.java:206)\n\tat $Proxy38.start(Unknown Source)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:42)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:37)\n\tat org.jboss.dependency.plugins.action.SimpleControllerContextAction.simpleInstallAction(SimpleControllerContextAction.java:62)\n\tat org.jboss.dependency.plugins.action.AccessControllerContextAction.install(AccessControllerContextAction.java:71)\n\tat org.jboss.dependency.plugins.AbstractControllerContextActions.install(AbstractControllerContextActions.java:51)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.system.microcontainer.ServiceControllerContext.install(ServiceControllerContext.java:286)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.ServiceController.doChange(ServiceController.java:688)\n\tat org.jboss.system.ServiceController.start(ServiceController.java:460)\n\tat org.jboss.system.deployers.ServiceDeployer.start(ServiceDeployer.java:163)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:99)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:46)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractSimpleRealDeployer.internalDeploy(AbstractSimpleRealDeployer.java:62)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractRealDeployer.deploy(AbstractRealDeployer.java:50)\n\tat org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:171)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1439)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1157)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1178)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1098)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:781)\n\tat org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:702)\n\tat org.jboss.system.server.profileservice.repository.MainDeployerAdapter.process(MainDeployerAdapter.java:117)\n\tat org.jboss.system.server.profileservice.repository.ProfileDeployAction.install(ProfileDeployAction.java:70)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileAction.install(AbstractProfileAction.java:53)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.install(AbstractProfileService.java:361)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1631)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:934)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:984)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:822)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:553)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.activateProfile(AbstractProfileService.java:306)\n\tat org.jboss.system.server.profileservice.ProfileServiceBootstrap.start(ProfileServiceBootstrap.java:271)\n\tat org.jboss.bootstrap.AbstractServerImpl.start(AbstractServerImpl.java:461)\n\tat org.jboss.Main.boot(Main.java:221)\n\tat org.jboss.Main$1.run(Main.java:556)\n\tat java.lang.Thread.run(Thread.java:619)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2262",
        "summary": "o.a.j.webdav.jcr.DavResourceFactoryImpl#createResource creates VersionControlledResource instances regardless of mix:versionable status",
        "description": "DavResourceFactoryImpl#createResource() first calls createResourceForItem() which threats all nodes as version-controlled. \nit then calls isVersionControlled() which indirectly triggers a call to Node#getVersionHistroy(). \ngetVersionHistroy throws a UnsupportedRepositoryException if the node is non-versionable, leading to a DavException further up the call stack.\n\nas a consequence, every request for a non-versionable node leads to unnecessary (and expensive) exception generation which could be avoided by checking the mix:versionable status of a node.\n\n\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1784",
        "summary": "OCM:The UUID of the collection elements changes on update.",
        "description": "On ocm.update transaction, the  Current implementation of DefaultCollectionConverterImpl recreates the colleciton-element nodes if there is no id field specificaiton.  This is completely valid for majority of the cases.  But I came across a case where the colleciton element has a uuid field.  In this case also what is happening with the current implementation is that it drops all the elements from the old collection-elements and recreates the new ones.  The major flip side is that now I am left with brand new UUIDs.  I think we should address the uniqueness characteristics specified through UUID also while mapping colleciton elements.\n\nI have a patch and a TestCase to verify the same.  I have implemented it only for the digester.  If people feel the approach is right I will work out an annotation based testcase as well.  I do not think it is going to fail even with annotations.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2542",
        "summary": "spi2dav: EventFilters not respected",
        "description": "i have the impression that the event filter passed to the event subscription in spi2dav is not (or not properly) respected.\n\nmarcel, is there a specific reason that you always pass the static SubscriptionInfo constant (no node type filter, noLocal false) to the SubscribeMethod\nin spi2dav/RepositoryServiceImpl#createSubscription ?\n\ni guess this is the reason for the failure of\n  testNodeType(org.apache.jackrabbit.test.api.observation.AddEventListenerTest)\n  testNoLocalTrue(org.apache.jackrabbit.test.api.observation.AddEventListenerTest)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3086",
        "summary": "potential infinite loop around InternalVersionImpl.getSuccessors",
        "description": "There's an infinite loop waiting to happen when the underlying persisted version storage is defect:\n\n{noformat}\nat\norg.apache.jackrabbit.core.version.InternalVersionImpl.getSuccessors(InternalVersionImpl.java:148)\n\nat\norg.apache.jackrabbit.core.version.InternalVersionHistoryImpl.init(InternalVersionHistoryImpl.java:165)\n\nat\norg.apache.jackrabbit.core.version.InternalVersionHistoryImpl.reload(InternalVersionHistoryImpl.java:180)\n\nat\norg.apache.jackrabbit.core.version.InternalVersionHistoryImpl.getVersion(InternalVersionHistoryImpl.java:299) \n{noformat}\n\n(line numbers from 2.2)\n\nWhat happens here is that when a version can not be instantiated, reload() is called, which in turn calls init(), which, as part of piece of code labeled \"fix legacy\" will call getSuccessors(), which in turn wants to instantiate versions.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-571",
        "summary": "jackrabbit JCA pom.xml",
        "description": "do not see a way to add attachments, so here it is below inline.\nNote, need to move the src/rar/META-INF/ra.xml to src/main/rar/META-INF/ra.xml (which is the default location with maven rar packager).\n==========================================\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n  -->\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                             http://maven.apache.org/maven-v4_0_0.xsd \">\n  <modelVersion>4.0.0</modelVersion>\n\n<!-- ====================================================================== -->\n<!-- P R O J E C T  D E S C R I P T I O N                                   -->\n<!-- ====================================================================== -->\n  <groupId>org.apache.jackrabbit</groupId>\n  <artifactId>jackrabbit-jca</artifactId>\n  <packaging>rar</packaging>\n  <name>Jackrabbit JCA</name>\n  <version>1.1-SNAPSHOT</version>\n  <!--\n    Keep the description on a single line. Otherwise Maven might generate\n    a corrupted MANIFEST.MF (see http://jira.codehaus.org/browse/MJAR-4)\n   -->\n  <description>\nA resource adapter for Jackrabbit as specified by JCA 1.0.\n</description>\n  <url>http://jackrabbit.apache.org/</url>\n  <prerequisites>\n    <maven>2.0</maven>\n  </prerequisites>\n  <issueManagement>\n    <system>Jira</system>\n    <url>http://issues.apache.org/jira/browse/JCR</url>\n  </issueManagement>\n  <inceptionYear>2005</inceptionYear>\n\n\n\n\n<!-- ====================================================================== -->\n<!-- M A I L I N G   L I S T S                                              -->\n<!-- ====================================================================== -->\n  <mailingLists>\n    <mailingList>\n      <name>Jackrabbit Announce List</name>\n      <subscribe>announce-subscribe@jackrabbit.apache.org</subscribe>\n      <unsubscribe>announce-unsubscribe@jackrabbit.apache.org</unsubscribe>\n      <archive>http://mail-archives.apache.org/mod_mbox/jackrabbit-announce/</archive>\n    </mailingList>\n    <mailingList>\n      <name>Jackrabbit Users List</name>\n      <subscribe>users-subscribe@jackrabbit.apache.org</subscribe>\n      <unsubscribe>users-unsubscribe@jackrabbit.apache.org</unsubscribe>\n      <post>users at jackrabbit.apache.org</post>\n      <archive>http://mail-archives.apache.org/mod_mbox/jackrabbit-users/</archive>\n      <otherArchives>\n        <otherArchive>\n          http://dir.gmane.org/gmane.comp.apache.jackrabbit.user\n        </otherArchive>\n        <otherArchive>\n          http://www.mail-archive.com/users@jackrabbit.apache.org/\n        </otherArchive>\n      </otherArchives>\n    </mailingList>\n    <mailingList>\n      <name>Jackrabbit Development List</name>\n      <subscribe>dev-subscribe@jackrabbit.apache.org</subscribe>\n      <unsubscribe>dev-unsubscribe@jackrabbit.apache.org</unsubscribe>\n      <post>dev at jackrabbit.apache.org</post>\n      <archive>http://mail-archives.apache.org/mod_mbox/jackrabbit-dev/</archive>\n      <otherArchives>\n        <otherArchive>\n          http://dir.gmane.org/gmane.comp.apache.jackrabbit.devel\n        </otherArchive>\n        <otherArchive>\n          http://www.mail-archive.com/dev@jackrabbit.apache.org/\n        </otherArchive>\n        <otherArchive>\n          http://www.mail-archive.com/jackrabbit-dev@incubator.apache.org/\n        </otherArchive>\n      </otherArchives>\n    </mailingList>\n    <mailingList>\n      <name>Jackrabbit Source Control List</name>\n      <subscribe>commits-subscribe@jackrabbit.apache.org</subscribe>\n      <unsubscribe>commits-unsubscribe@jackrabbit.apache.org</unsubscribe>\n      <archive>http://mail-archives.apache.org/mod_mbox/jackrabbit-commits/</archive>\n    </mailingList>\n  </mailingLists>\n\n\n  <licenses>\n    <license>\n      <name>The Apache Software License, Version 2.0</name>\n      <url>http://www.apache.org/licenses/LICENSE-2.0</url>\n      <distribution>repo</distribution>\n    </license>\n  </licenses>\n  <scm>\n    <connection>scm:svn:http://svn.apache.org/repos/asf/jackrabbit/trunk/jca</connection>\n    <developerConnection>scm:svn:https://svn.apache.org/repos/asf/jackrabbit/trunk/jca</developerConnection>\n    <url>http://svn.apache.org/viewvc/jackrabbit/trunk/jca</url>\n  </scm>\n  <organization>\n    <name>The Apache Software Foundation</name>\n    <url>http://www.apache.org/</url>\n  </organization>\n  <build>\n    <resources>\n      <resource>\n        <directory>src/java</directory>\n      </resource>\n    </resources>\n<!-- \n   <testResources>\n      <testResource>\n        <directory>applications/test</directory>\n        <includes>\n          <include>*.properties</include>\n          <include>*.xml</include>\n        </includes>\n      </testResource>\n      <testResource>\n        <directory>src/test/java</directory>\n        <includes>\n          <include>**/*.xml</include>\n          <include>**/*.txt</include>\n        </includes>\n      </testResource>\n    </testResources>\n-->\n    <plugins>\n      <plugin>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n          <target>1.4</target>\n          <source>1.4</source>\n        </configuration>\n      </plugin>\n<!-- \n      <plugin>\n        <artifactId>maven-surefire-plugin</artifactId>\n        <configuration>\n          <excludes>\n            <exclude>**/init/*</exclude>\n          </excludes>\n          <includes>\n            <include>**/*TestAll.java</include>\n          </includes>\n          <forkMode>once</forkMode>\n          <argLine>-Xmx128m -enableassertions</argLine>\n          <systemProperties>\n            <property>\n              <name>derby.system.durability</name>\n              <value>test</value>\n            </property>\n            <property>\n              <name>known.issues</name>\n              <value>org.apache.jackrabbit.core.xml.DocumentViewTest#testMultiValue org.apache.jackrabbit.value.BinaryValueTest#testBinaryValueEquals</value>\n            </property>\n          </systemProperties>          \n        </configuration>\n      </plugin>\n-->\n    </plugins>\n  </build>\n\n  <dependencies>\n  \n  \t<dependency>\n\t    <groupId>org.apache.jackrabbit</groupId>\n\t    <artifactId>jackrabbit-core</artifactId>\n\t    <version>1.1-SNAPSHOT</version>\n\t</dependency>\n    <dependency>\n      <groupId>concurrent</groupId>\n      <artifactId>concurrent</artifactId>\n      <version>1.3.4</version>\n    </dependency>\n    <dependency>\n      <groupId>commons-collections</groupId>\n      <artifactId>commons-collections</artifactId>\n      <version>3.1</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.geronimo.specs</groupId>\n      <artifactId>geronimo-jta_1.0.1B_spec</artifactId>\n      <version>1.0.1</version>\n    </dependency>\n    <dependency>\n      <groupId>javax.jcr</groupId>\n      <artifactId>jcr</artifactId>\n      <version>1.0</version>\n    </dependency>\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.8</version>\n    </dependency>\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>1.0</version>\n    </dependency>\n    <dependency>\n      <groupId>lucene</groupId>\n      <artifactId>lucene</artifactId>\n      <version>1.4.3</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.derby</groupId>\n      <artifactId>derby</artifactId>\n      <version>10.1.1.0</version>\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <distributionManagement>\n    <repository>\n      <id>apache.releases</id>\n      <name>Apache Repository for PMC approved releases</name>\n      <url>scp://people.apache.org/www/www.apache.org/dist/maven-repository/</url>\n    </repository>\n    <snapshotRepository>\n      <id>apache.snapshots</id>\n      <name>Apache Development Repository</name>\n      <url>scp://people.apache.org/www/cvs.apache.org/maven-snapshot-repository</url>\n    </snapshotRepository>\n    <site>\n      <id>website</id>\n      <url>scp://people.apache.org/www/jackrabbit.apache.org/</url>\n    </site>\n  </distributionManagement>\n\n</project>",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1930",
        "summary": "Extra </div> in populate.jsp",
        "description": "The populate.jsp page in jackrabbit-webapp has an extra </div> that causes minor breakage to the page layout.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1131",
        "summary": "JCR2SPI NodeEntryImpl throws NPE during reorderNodes",
        "description": "Two folder nodes are created below root. From the root node, the 2nd folder is ordered before the first node. The request is batched up correctly, but upon save, NodeEntryImpl throws a NullPointerException in the first line of the completeTransientChanges method, because revertInfo.oldParent is null.\n\nTest code:\n\n\t\tfinal String FOLDER1 = \"folder1\", FOLDER2 = \"folder2\";\n\t\t\n\t\t// Create folder 1 on server in root\n\t\tSession serverSession = login(repository, creds);\n\t\tNode serverRootNode = serverSession.getRootNode();\n\t\tNode serverFolder1 = serverRootNode.addNode(FOLDER1, \"nt:folder\");\n\t\t\n\t\t// Create folder 2 on server in root\n\t\tNode serverFolder2 = serverRootNode.addNode(FOLDER2, \"nt:folder\");\n\t\tserverSession.save();\n\t\t\n\t\t// Validate order (TODO)\n\t\t\n\t\t// Perform reorder via client\n\t\tSession clientSession = login(clientRepository, creds);\n\t\tNode clientRootNode = clientSession.getRootNode();\n\t\tclientRootNode.orderBefore(FOLDER2, FOLDER1);\n\t\tclientSession.save(); <== Throws NPE\n\nCall Stack:\n\n    [junit] java.lang.NullPointerException\n    [junit]     at org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntryImpl.completeTransientChanges(NodeEntryImpl.java:1354)\n    [junit]     at org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntryImpl.access$1100(NodeEntryImpl.java:60)\n    [junit]     at org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntryImpl$RevertInfo.statusChanged(NodeEntryImpl.java:1465)\n    [junit]     at org.apache.jackrabbit.jcr2spi.state.ItemState.setStatus(ItemState.java:257)\n    [junit]     at org.apache.jackrabbit.jcr2spi.state.NodeState.adjustNodeState(NodeState.java:554)\n    [junit]     at org.apache.jackrabbit.jcr2spi.state.NodeState.persisted(NodeState.java:276)\n    [junit]     at org.apache.jackrabbit.jcr2spi.state.ChangeLog.persisted(ChangeLog.java:135)\n    [junit]     at org.apache.jackrabbit.jcr2spi.WorkspaceManager.execute(WorkspaceManager.java:479)\n    [junit]     at org.apache.jackrabbit.jcr2spi.state.SessionItemStateManager.save(SessionItemStateManager.java:149)\n    [junit]     at org.apache.jackrabbit.jcr2spi.ItemImpl.save(ItemImpl.java:239)\n    [junit]     at org.apache.jackrabbit.jcr2spi.SessionImpl.save(SessionImpl.java:317)\n    [junit]     at TestWsNodeReorder.testReorderNodes(TestWsNodeReorder.java:72)\n\n\nI'm using an SPI I implemented, in conjunction with the jcr2spi and spi2jcr bridges, coupled with a back-end Jackrabbit in-memory filesystem. So there's always the possibility that node or property SPI calls inject errors and cause this downstream problem.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-786",
        "summary": "OracleBundlePersistenceManager needs special blob handling for JDBC drivers prior to oracle 10",
        "description": "the new oracle bundle persistence manager (see JCR-755) needs special blob handling for oracle jdbc drivers prior to version 10. since the pm works for newer versions, i suggest to add a separate pm eg: Oracle9PersistenceManager that contains this special blob handling.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1327",
        "summary": "SPI POM improvements",
        "description": "While the SPI components were upgraded from the sandbox I didn't pay too much attention to the POM details and thus there still are a number of configuration entries that duplicate stuff from the Jackrabbit parent POM, etc.\n\nI plan to get rid of any such duplication, remove some unneeded dependencies (spi-commons has a compile scope dependency on junit) and generally update the POMs to be in line with the other release components.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1296",
        "summary": "Exception may get lost in WorkspaceManager.OperationVisitorImpl.execute()",
        "description": "The method calls Batch.submit() in the finally block. If both the try and finally block throw exceptions, the one from the try block is ignored.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-555",
        "summary": "ConsistencyCheck uses too much memory",
        "description": "A consistency check loads all lucene documents into memory. On a large repository this may lead to an OutOfMemoryError. The consistency check should rather read the lucene documents on demand and discard them afterwards.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2752",
        "summary": "The \"jackrabbit-pool-\" thread prevents the process from stopping",
        "description": "If the repository is not closed, and a session is still logged in, then the process doesn't terminate because of a non-daemon thread named \"jackrabbit-pool-<n>\". Test case:\n\npublic class TestThreadPreventsExit {\n    public static void main(String... a) throws Exception {\n        new TransientRepository().login(\n                new SimpleCredentials(\"\", new char[0]));\n    }\n}\n\nThis program doesn't stop.\n\nThe non-daemon thread was introduces as part of https://issues.apache.org/jira/browse/JCR-2465\n\nThe fix is to use a daemon thread.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-606",
        "summary": "RMI-DateValue does not support full ISO8601 format",
        "description": "as mentioned in the javadoc:\n\n * To convert <code>Calendar</code> instances to and from strings, this class\n * uses a <code>SimpleDateFormat</code> instance with the pattern\n * <code>yyyy-MM-dd'T'HH:mm:ss'Z'</code>. The issue with this pattern is that\n * the era specification as defined in the JCR specification (+/- prefix) as\n * well as full time zone naming are not supported.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1663",
        "summary": "REFERENCE properties produce duplicate strings in memory",
        "description": "When reference property is loaded from PM, Serializer.deserialize(NodeReferences, InputStream) is called, which calls PropertyId.valueOf(String), which in turn calls NameFactoryImpl.create(String) which finally splits a full property name to namespace and local name. Namespace is internalized, but local name is not (comments say that this is done to avoid perm space overfilling).\nSo, in the end, a new String instance is created for local name. This leads to considerable memory waste when repository has a lot of nodes with REFERENCE properties.\nIt seems that local name part could be internalized here too because in the most repositories it's not allowed to create properties with arbitrary names, so the danger of perm space exhaust does not seem to be an argument.\n\nAs for ways to resolve this, maybe a new NameFactory implementation could be created which would be used for properties only (and, possibly, mainly in the PropertyId.valueOf(String)) which would extend an existing NameFactoryImpl overriding its create(String) method.\n\nWhat do you think about all this?",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-574",
        "summary": "MsExcelTextFilter throws Exception. Repository is not startable",
        "description": "If i try to add a Excel File (see attachment) i get this Exception\n\nCaused by: java.lang.NumberFormatException: You cannot get a string value from a numeric cell\n\tat org.apache.poi.hssf.usermodel.HSSFCell.getStringCellValue(HSSFCell.java:800)\n\tat org.apache.jackrabbit.core.query.MsExcelTextFilter$1.initializeReader(MsExcelTextFilter.java:97)\n\tat org.apache.jackrabbit.core.query.LazyReader.read(LazyReader.java:79)\n\nThe bad news is that if you add this file the repository is not startabel anymore because the file is in the redo.log and you\nget a blocker !\n\nThe stack from the restart after NumberFormatException\n\n19.09.2006 08:47:23 *ERROR* RepositoryImpl: Unable to start repository, forcing shutdown... \n19.09.2006 08:47:23 *INFO * RepositoryImpl: Shutting down repository... \n19.09.2006 08:47:23 *INFO * RepositoryImpl: shutting down workspace 'default'... \n19.09.2006 08:47:23 *INFO * ObservationManagerFactory: Notification of EventListeners stopped. \n19.09.2006 08:47:23 *INFO * RepositoryImpl: workspace 'default' has been shutdown \n\nI think its very important that you can not block a whole repository if the indexer throws a exception.\nthanks\nclaus",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3065",
        "summary": "ConcurrentModificationException in FineGrainedISMLocking",
        "description": "We have a report where the FineGrainedISMLocking throws a ConcurrentModificationException (stacktrace\nfrom a Jackrabbit 2.2.x):\n\njava.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)\n\tat java.util.HashMap$KeyIterator.next(HashMap.java:828)\n\tat org.apache.jackrabbit.core.state.FineGrainedISMLocking$LockMap.hasDependency(FineGrainedISMLocking.java:388)\n\tat org.apache.jackrabbit.core.state.FineGrainedISMLocking.acquireWriteLock(FineGrainedISMLocking.java:138)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.acquireWriteLock(SharedItemStateManager.java:1848)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.access$200(SharedItemStateManager.java:113)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:563)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:1457)\n\tat org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:1487)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:351)\n\tat org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:354)\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:326)\n\tat org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:289)\n\tat org.apache.jackrabbit.core.ItemSaveOperation.perform(ItemSaveOperation.java:258)\n\tat org.apache.jackrabbit.core.session.SessionState.perform(SessionState.java:200)\n\tat org.apache.jackrabbit.core.ItemImpl.perform(ItemImpl.java:91)\n\tat org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:329)\n\tat org.apache.jackrabbit.core.session.SessionSaveOperation.perform(SessionSaveOperation.java:42)\n\tat org.apache.jackrabbit.core.session.SessionState.perform(SessionState.java:200)\n\tat org.apache.jackrabbit.core.SessionImpl.perform(SessionImpl.java:355)\n\tat org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:758)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2220",
        "summary": "Use the remote-resources-plugin to add LICENSE and NOTICE files to binaries",
        "description": "Since JCRSITE-13 the remote resources plugin is configured to automatically add LICENSE and NOTICE files to all of our binary artifacts (including -sources and -javadoc jars). We should adapt the configuration so that these files get to include all the correct licensing metadata we currently maintain in src/main/resources/META-INF.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1069",
        "summary": "SerializationTest and AbstractImportXmlTest leak temporary files",
        "description": "Both test classes leak temporary files when setUp() fails.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-24",
        "summary": "ClassCastException bei unregisterNodeType",
        "description": "I have a NodeType with various childnodes which I want to unregister. If I call:\n\n    \n      NodeTypeManager ndmg = session.getWorkspace().getNodeTypeManager();\n      NodeTypeRegistry ntReg = ((NodeTypeManagerImpl) ndmg).getNodeTypeRegistry();\n      ntReg.unregisterNodeType(new QName(\"testURI\",\"Page\"));\n\n\nI get a \n\njava.lang.ClassCastException\n at org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.getDependentNodeTypes(NodeTypeRegistry.java:1242)\n at org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.unregisterNodeType(NodeTypeRegistry.java:1120)\n at de.freaquac.test.JCRTest.main(JCRTest.java:80)\n\nIt looks to me like there are QNames in the Iterator but NodeTyeDefs are expected.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-646",
        "summary": "Misleading exception message for jcr:deref()",
        "description": "If the type of the second argument in a jcr:deref() function is not a String an InvalidQueryException is thrown with a misleading message: \"Wrong second argument type for jcr:like\"\n\nIt should be rather something like: \"Second argument for jcr:deref must be a String\"",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1514",
        "summary": "SPI: Javadoc Issue with QNodeTypeDefinition#getPropertyDefs and #getChildNodeDefs",
        "description": "Javadoc of the mentioned methods currently states:\n\n@return an array containing the property definitions or\n     *         <code>null</code> if not set.\n\nwhile the default implementation returns an empty array, which i find much nicer.\n\nif nobody objects, i would fix the javadoc accordingly.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "BUG"
    },
    {
        "key": "JCR-526",
        "summary": "TCK: XPathQueryLevel2Test uses optional column specifier syntax",
        "description": "Test assumes the implementation uses a terminal attribute step as the column specifier.  This is allowed, but not required, by JCR.\n\nProposal: remove column specifier and process results using getNodes instead of getRows.\n\n--- XPathQueryLevel2Test.java   (revision 422074)\n+++ XPathQueryLevel2Test.java   (working copy)\n@@ -85,7 +85,7 @@\n         checkResult(result, 1);\n  \n         // evaluate result\n-        checkValue(result.getRows(), propertyName1, \"b\");\n+        checkValue(result.getNodes(), propertyName1, \"b\");\n     }\n  \n     /**\n@@ -101,7 +101,7 @@\n         checkResult(result, 1);\n  \n         // evaluate result\n-        checkValue(result.getRows(), propertyName1, \"existence\");\n+        checkValue(result.getNodes(), propertyName1, \"existence\");\n     }\n  \n     /**\n@@ -147,7 +147,6 @@\n         tmp.append(jcrRoot).append(testRoot);\n         tmp.append(\"/*[@\").append(propertyName2).append(\" = 'two'\");\n         tmp.append(\" and @\").append(propertyName1).append(\" = 'existence']\");\n-        tmp.append(\"/@\").append(propertyName1);\n         return new Statement(tmp.toString(), Query.XPATH);\n     }\n  \n@@ -161,7 +160,7 @@\n         tmp.append(propertyName1);\n         tmp.append(\" <= 'b' and @\");\n         tmp.append(propertyName1);\n-        tmp.append(\" > 'a']/@\").append(propertyName1);\n+        tmp.append(\" > 'a']\");\n         return new Statement(tmp.toString(), Query.XPATH);\n     }\n }\n\n--- AbstractQueryLevel2Test.java        (revision 422074)\n+++ AbstractQueryLevel2Test.java        (working copy)\n@@ -19,6 +19,7 @@\n import org.apache.jackrabbit.test.NotExecutableException;\n  \n import javax.jcr.nodetype.NodeType;\n+import javax.jcr.NodeIterator;\n import javax.jcr.query.RowIterator;\n import javax.jcr.query.Row;\n import javax.jcr.Value;\n@@ -115,4 +116,16 @@\n                     expectedValue, value.getString());\n         }\n     }\n+\n+    protected void checkValue(NodeIterator itr,\n+                              String propertyName,\n+                              String expectedValue) throws RepositoryException {\n+        while (itr.hasNext()) {\n+            Node node = itr.nextNode();\n+            // check fullText\n+            Value value = node.getProperty(propertyName).getValue();\n+            assertEquals(\"Value in query result row does not match expected value\",\n+                    expectedValue, value.getString());\n+        }\n+    }\n }\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2196",
        "summary": "Add cause to ItemStateException in BundleDbPersistenceManager.store()",
        "description": "Currently only the message of the causing exception is given to the ItemStateException. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-34",
        "summary": "autoCreate attribute of PropDef instances not serialized",
        "description": "When a property of custom node type is defined to be autoCreate=true, this fact is not serialized to the custom_nodetypes.xml file. Digging into the source revealse the NodeTypeDefStore.writeDef method to not write the autoCreate attribute:\n\n   // autoCreate\n   String autoCreate = elem.getAttributeValue(AUTOCREATE_ATTRIBUTE);\n   if (autoCreate != null && autoCreate.length() > 0) {\n     pd.setAutoCreate(Boolean.valueOf(autoCreate).booleanValue());\n   }\n\nThis seems to be a remains of a copy-paste procedure :-) with the correct code most probably being something like\n\n   // autoCreate\n   elem.setAttribute(AUTOCREATE_ATTRIBUTE, Boolean.toString(pd.isAutoCreate()));\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-481",
        "summary": "Checks for optional features in test cases are wrong",
        "description": "Reported by David Sanders:\n\nThe TCK for JSR-170 Final Release\n(http://jcp.org/aboutJava/communityprocess/final/jsr170/index.html)\nchecks for level 2 and optional features by comparing\nRepository.getDescriptor to null.  According to the\nspec and javadoc, getDescriptor must return either\n\"true\" or \"false\" for the \"capability\" keys.\n\nExample in AbsractJCRest.java:\n\n        // setup custom namespaces\n        if\n(helper.getRepository().getDescriptor(Repository.LEVEL_2_SUPPORTED)\n!= null) {\n            NamespaceRegistry nsReg =\nsuperuser.getWorkspace().getNamespaceRegistry();\n\n\nI think the above if statement should be:\n       if\n(helper.getRepository().getDescriptor(Repository.LEVEL_2_SUPPORTED)\n.equals(\"true\")) ",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1008",
        "summary": "SerializationTest leaks sessions",
        "description": "The class TreeComparator extends from AbstractJCRTest and opens a session in its constructor because it calls the setUp() method. The tearDown() method is never called.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-255",
        "summary": "Workspace operations (copy/clone) do not handle references correctly",
        "description": "REFERENCE properties created through Workspace.copy() or Workspace.clone() are not reflected by \nNode.getReferences() and are as a consequence not enforced.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2201",
        "summary": "Implement QueryResult.getSelectorNames()",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-76",
        "summary": "PersistenceManager sanity check",
        "description": "Library that provides a framework for testing the repository consistency and repairing it if necessary.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-99",
        "summary": "Introduce cache for frequently used index lookups",
        "description": "Some queries heavily use hierarchy relations to resolve location steps. E.g. ChildAxisQuery or DescendantSelfAxisQuery. Currently those hierarchy relations are looked up from the native lucene index which is not very efficient. The index should maintain a cache of frequently used hierarchy lookups. \nThat is, calls like IndexReader.termDocs() on terms with field: UUID or PARENT",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2341",
        "summary": "Unable to add/lock and unlock/remove Node with shared Session in 2 Transactions",
        "description": "If you try to unlock and remove a node the NodeState can be run out of sync between the two operations.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2863",
        "summary": "Session#importXML can't handle properly uuid collision if user has insufficient permission",
        "description": "When importing referenceable nodes, if there are nodes with the same uuid in the workspace but the session has no sufficient permission to read them then the import will fail no matter what ImportUUIDBehavior is chosen. \nBut the same xml will be imported successfully in another repository or if the user have read access.\n\nSessionImpl.java :\n public NodeImpl getNodeById(NodeId id) ...{\n...\n try {\n            return (NodeImpl) getItemManager().getItem(id);\n        } catch (AccessDeniedException ade) {\n            throw new ItemNotFoundException(id.toString());\n        }\n}\n\nSessionImporter.java :\n\n public void startNode(NodeInfo nodeInfo, List propInfos)...{\n...\n  if (node == null) {\n            // create node\n            if (id == null) {\n            ...\n            } else {\n                // potential uuid conflict\n                NodeImpl conflicting;\n                try {\n                    conflicting = session.getNodeById(id);\n                } catch (ItemNotFoundException infe) {\n                    conflicting = null;\n                }\n                if (conflicting != null) {\n                    // resolve uuid conflict\n                 ...\n               }\n...\n}\n\nIn the JCR 1.0 spec says \"lack of read access to an item blocks access to both information about the content of that item and information about the existence of the item\" but this should probably not be true, internally, when doing an import. \nOtherwise it means that read access to an entire workspace must be granted to a user so that it could successfully use the IMPORT_UUID_CREATE_NEW behaviour.\n\n",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-334",
        "summary": "loadURI compile error with Maven 1.0.2",
        "description": "As reported on the mailing list by Ashley Martens:\n\n----\nC:\\apache\\jackrabbit-contrib\\nt-ns-util>maven\n __  __\n|  \\/  |__ _Apache__ ___\n| |\\/| / _` \\ V / -_) ' \\  ~ intelligent projects ~\n|_|  |_\\__,_|\\_/\\___|_||_|  v. 1.0.2\n\nAttempting to download jackrabbit-1.0-SNAPSHOT.jar.\nArtifact /org.apache.jackrabbit/jars/jackrabbit-1.0-SNAPSHOT.jar doesn't exists in remote repository, but it exists locally\nAttempting to download jackrabbit-commons-1.0-SNAPSHOT.jar.\nArtifact /org.apache.jackrabbit/jars/jackrabbit-commons-1.0-SNAPSHOT.jar doesn't exists in remote repository, but it exists locally\nbuild:start:\n\njava:prepare-filesystem:\n\njava:compile:\n   [echo] Compiling to C:\\apache\\jackrabbit-contrib\\nt-ns-util/target/classes\n   [javac] Compiling 1 source file to C:\\apache\\jackrabbit-contrib\\nt-ns-util\\target\\classes\nC:\\apache\\jackrabbit-contrib\\nt-ns-util\\src\\main\\java\\org\\apache\\jackrabbit\\util\\nodetype\\SchemaConverter.java:71: cannot resolve symbol\nsymbol  : method loadURI (java.lang.String)\nlocation: class org.apache.xerces.impl.xs.XMLSchemaLoader\n       XSModel xsModel = loader.loadURI(uri);\n                               ^\n1 error\n\nBUILD FAILED\nFile...... C:\\Documents and Settings\\ashleym\\.maven\\cache\\maven-java-plugin-1.5\\plugin.jelly\nElement... ant:javac\nLine...... 63\nColumn.... 48\nCompile failed; see the compiler error output for details.\nTotal time: 8 seconds\nFinished at: Mon Jan 02 10:40:47 EST 2006\n----\n\nPeeter Piegaze found out the problem:\n\n----\nI was able to build it without a problem using maven-1.1-beta-2 and JDK 1.4.2.\n\nHowever, it sounds to me like in your case maven has set up its\non-build classpath so that it sees the older xerces-2.4.0.jar before\nthe new xerxesImpl.-2.6.2.jar. Maven seems to download the old\nxerces-2.4.0 into its repository for internal use, while my code uses\nthe newer xerxesImpl-2.6.2.jar. The old jar overlaps class-wise with\nthe new one, but the new one implements the additional loadURI method\n(among others).\n\nI am not sure exactly why your maven build process is looking in the\nwrong jar. But that is what is doing, almost certainly.\n----\n",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-2107",
        "summary": "JSR 283 Query",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-743",
        "summary": "XA Transaction Recovery",
        "description": "If i add a node to the repository i get a XAException because i run into a Timeout ... \nI see the Warn Message: Transaction rolled back because timeout expired.\nThe default Timeout is set to 5 sec and i dont know how to set it to a higher value\nThe Problem is if i restart my server websphere has a RecoveryManager and he try to recover this Transaction\nand then i get a NullpointerException in JCAManagedConnectionFactory. createManagedConnection beacuse the given \nConnectionRequestInfo is null.\nSo i dont know why the RecoveryManager tries to recover the Transaction ? The only solution for me is to delete the Tran-Log Files wich keep Websphere to recvoer\nXA Trasnactions.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2765",
        "summary": "JCR-SQL2 : no count when WHERE clause is provided",
        "description": "whenever you provide a where-clause to a sql2 select, jcr/jackrabbit does not provide the hit count.\n\nE.g.:\n   select * from [nt:unstructured]\n   order by [jcr:score]\nreturns the hit count (query.execute().getRows().getSize()), \nwhereas\n  select * from [nt:unstructured]\n  where entity = \"customer\"\n  order by [jcr:score]\ndoesn't.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2087",
        "summary": "Upgrade to Java 5 as the base platform",
        "description": "As discussed on the mailing list, Jackrabbit 2.0 will use Java 5 as the base platform.\n\nNow that 1.x has been branched, we can update the build settings in trunk to use Java 5.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1582",
        "summary": "Parameters 'idleTime' and 'queryClass' cause QueryHandler to fail",
        "description": "This issue does not occur in a released jackrabbit-core version. With the changes from JCR-1462 jackrabbit now fails to startup if there is an unknown parameter in a bean configuration.\n\nThe parameters 'idleTime' and 'queryClass' are not used by the QueryHandler but by the SearchManager, which instantiates the QueryHandler. Therefore the parameters do not show up in the QueryHandler.\n\nI suggest we introduce them in the common base class AbstractQueryHandler.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1283",
        "summary": "Add missing license headers",
        "description": "The RAT tool (http://code.google.com/p/arat/) points out a few files within Jackrabbit trunk that are currently missing the correct license header. We should fix those.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1981",
        "summary": "Test class in the main source tree",
        "description": "org.apache.jackrabbit.core.TestRepository is in the main source folder\n(src/main/java) instead of the test folder (src/test/java).\n\nThe build of jackrabbit-core is successful even if I move the class\nto the test folder, so it looks like it was just a mistake.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2256",
        "summary": "JSR 283 Repository Descriptors",
        "description": "- new methods returning Value objects (jcr2spi)\n- check descriptor-report in jcr-server and corresponding handling on the client side\n- etc.etc.",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1409",
        "summary": "PathFactoryImpl creates illegal Path objects",
        "description": "it is currently possible to create illegal/inconsistent paths using the default path factory.\nPath objects are expected to represent syntactically correct paths.\n\nsome examples:\n\n            PathFactory pf = PathFactoryImpl.getInstance();\n            Path.Element re = pf.getRootElement();\n            Path illegalPath = pf.create(new Path.Element[]{re, re});\n            \n            Path.Element pe = pf.getParentElement();\n            Path nonNormalizedPath = pf.create(new Path.Element[]{pe, pe});    // \"../..\"\n            assertFalse(nonNormalizedPath.isNormalized());\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1499",
        "summary": "Error logged when repository is shut down",
        "description": "This only happens with the bundle DerbyPersistenceManager.\n\nIn DerbyPersistenceManager.close() the embedded derby database is shut down and then super.close() is called. There the ConnectionRecoveryManager is closed, which tries to operate on a connection to the already shut down derby database. The log contains entries like:\n\n25.03.2008 13:49:29 *ERROR* [Thread-5] ConnectionRecoveryManager: failed to close connection, reason: No current connection., state/code: 08003/40000 (ConnectionRecoveryManager.java, line 453)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1365",
        "summary": "Query path constraints like foo//*/bar do not scale",
        "description": "To resolve the * step the LuceneQueryBuilder currently creates a MatchAllQuery and checks every node for a foo ancestor. Instead, it should search for bar nodes and check for foo ancestors with at least one arbitrary hierarchy level in between.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2493",
        "summary": "Unit tests for persistence managers",
        "description": "Currently we only test our persistence managers indirectly via JCR-level test cases. The downside of this approach is that we can only test one persistence manager implementation at a time, and need separate build profiles to switch from one implementation to another. To ensure better coverage and consistent behaviour across all our persistence managers I implemented a simple unit test that works directly against the PersistenceManager interface.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-405",
        "summary": "PROPPATCH doesn't respect document order",
        "description": "PROPPATCH is currently implemented in terms of DavResource.alterProperties(...), which takes a set of properties to be set and a set of properties to be removed. This is not sufficient to model WebDAV's method semantics, as the order in which set/remove instructions appear is supposed to be relevant.\n\nI have submitted a patch to the Litmus mailing list checking this (see <http://mailman.webdav.org/pipermail/litmus/2006-April/000196.html>).\n\nIn jcr-server, alterProperties probably should be changed to take an (ordered) list of set/remove instructions instead. The simplest approach for that would probably be to use a List containing either DavProperty (set) or DavPropertyName (remove) objects.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-902",
        "summary": "Put JavaDoc resources in src/main/javadoc",
        "description": "The Maven javadoc plugin suggests that Javadoc resources like package.html files and doc-files subdirectories should be placed in the src/main/javadoc folder (see http://maven.apache.org/plugins/maven-javadoc-plugin/faq.html). I'll move the javadoc files unless anyone argues otherwise.",
        "label": "NUG",
        "classified": "OTHER",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3005",
        "summary": "Make it possible to get multiple nodes in one call via davex",
        "description": "I'm working on this currently",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1824",
        "summary": "Change log level for text extractor timeout",
        "description": "Currently an info message is written to the log when a text extractor job times out. Because this may happen quite frequently this should be changed to log level debug.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2604",
        "summary": "Improve javadoc of User#getCredentials",
        "description": "User#getCredentials is not meant to return the credentials used for a repository login but the javadoc in the interface doesn't make this clear.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2246",
        "summary": "Deprecate/remove unused FileSystem features such as RandomAccessOutputStream",
        "description": "Currently the FileSystem interface includes a method getRandomAccessOutputStream.\nIt looks like this method and the class RandomAccessOutputStream is no longer used.\nIf this is the case, I suggest we remove the method everywhere and deprecate the class.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1591",
        "summary": "JSR 283: NodeType Management",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-1184",
        "summary": "Introduce spellchecker functionality based on content in the workspace",
        "description": "Provide a way to spell check a fulltext statement based on the content present in the workspace.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1869",
        "summary": "Make lazy loading proxy callback Serializable",
        "description": "Hello (probably Christophe :) ),\n\nIt would be nice to have the CGLib callbacks Serializable, because if they're not, the proxies are not either, even if the target is.\n\nI've seen that you've made BeanLazyLoader Serializable. Wouldn't be better to have AbstractLazyLoader Serializable, so CollectionLazyLoader is too?\n\nWhat I've done is :\n*) declaring AbstractLazyLoader as Serializable\n*) declaring non-Serializable resources such as Session as volatile\n*) throwing an IllegalStateException in BeanLazyLoader.fetch and CollectionLazyLoader.fetch if the Session is null. This case can only happen if the proxy has been serialized without the volatile Session, and it doesn't make sense to lazy load the target then.\n\nBTW, I realized I didn't clean up the beanClassDescriptor in BeanLazyLoader.cleanUp, so I corrected this.\n\nI'll attach the modified classes.\n\nSincerely,\n\nSt\u00e9phane Landelle",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-686",
        "summary": "change some access-level modifiers to allow for better subclassing",
        "description": "Some of the methods in the core parts of jackrabbit are package protected and do not allow easy subclassing. suggest to make some of the methods 'protected'.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2933",
        "summary": "SQL2 Left Outer Join",
        "description": "Create this nodes.\ndef n1 = root.addNode(\"node1\", \"sling:SamplePage\");\nn1.setProperty(\"n1prop1\", \"page1\");\ndef n2 = n1.addNode(\"node2\", \"sling:SampleContent\");\nn2.setProperty(\"n2prop1\", \"content1\");\n\nExecute this Query:\nSelect * from [sling:SamplePage] as page left outer join [sling:SampleContent] as content on ISDESCENDANTNODE(content,page) where page.n1prop1 = 'page1' and content.n2prop1 = 'content1';\nThe resultset have 1 row with 2 Nodes. This OK.\n\nThen execute this:\nSelect * from [sling:SamplePage] as page left outer join [sling:SampleContent] as content on ISDESCENDANTNODE(content,page) where page.n1prop1 = 'page1' and content.n2prop1 = 'XXXXX';\n\nThe resultset has 1 row with 1 node.\nThis wrong. The result should be 0 rows.\n\nOld Versions, prior 2.2.2 have also 0 rows as result.\n\nAlso, if nodes \"n2\" not exists, jackrabbit reports 1 row as result.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1613",
        "summary": "REMOVE access is not checked when moving a node",
        "description": "When a node cannot be removed because AccessManager does not allow this, it still can be moved (using Session.move()).",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2361",
        "summary": "Add parser callback to GQL",
        "description": "The parsing of GQL is currently hidden in the implementation. It would be nice to have a mechanism that allows client code to get callbacks whenever a field/value pair is parsed.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1490",
        "summary": "[PATCH] UpdateTest has two typos",
        "description": "UpdateTest has a typo where it doesn't grab an element out of an array, but uses the array itself to do comparisons. This patch fixes this.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2574",
        "summary": "Row.getValue(\"rep:excerpt(.)\") may throw ArrayIndexOutOfBoundsException",
        "description": "Happens when the matching node only has properties that are configured not to be used in excerpts.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1833",
        "summary": "Test case for RTFTextExtractor",
        "description": "There should be a test case for the RTFTextExtractor.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2165",
        "summary": "Node.getReferences(String) and Node.getWeakReferences(String) issues",
        "description": "Node.getReferences(String) always returns empty iterator.\n\nNode.getWeakReferences() & getWeakReferences(String)  cannot handle multi-valaued reference properties",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2268",
        "summary": "Generify Security API",
        "description": "The current security api, namely the Authorizable and Group interface use non-generic collections/iterators.\nsuggest to change this.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1101",
        "summary": "Observation tests should throw NotExecutableException when repository does not support observation",
        "description": "The observation tests should throw NotExecutableException when repository does not support observation.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2836",
        "summary": "Unclosed threads in Jackrabbit",
        "description": "The Tomcat integration test added in JCR-2831 shows the following warnings about Jackrabbit threads that remain in place even after the repository has been closed:\n\n08-Dec-2010 12:14:58 org.apache.catalina.loader.WebappClassLoader clearReferencesThreads\nSEVERE: The web application [] appears to have started a thread named [Timer-1] but has failed to stop it. This is very likely to create a memory leak.\n08-Dec-2010 12:14:58 org.apache.catalina.loader.WebappClassLoader clearReferencesThreads\nSEVERE: The web application [] appears to have started a thread named [DynamicPooledExecutor] but has failed to stop it. This is very likely to create a memory leak.\n08-Dec-2010 12:14:58 org.apache.catalina.loader.WebappClassLoader clearReferencesThreads\nSEVERE: The web application [] appears to have started a thread named [Timer-2] but has failed to stop it. This is very likely to create a memory leak.\n\nIt would be best to close all such background threads even if they are singleton daemon threads and thus unlikely to cause trouble when left unattended.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-1252",
        "summary": "BundleFsPersistenceManager: remove deprecated settings",
        "description": "Some settings of the BundleFsPersistenceManager are not used internally and should be removed:\n\nblobFSInitialCache, blobFSMaximumCache, itemFSBlockSize, itemFSInitialCache, itemFSMaximumCache",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2213",
        "summary": "ChangeLogRecord throws NullPointerException",
        "description": "Happens when the userId of the session that created the events is null.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-636",
        "summary": "Local AuthContext authenticates if LoginModule should be ignored",
        "description": "The LoginModule indicates that it doesn't handle thecurrent login-attemp by returning false:\non login or commit invokation. It should thus be ignored.\nThe LoginContext calculates the overall login success.\nIn case of the local context, the login should faile if the only LoginModule is ignored.\nCurrently this is a success, but the ",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2771",
        "summary": "Simplified Repository URI format for JNDI lookups",
        "description": "The JndiRepositoryFactory class (together with JcrUtils) currently supports the following repository URI formats:\n\n    JcrUtils.getRepository(\"jndi:name-of-repository\");\n    JcrUtils.getRepository(\"jndi://ignored?org.apache.jackrabbit.repository.jndi.name=name-of-repository&other-parameters\");\n\nThe first uri formats allows no extra JNDI environment settings to be passed in, and the second one is pretty verbose and simply ignores the authority and path parts of the URI.\n\nI'd like to add support for the following simplified format that makes it easy to provide the repository name along with the initial context factory from which the name is to be looked up:\n\n    JcrUtils.getRepository(\"jndi://initial-context-factory/name-of-repository\");\n\nExtra JNDI environment settings could still be included as additional query parameters. Backwards compatibility with the previous formats would be guaranteed based on the presence or absence of the org.apache.jackrabbit.repository.jndi.name parameter in hierarchical URIs.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-21",
        "summary": "NodeTypeRegistry.validateNodeTypeDef causes NullPointerException",
        "description": "NodeTypeRegistry.registerNodeType(NodeTypeDef) checks the given node type definition for circular inheritance (amongst other things, of course). If the the node type definition does not contain a list of super types, the validateNodeTypeDef() (line 442) causes a NullPointerException being thrown in checkForCircularInheritance() because the \"supertypes\" variable is null and is not being checked.\n\nInterestingly the other accesses to the same supertypes object in validNodeTypeDef() are all guarded against null and length==0. Might be an ommission.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-561",
        "summary": "Add support to provide custom classloader for class instantiation from configuration",
        "description": "The configuration framework is based around a BaseConfig class, which provides functionality to instantiate a class whose name is configured in the repository configuration file. Examples of such classes are the FileSystem or the PersistenceManager elements.\n\nThe current implementation of the BeanConfig.newInstance() method is to use the \"default classloader\" to load configured classes. That is, the class loader of the BeanConfig class is actually used. This is - generally - the class loader which loads the repository. In certain environments, classes may be provided from outside the core repository class loader. An example fo such an environment is an OSGi setup where each bundle gets its own class laoder, which is separate from all other class loaders except declared by configuration.\n\nI propose to enhance the BeanConfig class as follows:\n\npublic class BeanConfig {\n ...\n // Current default class loader, default is BeanConfig's class loader\n private static ClassLoader defaultClassLoader =\nBeanConfig.class.getClassLoader();\n // Current instance class loader\n private ClassLoader classLoader;\n ...\n // Sets the default class loader for new BeanConfig instances\n public static void setDefaultClassLoader(ClassLoader loader);\n // Returns the default class loader for new BeanConfig instances\n public static ClassLoader getClassLoader();\n // Sets the class loader of this BeanConfig instance\n public void setClassLoader(ClassLoader loader);\n // Returns the class loader of this BeanConfig instance\n public ClassLoader getClassLoader();\n}\n\nThe BeanConfig.newInstance method would then use the following to use the class:\n\npublic Object newInstance() throws ConfigurationException {\n Class clazz = Class.forName(getClassName(), true, getClassLoader());\n ...\n}\n\n\nThis has also been discussed on the dev list: http://mail-archives.apache.org/mod_mbox/jackrabbit-dev/200607.mbox/%3cae03024e0607272341l52aff9b2h3957131411790bc9@mail.gmail.com%3e",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-382",
        "summary": "Setting WebDAV property without value causes NPE in DAVResourceImpl",
        "description": "A WebDAV PROPPATCH of a property without a value <prf:SomeProperty/> causes a NPE in DAVResourceImpl when the value is retrieved and the toString() method called on it. Here is a patch that works around the problem.\n\nIndex: C:/jprojects/eclipse/jackrabbit/jcr-server/server/src/java/org/apache/jackrabbit/webdav/simple/DavResourceImpl.java\n===================================================================\n--- C:/jprojects/eclipse/jackrabbit/jcr-server/server/src/java/org/apache/jackrabbit/webdav/simple/DavResourceImpl.java\t(revision 388517)\n+++ C:/jprojects/eclipse/jackrabbit/jcr-server/server/src/java/org/apache/jackrabbit/webdav/simple/DavResourceImpl.java\t(working copy)\n@@ -930,7 +930,10 @@\n      */\n     private void setJcrProperty(DavProperty property) throws RepositoryException {\n         // retrieve value\n-        String value = property.getValue().toString();\n+        String value = \"\";\n+        if (property.getValue() != null) {\n+            value = property.getValue().toString();\n+        }\n         // set value; since multivalued-properties are not listed in the set\n         // of available properties, this extra validation-check is omitted.\n         node.setProperty(getJcrName(property.getName()), value);\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2669",
        "summary": "Improve reading of cached UUID for given document number",
        "description": "CachingIndexReader.document(int n, FieldSelector fieldSelector) creates a new\nField from the cached UUID. The lucene Field implementation always does a\nString.intern() on the field name, which is quite slow. We should probably have\nour own implementation for that specific use case where we know that the name\nis already interned. e.g. UUIDField implements Fieldable.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1185",
        "summary": "building trunk  fails with javacc plugin version 2.2",
        "description": "\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[23,38] cannot find symbol\nsymbol: class JCRSQLParserVisitor\nclass DefaultParserVisitor implements JCRSQLParserVisitor {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[25,24] cannot find symbol\nsymbol  : class SimpleNode\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[29,24] cannot find symbol\nsymbol  : class ASTQuery\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[33,24] cannot find symbol\nsymbol  : class ASTSelectList\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[37,24] cannot find symbol\nsymbol  : class ASTFromClause\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[41,24] cannot find symbol\nsymbol  : class ASTWhereClause\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTPredicate.java:[21,34] cannot find symbol\nsymbol: class SimpleNode\npublic class ASTPredicate extends SimpleNode {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[49,24] cannot find symbol\nsymbol  : class ASTOrExpression\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[53,24] cannot find symbol\nsymbol  : class ASTAndExpression\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[57,24] cannot find symbol\nsymbol  : class ASTNotExpression\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[61,24] cannot find symbol\nsymbol  : class ASTBracketExpression\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTLiteral.java:[19,32] cannot find symbol\nsymbol: class SimpleNode\npublic class ASTLiteral extends SimpleNode {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTIdentifier.java:[21,35] cannot find symbol\nsymbol: class SimpleNode\npublic class ASTIdentifier extends SimpleNode {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[73,24] cannot find symbol\nsymbol  : class ASTOrderByClause\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTContainsExpression.java:[21,43] cannot find symbol\nsymbol: class SimpleNode\npublic class ASTContainsExpression extends SimpleNode {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[81,24] cannot find symbol\nsymbol  : class ASTOrderSpec\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[85,24] cannot find symbol\nsymbol  : class ASTAscendingOrderSpec\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[89,24] cannot find symbol\nsymbol  : class ASTDescendingOrderSpec\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[93,24] cannot find symbol\nsymbol  : class ASTLowerFunction\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[97,24] cannot find symbol\nsymbol  : class ASTUpperFunction\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/DefaultParserVisitor.java:[101,24] cannot find symbol\nsymbol  : class ASTExcerptFunction\nlocation: class org.apache.jackrabbit.core.query.sql.DefaultParserVisitor\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTPredicate.java:[37,22] cannot find symbol\nsymbol  : class JCRSQLParser\nlocation: class org.apache.jackrabbit.core.query.sql.ASTPredicate\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTPredicate.java:[82,26] cannot find symbol\nsymbol  : class JCRSQLParserVisitor\nlocation: class org.apache.jackrabbit.core.query.sql.ASTPredicate\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTLiteral.java:[30,22] cannot find symbol\nsymbol  : class JCRSQLParser\nlocation: class org.apache.jackrabbit.core.query.sql.ASTLiteral\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTLiteral.java:[54,28] cannot find symbol\nsymbol  : class JCRSQLParserVisitor\nlocation: class org.apache.jackrabbit.core.query.sql.ASTLiteral\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTIdentifier.java:[29,23] cannot find symbol\nsymbol  : class JCRSQLParser\nlocation: class org.apache.jackrabbit.core.query.sql.ASTIdentifier\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTIdentifier.java:[42,26] cannot find symbol\nsymbol  : class JCRSQLParserVisitor\nlocation: class org.apache.jackrabbit.core.query.sql.ASTIdentifier\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTContainsExpression.java:[31,33] cannot find symbol\nsymbol  : class JCRSQLParser\nlocation: class org.apache.jackrabbit.core.query.sql.ASTContainsExpression\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTContainsExpression.java:[54,28] cannot find symbol\nsymbol  : class JCRSQLParserVisitor\nlocation: class org.apache.jackrabbit.core.query.sql.ASTContainsExpression\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/LuceneQueryBuilder.java:[44,56] cannot find symbol\nsymbol  : class QueryParser\nlocation: package org.apache.jackrabbit.core.query.lucene.fulltext\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/LuceneQueryBuilder.java:[45,56] cannot find symbol\nsymbol  : class ParseException\nlocation: package org.apache.jackrabbit.core.query.lucene.fulltext\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[55,42] cannot find symbol\nsymbol: class XPathVisitor\npublic class XPathQueryBuilder implements XPathVisitor, XPathTreeConstants {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[55,56] cannot find symbol\nsymbol: class XPathTreeConstants\npublic class XPathQueryBuilder implements XPathVisitor, XPathTreeConstants {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[23,35] cannot find symbol\nsymbol: class Node\npublic class SimpleNode implements Node {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[24,14] cannot find symbol\nsymbol  : class Node\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[25,14] cannot find symbol\nsymbol  : class Node\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[27,14] cannot find symbol\nsymbol  : class XPath\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[33,22] cannot find symbol\nsymbol  : class XPath\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[39,33] cannot find symbol\nsymbol  : class XPath\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[39,18] cannot find symbol\nsymbol  : class Node\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[49,29] cannot find symbol\nsymbol  : class Node\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[53,11] cannot find symbol\nsymbol  : class Node\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[57,28] cannot find symbol\nsymbol  : class Node\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[68,11] cannot find symbol\nsymbol  : class Node\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[79,28] cannot find symbol\nsymbol  : class XPathVisitor\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[86,33] cannot find symbol\nsymbol  : class XPathVisitor\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/SimpleNode.java:[132,29] cannot find symbol\nsymbol  : class Token\nlocation: class org.apache.jackrabbit.core.query.xpath.SimpleNode\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/JQOM2LuceneQueryBuilder.java:[53,56] cannot find symbol\nsymbol  : class QueryParser\nlocation: package org.apache.jackrabbit.core.query.lucene.fulltext\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/fulltext/FastCharStream.java:[30,45] cannot find symbol\nsymbol: class CharStream\npublic final class FastCharStream implements CharStream {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[60,43] cannot find symbol\nsymbol: class JCRSQLParserVisitor\npublic class JCRSQLQueryBuilder implements JCRSQLParserVisitor {\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[81,18] cannot find symbol\nsymbol  : class ASTQuery\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[121,31] cannot find symbol\nsymbol  : class ASTQuery\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[201,24] cannot find symbol\nsymbol  : class SimpleNode\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[206,24] cannot find symbol\nsymbol  : class ASTQuery\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[279,24] cannot find symbol\nsymbol  : class ASTSelectList\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[297,24] cannot find symbol\nsymbol  : class ASTFromClause\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[311,24] cannot find symbol\nsymbol  : class ASTWhereClause\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[447,24] cannot find symbol\nsymbol  : class ASTOrExpression\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[459,24] cannot find symbol\nsymbol  : class ASTAndExpression\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[469,24] cannot find symbol\nsymbol  : class ASTNotExpression\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[479,24] cannot find symbol\nsymbol  : class ASTBracketExpression\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[496,24] cannot find symbol\nsymbol  : class ASTOrderByClause\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[505,24] cannot find symbol\nsymbol  : class ASTOrderSpec\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[526,24] cannot find symbol\nsymbol  : class ASTAscendingOrderSpec\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[531,24] cannot find symbol\nsymbol  : class ASTDescendingOrderSpec\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[556,24] cannot find symbol\nsymbol  : class ASTLowerFunction\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[566,24] cannot find symbol\nsymbol  : class ASTUpperFunction\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/JCRSQLQueryBuilder.java:[576,24] cannot find symbol\nsymbol  : class ASTExcerptFunction\nlocation: class org.apache.jackrabbit.core.query.sql.JCRSQLQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTPredicate.java:[87,15] cannot find symbol\nsymbol  : variable super\nlocation: class org.apache.jackrabbit.core.query.sql.ASTPredicate\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTLiteral.java:[59,15] cannot find symbol\nsymbol  : variable super\nlocation: class org.apache.jackrabbit.core.query.sql.ASTLiteral\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/sql/ASTIdentifier.java:[47,15] cannot find symbol\nsymbol  : variable super\nlocation: class org.apache.jackrabbit.core.query.sql.ASTIdentifier\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/LuceneQueryBuilder.java:[376,12] cannot find symbol\nsymbol  : class QueryParser\nlocation: class org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/LuceneQueryBuilder.java:[376,37] cannot find symbol\nsymbol  : class QueryParser\nlocation: class org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/LuceneQueryBuilder.java:[378,31] cannot find symbol\nsymbol  : variable QueryParser\nlocation: class org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/LuceneQueryBuilder.java:[440,17] cannot find symbol\nsymbol  : class ParseException\nlocation: class org.apache.jackrabbit.core.query.lucene.LuceneQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[267,12] cannot find symbol\nsymbol  : class XPath\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[269,26] cannot find symbol\nsymbol  : class XPath\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[271,33] cannot find symbol\nsymbol  : class XPath\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[283,17] cannot find symbol\nsymbol  : class ParseException\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[356,17] cannot find symbol\nsymbol  : variable JJTXPATH2\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[359,17] cannot find symbol\nsymbol  : variable JJTROOT\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[360,17] cannot find symbol\nsymbol  : variable JJTROOTDESCENDANTS\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[368,17] cannot find symbol\nsymbol  : variable JJTSTEPEXPR\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[415,17] cannot find symbol\nsymbol  : variable JJTNAMETEST\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[429,17] cannot find symbol\nsymbol  : variable JJTELEMENTNAMEORWILDCARD\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[432,41] cannot find symbol\nsymbol  : variable JJTANYNAME\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[437,17] cannot find symbol\nsymbol  : variable JJTTEXTTEST\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[443,17] cannot find symbol\nsymbol  : variable JJTTYPENAME\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[456,17] cannot find symbol\nsymbol  : variable JJTOREXPR\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[463,17] cannot find symbol\nsymbol  : variable JJTANDEXPR\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[470,17] cannot find symbol\nsymbol  : variable JJTCOMPARISONEXPR\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[473,17] cannot find symbol\nsymbol  : variable JJTSTRINGLITERAL\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[474,17] cannot find symbol\nsymbol  : variable JJTDECIMALLITERAL\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[475,17] cannot find symbol\nsymbol  : variable JJTDOUBLELITERAL\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[476,17] cannot find symbol\nsymbol  : variable JJTINTEGERLITERAL\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[480,40] cannot find symbol\nsymbol  : variable JJTINTEGERLITERAL\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[490,17] cannot find symbol\nsymbol  : variable JJTUNARYMINUS\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[497,17] cannot find symbol\nsymbol  : variable JJTFUNCTIONCALL\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[500,17] cannot find symbol\nsymbol  : variable JJTORDERBYCLAUSE\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n\n/Users/adc/dev/jackrabbit/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/xpath/XPathQueryBuilder.java:[505,17] cannot find symbol\nsymbol  : variable JJTORDERMODIFIER\nlocation: class org.apache.jackrabbit.core.query.xpath.XPathQueryBuilder\n",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "BUG"
    },
    {
        "key": "JCR-1172",
        "summary": "Better MimeType Handling",
        "description": "After saving a Excel File through WebDAV the mimetype will be changed.\nThe mimetype for a Win2000 Exel File is application/vnd.ms-excel. This will be changed to application/msexcel.\nAlso problems makes the new office 07 format (docx,xlsx,pptx). They will also be changed to application/octet-stream (default mimetype).\nWe have a lot of file types that we store in jackrabbit that are not in the properties file (MSInfoPath-, OutlookMsg-, MsAccess-Files, ...)\nI think it will be better to let the mimetype property untouched if a mimetype is present so we must not put all the possible mimetypes in the property file.\n\nBR\nclaus",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-281",
        "summary": "textfilters module patch: Support for text extraction for HTML,XML and RTF files",
        "description": "This patch adds text extraction support form XML, RTF and HTML files.\n\nThe unique dependency is htmlparser library for handling HTML text extraction.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-772",
        "summary": "Merging between workspaces fails",
        "description": "I have setup 2 workspaces in Jackrabbit.  I have a preview and a production\nworkspace.  These workspaces keep a tree of menu nodes that can have content\nassociated to those menus.  Each node is of type nt:unstructured and has\nmixin types of versionable, lockable, and referenceable.\n\nIn our system you are only allowed to edit nodes in the preview workspace.\nSo what I do is when you go to edit a node we check it out, allow for edits,\nthen check it in.  This creates a new version on the node.  Then we merge\nthe node up to the production workspace.  All nodes in the production\nworkspace are always checked in and not locked.\n\nWhen I go to do a merge I run into problems when I try to merge a node that\nhas children.  Lets say I have node A with children B and C.  These all have\nthe same node types as stated above.  I make a change to a property in Node\nA in the preview workspace and now want to merge it into the production\nworkspace (where it exists already).  Here is the code that is run:\n\nNode destNode = destSession.getNodeByUUID(getUUID());\nNodeIterator ni = destNode.merge(\"preview\", true);\n\nNow this fails in the ItemImpl.internalRemove() method with a\nVersionException of cannot remove a child of a checked-in node.  Here is the\ntrace for the error:\nat org.apache.jackrabbit.core.ItemImpl.internalRemove(ItemImpl.java:848)\nat org.apache.jackrabbit.core.NodeImpl.internalMerge(NodeImpl.java:3693)\nat org.apache.jackrabbit.core.NodeImpl.internalMerge(NodeImpl.java:3587)\nat org.apache.jackrabbit.core.NodeImpl.merge(NodeImpl.java:3003)\n\nNow if I understand correctly when doing a merge the node that you are\ntrying to merge to needs to be older then the source node and the\ndestination node cannot be checked out (NodeImpl.doMergeTest() is where I\nfigured that out).  But then when I step through further in the merge in\nNodeImpl it gets all the nodes of the src node and retrieves the same\nchildren in the destination workspace and then tries to remove those\ndestination children but it can't remove those children b/c the parent node\n(which is node A in the production workspace) is not checked out, but\naccording to the mergeTest it can't be checked out or the merge won't even\nbegin.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-448",
        "summary": "Moving a node while index is merged leads to inconsistent index",
        "description": "The IndexMerger keeps track of nodes that are deleted from the index and applies that change also to the merged index, but if the same node is added again to the index during the merge process the index becomes inconsistent.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2632",
        "summary": "Concurrent Session.move() operations failure",
        "description": "Performing concurrent move operations may cause failures similar to the following:\n\njavax.jcr.RepositoryException: Unable to update item: node /\n       at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1147)\n       at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:920)\n       at ConcurrentMoveTest$1.execute(ConcurrentMoveTest.java:30)\n       at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:209)\n       at java.lang.Thread.run(Thread.java:637)\nCaused by: org.apache.jackrabbit.core.state.ItemStateException: Unable\nto resolve path for item: 79a0fbdb-49fd-4830-a842-5ab11842cd17\n       at org.apache.jackrabbit.core.observation.EventStateCollection.getPath(EventStateCollection.java:683)\n       at org.apache.jackrabbit.core.observation.EventStateCollection.createEventStates(EventStateCollection.java:268)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:702)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:1110)\n       at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:1140)\n       at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:351)\n       at org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:354)\n       at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:326)\n       at org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:328)\n       at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1141)\n       ... 4 more\nCaused by: javax.jcr.ItemNotFoundException: failed to build path of\n79a0fbdb-49fd-4830-a842-5ab11842cd17:\n826f0c19-9956-402a-9c0d-93089eedcc1c has no child entry for\n79a0fbdb-49fd-4830-a842-5ab11842cd17\n       at org.apache.jackrabbit.core.HierarchyManagerImpl.buildPath(HierarchyManagerImpl.java:291)\n       at org.apache.jackrabbit.core.CachingHierarchyManager.buildPath(CachingHierarchyManager.java:198)\n       at org.apache.jackrabbit.core.HierarchyManagerImpl.getPath(HierarchyManagerImpl.java:395)\n       at org.apache.jackrabbit.core.CachingHierarchyManager.getPath(CachingHierarchyManager.java:232)\n       at org.apache.jackrabbit.core.observation.EventStateCollection.getPath(EventStateCollection.java:678)\n       ... 13 more\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2969",
        "summary": "FileDataStore garbage collection can throw a NullPointerException if there is I/O problem",
        "description": "The FileDataStore can throw a NPE when doing garbage collection, if there is file I/O problem (for example an access rights problem). The reason is that it doesn't check if File.list / listFiles returns null. Stack trace:\n\nException in thread \"Thread-461\" java.lang.NullPointerException\n\tat org.apache.jackrabbit.core.data.FileDataStore.deleteOlderRecursive(FileDataStore.java:334)\n\tat org.apache.jackrabbit.core.data.FileDataStore.deleteOlderRecursive(FileDataStore.java:328)\n\tat org.apache.jackrabbit.core.data.FileDataStore.deleteOlderRecursive(FileDataStore.java:328)\n\tat org.apache.jackrabbit.core.data.FileDataStore.deleteOlderRecursive(FileDataStore.java:328)\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-223",
        "summary": "fix jackrabbit groupId",
        "description": "Actually the groupid used in maven project.xml is simply \"jackrabbit\".\nHowever, the new naming policy adopted by maven requires the groupid to mirror the main package name, so it should be changed to \"org.apache.jackrabbit\".\nProbably this could be a good moment to fix it, after the recent merge and modification of artifact ids.\n\nA note about the new policy for groupid can be found in http://maven.apache.org/reference/repository-upload.html",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2018",
        "summary": "Jcr-Remoting: PathNotFoundException if item name ends with .json",
        "description": "the jcr-remoting-servlet contains the following commented issue:\n\n    * TODO: TOBEFIXED will not behave properly if resource path (i.e. item name)\n    * TODO  ends with .json extension and/or contains a depth-selector pattern.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1004",
        "summary": "SPI: Add RepositoryService.getQNodeTypeDefinition",
        "description": "Finding of the F2F (2/3 July)\n\nsimilar to recent modifications to the retrieval of name spaces the node type management should be changed in order to only retrieve the complete set of node types on demand. Otherwise single node type definitions should be retrieved as required.\nTo achieve this we agreed to add RepositoryService.getQNodeTypeDefinition",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-911",
        "summary": "Remove sanityCheck() from ItemImpl.getSession()",
        "description": "The following code causes an InvalidItemStateException to be thrown for no good reason:\n\n    Property property = ...;\n    property.setValue((Value) null);\n    property.getSession();\n\nThere are cases (I'm looking at one right now) where it's good to be able to access the session of an Item even if it has already been invalidated.\n\nThe simple fix is to remove the sanityCheck() call from ItemImpl.getSession(). I'll do that unless someone has a good reason why the sanity check should be kept.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2260",
        "summary": "MemoryFileSystem.deleteFolder deletes all folders starting with this name ",
        "description": "MemoryFileSystem.deleteFolder deletes not only the folder requested but all folders that start with the given name.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1051",
        "summary": "MatchAllScorer calculateDocFilter() bug",
        "description": "In MatchAllScorer.calculateDocFilter(), When you have just two nodes, with different properties, like \"myprop\" and \"myprop2\", and you have an xpath String xpath = \"//*[@myprop], you get both nodes back (to be precise, you'll get every node that has a property that startswith \"myprop\")\n\n\nYou can reproduce it by changing the SimpleQueryTest.testIsNotNull() a little:\n\nChange \n\nbar.setProperty(\"text\", \"the quick brown fox jumps over the lazy dog.\"); \n\nto\n\nbar.setProperty(\"mytextwhichstartswithmytext\", \"the quick brown fox jumps over the lazy dog.\");\n\nNow the test with xpath = \"//*[@jcr:primaryType='nt:unstructured' and @mytext]\"; fails because 2 results. I did test for the trunk and tag 1.3.1 and both have the same problem. I have attached MatchAllScorer.java.patch in this mail, or should I create a JIRA issue for this? \n\nFurthermore I would like to discuss a different implementation for the MatchAllScorer, because IMHO the current calculateDocFilter() becomes slow pretty fast (see bottom email the code part i am referring to: if you have 100.000 docs with \"mytext\" property, and you query  [@mytext] the loop below is executed at least 100.000 times). I think it might be out of scope for the user-list, or is the user-list the place to discuss something like this? \n\n-----------------------------------------------------------------------\n\nTermEnum terms = reader.terms(new Term(FieldNames.PROPERTIES, field));\n        try {\n            TermDocs docs = reader.termDocs();\n            try {\n                while (terms.term() != null\n                        && terms.term().field() == FieldNames.PROPERTIES\n                        && terms.term().text().startsWith(field)) {\n                    docs.seek(terms);\n                    while (docs.next()) {\n                        docFilter.set(docs.doc());\n                    }\n                    terms.next();\n                }\n            } finally {\n                docs.close();\n            }\n        } finally {\n            terms.close();\n        }\n\n-----------------------------------------------------------------------\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1946",
        "summary": "JCAResourceAdapter must implement Serializable",
        "description": "We are running Weblogic 10.0 servers in cluster environment.   When deploying the rar, we always get this warning from weblogic stdout.log: \n\n<Jan 15, 2009 2:42:10 AM PST> <Warning> <Connector> <BEA-190155> <Compliance checking/validation of the resource adapter /home/user/jackrabbit_rar/jackrabbit-jca-1.5.0.rar resulted in the following warnings:  The ra.xml <resourceadapter-class> class 'org.apache.jackrabbit.jca.JCAResourceAdapter' should implement java.io.Serializable but does not.> \n\nWhen trying to do the JNDI lookup the repository, we got the error \"No Object found: jackrabbit|null\".   The jackrabbit entry in the jndi tree is visible only as a javax.naming.reference and not as the JCARepositoryHandle due to the above warning.  Due to that, we can't deploy jackrabbit-jca in Test/Production environment.  \n\nI'm no expert in JCA, but feel it is fairly easy to implement Serializable for  JCAResourceAdapter.  Please help us out.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1541",
        "summary": "Evict fixed NodePropBundle from cache",
        "description": "The BundleDbPersistenceManager only stores back fixed NodePropBundles in checkConsistency() but does not invalidate the cache, which may potentially contain a cached version of a NodePropBundle.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2380",
        "summary": "NPE in ObservationManagerImpl.getRegisteredEventListeners() during shutdown after broken startup",
        "description": "See JCR-2378. The variable \"dispatcher\" is passed as null in the constructor.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1394",
        "summary": "FileDataStore Garbage Collector and empty directories",
        "description": "When the org.apache.jackrabbit.core.data.GarbageCollector is called for a FileDataStore the file objects are correctly deleted.\nBut the (sub)directories aren't removed.\nIn time this will result in a huge tree of unused empty directories\n\nI've created a small chance in method FileDataStore.deleteOlderRecursive()\nIt will remove a directory when it hasn't any files entries. Please note that currently the file objects are stored three levels deep, so it\nwill take three gc calls remove all directories. Which I think is no problem because the currently implementation is lightweighted.\n\n>>>>> CURRENT FileDataStore.java\n\n    private int deleteOlderRecursive(File file, long min) {\n        int count = 0;\n        if (file.isFile() && file.exists() && file.canWrite()) {\n            if (file.lastModified() < min) {\n                DataIdentifier id = new DataIdentifier(file.getName());\n                if (!inUse.containsKey(id)) {\n                    file.delete();\n                    count++;\n                }\n            }\n        } else if (file.isDirectory()) {\n            File[] list = file.listFiles();\n            for (int i = 0; i < list.length; i++) {\n                count += deleteOlderRecursive(list[i], min);\n            }\n        }\n        return count;\n    }\n\n>>>>>>> NEW\n\n    private int deleteOlderRecursive(File file, long min) {\n        int count = 0;\n        if (file.isFile() && file.exists() && file.canWrite()) {\n            if (file.lastModified() < min) {\n                DataIdentifier id = new DataIdentifier(file.getName());\n                if (!inUse.containsKey(id)) {\n                    file.delete();\n                    count++;\n                }\n            }\n        } else if (file.isDirectory()) {\n            File[] list = file.listFiles();\n            if (list.length==0) {\n              file.delete();\n            } else {\n              for (int i = 0; i < list.length; i++) {\n                count += deleteOlderRecursive(list[i], min);\n              }\n            }\n        }\n        return count;\n    }\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-104",
        "summary": "Contrib/Jcr-Server: Improve package structure",
        "description": "+ org\n  + apache\n    + jackrabbit\n       + webdav\n         + <dav-specific packages as currently present>\n         + spi_jcr (formerly spi)\n         + spi_simple (formerly dav-package below server/simple        \n         + client (webdav-client lib)\n\n       + server\n         + jcr (jcr-server-classes formerly below server)\n         + simple\n   \n       + client\n         + jcr (client-side jcr impl. without dav-dependency)\n    \n         \n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3081",
        "summary": "Add UserManager#getAuthorizableByPath(String) for symmetry with JCR-3037",
        "description": "JCR-3037 added Authorizable#getPath. I would suggest to also add UserManager#getAuthorizableByPath that was symmetric to Authorizable#getPath",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2657",
        "summary": "DefaultAccessManager#hasPrivileges(String,Set,Privilege[]) doesn't close compiled permissions",
        "description": "DefaultAccessManager#hasPrivileges(String,Set,Privilege[]) retrieves the compiled permissions for the specified set of principals\nfrom the ac provider but omit the CompiledPermissions#close() call before returning.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2539",
        "summary": "spi2dav: Observation's user data not property handled",
        "description": "org.apache.jackrabbit.test.api.observation#GetUserDataTest still fail in the setup jcr2spi - spi2dav(ex) - jcr-server.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2955",
        "summary": "Use GrowingLRUMap in CachingEntryCollector",
        "description": "in order to allow for more flexibility of the cache size in caching entry collection, i would like to use the GrowingLRUMap.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1979",
        "summary": "Deadlock  on concurrent read & transactional write operations",
        "description": "Isuue has been introduced by resolving JCR-1755 (Transaction-safe versioning). This fixed changed sequence of commits, but at the same time order of acquiring locks has been disturbed.\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2824",
        "summary": "Add RepositoryException to JackrabbitAccessControlList#getRestrictionNames and #getRestrictionType",
        "description": "Throughout the JCR and Jackrabbit API methods that include name processing are define to throw RepositoryException in case of \nan error related to name processing (due to lack of a more specific exception in the javax.jcr package space).\n\nUnfortunately, I forgot those in JackrabbitAccessControlList and JackrabbitAccessControlEntry. While the latter has already been addressed for the 2.2 release,\nI would like to fix the JackrabbitAccessControlList interface as well (and subsequently also fix the implementations that currently do not properly cope with \nnames).\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "BUG"
    },
    {
        "key": "JCR-1766",
        "summary": "Bundle binding deserialization problem",
        "description": "I'm trying to upgrade from 1.3.x to jackrabbit 1.4.x (branch)  and have problems with existing repostories (probaly the same issue is with 1.5.x)\n\nCaused by: org.apache.jackrabbit.core.state.ItemStateException: failed to read bundle: deadbeef-face-babe-cafe-babecafebabe: java.lang.IllegalArgumentException: invalid namespaceURI specified\n at org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.loadBundle(BundleDbPersistenceManager.java:1229)\n at org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.loadBundle(BundleDbPersistenceManager.java:1161)\n\nIt looks that issue was introduced by resolving JCR-1632",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2713",
        "summary": "UserManagement: Don't read cached memberships if session has pending (group) changes",
        "description": "for backwards compatibility reasons reading group membership should not access the overall cache in case of pending (group) change.\nthe current implememation (always reading from cache) caused a regression in test-case we have @day that relied on accurate group\nmembership information with having unsaved group-member changes.",
        "label": "NUG",
        "classified": "BACKPORT",
        "type": "BUG"
    },
    {
        "key": "JCR-1871",
        "summary": "jcr2spi: use jcr names and path for log and exception message",
        "description": "in a couple of places jcr2spi adds the string representation of Path, Name and ItemId to the exception/error message. it would be convenient to convert them to jcr names and jcr path where ever possible.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1106",
        "summary": "Add simple query method to ObjectContentManager",
        "description": "As discussed in [1], I suggest a new method \n\n    ObejctContentManager.getObjectIterator(String query, String language)\n\nto easily query the repository for objects using a predefined query. (I chose getObjectIterator instead of getObjects as I intend the method to return an Iterator and not a Collection)\n\n[1] http://www.mail-archive.com/dev%40jackrabbit.apache.org/msg07475.html",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2698",
        "summary": "Consolidate type safe wrappers for commons-collection classes",
        "description": "Various places define their own type safe wrappers for classes from commons-collections (i.e. FilterIterator, TransformIterator and the like). I would like to consolidate them into one single place. ",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-330",
        "summary": "Include the README file in the generated jar files",
        "description": "The Incubator would prefer if we had the incubation notice included in the binary jar files we release. It should be a simple Maven configuration change to get the README.txt file included in the binary jars.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2326",
        "summary": "some jcr-client tests fail if a server runs on localhost:80 ",
        "description": "This is caused by RepositoryFactoryImplTest.testGetSpi2davRepository() and probably RepositoryFactoryImplTest.testGetSpi2davexRepository(). \n\nTo fix this the tests should set up the required webDav servers for the test runs. Currently the tests just try to connect to localhost:80 expecting the connection to fail in a specific way. ",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1561",
        "summary": "New MsOutlook Message Extractor",
        "description": "Sinse we are using poi 3.0.2 it will be useful to have a outlook message extractor",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2369",
        "summary": "Problem importing node with binary property in a repository configured with datastore",
        "description": "Using the importXML method of workspace to import some node containing binary properties the nodes are imported correctly and the value of the binary data property is imported\nHowever the binary data goes to the db (persistenceManager) an not to the datastore.\n\nCreating a new node of the same type using the api, the binary data go to the datastore.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2013",
        "summary": "IOUtils - getCreated(...) - SimpleDateFormat is not threadsafe",
        "description": "SimpleDateFormat is not threadsafe (http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4146524)\nSee exception in attachment.\nIMHO it will be enough to synchronize 'format' method in HttpDateFormat class.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-251",
        "summary": "NullPointerException in VirtualNodeTypeStateManager.nodeTypeRegistered",
        "description": "I am working on a custom persistence manager which requires an additional node type being registered. For performance reasons, the existence of this node type is verified during PersistenceManager.init.\n\nUnfortunately this does not seem to work as the VirtualNodeTypeStateManager is not prepared to handle this situation at that point in time - the systemSession field seems to still be null.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1832",
        "summary": "Missing log4j.properties file",
        "description": "The log4j.properties file is missing in the test resources.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2568",
        "summary": "extract test content loading from JackrabbitRepositoryStub",
        "description": "discussed here: http://markmail.org/message/vl5ldnfbocccccxw",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1791",
        "summary": "New utility: Journal walker for journal files",
        "description": "Given the cluster record access provided by JCR-1789, add a journal walker utiltity that provides descriptive information about the contents of journal records.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2034",
        "summary": "Add an option so skip the \"checkSchema\" methods",
        "description": "Sometimes the \"checkSchema\" methods in the various components (DB filesystem, DB persistence manager, DB journal) fail to detect that the required tables already exist with as result that the startup  fails. (See the mail thread on the dev list: http://jackrabbit.markmail.org/message/jtq2sqis2aceh7ro).\nAn option to just skip the checkSchema methods on startup would solve this issue.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1000",
        "summary": "JCR2SPI: remove duplicate item states",
        "description": "the original approach with duplicate item state objects connected to each is not required any more \nand can be simplified.",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-67",
        "summary": "Node.canAddMixin(String)",
        "description": "after the spec this method must return false if the node is locked.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-270",
        "summary": "Importer drops jcr:xmlcharacters fields after a large jcr:xmlcharacters entry",
        "description": "If you have an XML node as follows:\n\n<a>\n[lots and lots of data]\n</a>\n\nThis should translate into\n\nNode: a\n +- Node: jcr:xmltext\n   +- Property: jcr:xmlcharacters = [lots and lots of data]\n\nInstead, the following things happen:\n- There is no node jcr:xmltext\n- If the node a has child nodes, they also lose the jcr:xmltext node\n- Any nodes on the same level after node a also lose the jcr:xmltext node\n- Nodes that come after a, but are on a higher level, have correct jcr:xmltext \nnodes\n\n(I've used some 100+k of data, namely a base64 encoded picture)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-498",
        "summary": "TCK: ImpersonateTest#testImpersonate should allow LoginException",
        "description": "JSR-170 allows Session.impersonate to throw LoginException if the session lacks permission to impersonate another user.  Some repositories may not allow any session to impersonate another user, in which case this test would fail.\n\nProposal: catch and consume LoginException.\n\n--- ImpersonateTest.java        (revision 422074)\n+++ ImpersonateTest.java        (working copy)\n@@ -17,11 +17,13 @@\n package org.apache.jackrabbit.test.api;\n  \n import org.apache.jackrabbit.test.AbstractJCRTest;\n+import org.apache.jackrabbit.test.NotExecutableException;\n  \n import javax.jcr.Session;\n import javax.jcr.Credentials;\n import javax.jcr.NodeIterator;\n import javax.jcr.Node;\n+import javax.jcr.LoginException;\n import java.security.AccessControlException;\n  \n /**\n@@ -40,7 +42,14 @@\n      */\n     public void testImpersonate() throws Exception {\n         // impersonate to read-only user\n-        Session session = superuser.impersonate(helper.getReadOnlyCredentials());\n+        Session session = null;\n+\n+        try {\n+            session = superuser.impersonate(helper.getReadOnlyCredentials());\n+        }\n+        catch (LoginException e) {\n+          throw new NotExecutableException(\"impersonate threw LoginException\");\n+        }\n  \n         // get a path to test the permissions on\n         String thePath = \"\";\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1147",
        "summary": "spi2jcr: RepositoryServiceImpl.getRootId returns bad NodeId ",
        "description": "I think org.apache.jackrabbit.spi2jcr.RepositoryServiceImpl.getRootId() should not return getIdFactory().createNodeId((String) null, Path.ROOT). Rather should it do a round trip to the wrapped repository and return a UUID based NodeId if the root node of the wrapped repository is mix:referenceable.\n\nThe javadoc reads: \"If the root node can be identified with a unique ID the returned NodeId simply has a uniqueID part and the path part is null. If the root node cannot be identified with a unique ID the uniqueID part is null and the path part will be set to \"/\".\"",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-503",
        "summary": "TCK: SetValueDateTest compares Calendar objects",
        "description": "SetValueDateTest#testDateSession\nSetValueDateTest#testDateParent\n\nTests compare Calendar objects.  Calendar.equals(Object) is a stronger test than JSR-170 specifies for Value.equals(Object), leading to false failures.  For the purpose of these tests, even Value.equals(Object) is too strong an equality test, since some repositories may normalize date/time values across a save/read roundtrip (for example, converting \"Z\" to \"+00:00\", or adding/removing trailing zeros in fractional seconds).\n\nProposal: compare the getTimeInMillis() values.\n\n--- SetValueDateTest.java       (revision 422074)\n+++ SetValueDateTest.java       (working copy)\n@@ -79,7 +80,8 @@\n     public void testDateSession() throws RepositoryException {\n         property1.setValue(value);\n         superuser.save();\n-        assertEquals(\"Date node property not saved\", value.getDate(), property1.getValue().getDate());\n+        assertEquals(\"Date node property not saved\",\n+          value.getDate().getTimeInMillis(), property1.getDate().getTimeInMillis());\n     }\n  \n     /**\n@@ -89,7 +91,8 @@\n     public void testDateParent() throws RepositoryException {\n         property1.setValue(value.getDate());\n         node.save();\n-        assertEquals(\"Date node property not saved\", value.getDate(), property1.getValue().getDate());\n+        assertEquals(\"Date node property not saved\",\n+          value.getDate().getTimeInMillis(), property1.getDate().getTimeInMillis());\n     }\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-514",
        "summary": "TCK: NodeOrderableChildNodesTest tests node order even if node type doesn't support child node ordering",
        "description": "NodeOrderableChildNodesTest# testOrderBeforeUnsupportedRepositoryOperationException\n\nThis test calls prepareTest, which requires getNodes() to return the child nodes in the order added, even if the node type doesn't support child node ordering.  JSR-170 (Section 4.4.2) imposes no such requirement.\n\nProposal: do not check child node order in this test case.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-233",
        "summary": "repository lock file not removed without a clean shutdown",
        "description": "actually when a repository is loaded a \".lock\" file is created. This file is removed only after a clean shutdown but, if a jackrabbit instance has been killed, you have to manually delete the file in order to load the repository again, also if there was no live instance of jackrabbit that was using it.\n\nThe problem comes from the fact that the simple presence of the .lock file is used to indicate a live instance.\nI suggest replacing this behavior using this method (used for example by eclipse when opening workspaces):\n- when an instance is loaded create a \".lock\" file and open it with exclusive access\n- when a new instance is started try to delete an eventual .lock file. Only if the file can't be deleted because in use assume that another jackrabbit instance is running.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-23",
        "summary": "PersistentVersionManager contains grow-only cache",
        "description": "The PersistentVersionManager class contains a private HashMap \"histories\" which contains references to InternalVersionHistory objects. The bad thing about this cache is, that it only grows, but is not being managed to forget about \"unused\" histories. This is even badder, as the class has support for on-demand loading of version histories.\n\nExample: A repository which is filled with 9350 nodes and 52813 properties grows this histories map to 1'222'030 (!) entries. In this concrete case, the VM allocates 213MB to the heap of which 41MB is referenced by the PersistentVersionManager.histories map.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2859",
        "summary": "Make open scoped locks recoverable",
        "description": "The lock tokens for open scoped locks are currently tied to the session which created the lock. If the session dies (for whatever reason) there is no way to recover the lock and unlock the node.\nThere is a theoretical way of adding the lock token to another session, but in most cases the lock token is not available.\n\nFortunately, the spec allows to relax this behaviour and I think it would make sense to allow all sessions from the same user to unlock the node - this is still in compliance with the spec but would make unlocked locked nodes possible in a programmatic way.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1863",
        "summary": "Create jackrabbit-parent",
        "description": "Currently the Jackrabbit components use the top-level multi-module POM as their parent POM for sharing many of the common build settings. However, with the planned mixed component release model for 1.5.x we need to be able to increase the version number of the top-level POM without affecting individual components. Thus it is better if we move the shared settings to an explicit jackrabbit-parent component and keep the top-level POM simply as the multi-module container.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-61",
        "summary": "Docview import fails, if attribute and childelem have same name",
        "description": "docimport fails, if element has same name as one of the attributes of its parent element.\n\nexample:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<feature plugin=\"foobar\">\n    <plugin>test</plugin>\n</feature>\n\nimporting this results in a ItemExistsException: 'plugin'",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1247",
        "summary": "Add Warnlog on Extraction Failure",
        "description": "It will be fine to have a feedback if a exception occurs in the TextExtractors.\nAt the moment only a empty StringReader will be returned.\nWe had the issue that we updated the content and in the textextractor a exception occured\nso the index was not updated and the document was searchable by its old content.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2769",
        "summary": "Avoid String.intern() for UUID terms",
        "description": "Creating Lucene terms is somewhat expensive, because it will usually call String.intern() on the field String. Jackrabbit uses UUID terms quite heavily to resolve hierarchy constraints. Lucene also provides a factory method on a Term that will create a new term instance with a given value and the same field name, avoiding the String.intern(). Jackrabbit should use the factory method whenever it creates a term for a UUID field.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1273",
        "summary": "Unnecessary parsing of Name value",
        "description": "InternalValue.toJCRValue(NamePathResolver) formats the Name value and constructs a NameValue using the formatted String. The implementation of NameValue.valueOf(String) again checks the format, which is quite expensive and unnecessary in this case.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2002",
        "summary": "Support system property to define the DefaultTransactionTimeout for a XASession",
        "description": "It should be possible to define the DefaultTransactionTimeout for a XASession by a SystemProperty",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1994",
        "summary": "ExportSysViewTest fails with: System property org.xml.sax.driver not specified",
        "description": "The ExportSysViewTest class uses the XMLReaderFactory.createXMLReader() method that depends on the system property \"org.xml.sax.driver\" being specified. Apparently using a TransformerFactory works around this issue in some way, as the problem only appeared once we changed the XML export feature to use a custom serializer class instead of a JAXP Transformer for serialization (see JCR-1952).\n\nThe current workaround is to explicitly force a Transformer to be loaded, but we really should fix the cause of this issue for example by replacing the XMLReader instance with a SAXParser.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-824",
        "summary": "Problems with File Copy using WebDAV",
        "description": "When i make a copy of files from one workspace to other (CTRL-C -> CTRL-V). The file isnt copied, but the original file is deleted.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3262",
        "summary": "Oracle JDBC Class Cast Exception",
        "description": "When utilizing the OraclePersistenceManager (package org.apache.jackrabbit.core.persistence.db) (I realize this is marked as deprecated) we noticed during our migration from Jackrabbit 1.6.1 to 2.2.10/11 that when starting the application server an error message is displayed to us that indicates that the Connection object passed to the createTemporaryBlob method of the BLOB class can't be cast to oracle.jdbc.OracleConnection\n\nHere the interesting lines from our log:\n2012-03-15 17:15:47,926 ERROR [org.apache.jackrabbit.core.persistence.db.OraclePersistenceManager] failed to write node state: cafebabe-cafe-babe-cafe-babecafebabe\njava.lang.ClassCastException: org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper cannot be cast to oracle.jdbc.OracleConnection\n\tat oracle.sql.BLOB.createTemporary(BLOB.java:708)\n\tat org.apache.jackrabbit.core.persistence.db.OraclePersistenceManager.createTemporaryBlob(OraclePersistenceManager.java:375)\n\nI want to highlight at this point that the do not see the issue when using the Oracle Bundled persistence manager, however due to the fact that we haven't used the bundled version in the past we have a lot of customers with repo layouts that can not be used by the bundled persistence manager - we ran some tests and noticed that the consistency check fails.\n-> At the moment there is no good upgrade path to move a repo to the bundled structure, the paths provided thus far are shaky at best.\n\nI did find a solution to the problem that has shown no issues thus far and wanted to share this with you:\n\nIt is a one line change that can be made before the wrapped connection is passed to the Oracle driver:\norg.apache.jackrabbit.core.util.db.ConnectionFactory.unwrap(con);\n\nThis then solves the problem, I also wanted to share that we are using an XA datasource.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-298",
        "summary": "missing blob.remove in Berkeley DB persistance manager",
        "description": "org/apache/jackrabbit/core/state/bdb/BerkeleyDBPersistenceManager.destroy(PropertyState state) does not remove binary file from\nthe BLOBStore (filesystem impl)\n\n\n\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "BUG"
    },
    {
        "key": "JCR-702",
        "summary": "Allow database as backend for clustering",
        "description": "Currently, clustering (see JCR-623) uses a shared file system folder in order to store modifications and synchronize all nodes in the cluster. Alternatively, a database backend should be available.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-341",
        "summary": "Jcr-Server: registration of ReportTypes fails",
        "description": "Registration of ReportType(s) using \n\nReportType.register(String localName, Namespace namespace, Class reportClass)  [ReportType]\n\nfails due to wrong evaluation of interfaces implemented by the given class object.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3101",
        "summary": "recovery tool does not recover when version history can be instantiated, but root version can not",
        "description": "JCR-2551 introduced a recovery mode which tries to instantiate the version history, and if this fails, disconnects the VH (version history) and makes the node unversioned.\n\nHowever, it appears it can happen that the persistence is damaged such as getting the VH does indeed work, but subsequent operations fail due to other problems. One problem that has been seen is a missing frozenNode property of the root version (or a missing frozenNode itself).\n\nAs a quick fix, we may want to change the checker so that it actually also tries to get the rootVersion and it's frozenNode. Long term, depending on how frequent this problem is, we may have to think about a less drastic recovery than disconnecting the VH.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2378",
        "summary": "Avoid exceptions thrown in finalize handler of RepositoryImpl constructor",
        "description": "If an exception happens during initialization of the repository, it might be overlayed by an exception thrown in the finalize handler of the RepositoryImpl constructor (see line 382 ff in [1]). The latter exception wins and the original exception is lost (if you don't have a log). This makes it hard to figure out the real problem.\n\nThis problem is actually a bit self-enforcing: if something goes wrong during startup, the code in the shutdown() method that is called is actually very prone to fail as it might not expect such a broken-startup state. In my case the overlaying NPE happened in ObservationManagerImpl.getRegisteredEventListeners, where this.dispatcher was unexpectedly null [2].\n\nI think both places should be fixed (NPE guard in ObservationManagerImpl constructor for \"dispatcher\") and a try/catch block in the finalizer, just logging the exception:\n\n    } finally {\n        if (!succeeded) {\n            try {\n                // repository startup failed, clean up...\n                shutdown();\n            } catch (Throwable t) {\n                // shutdown() likely to fail now, as startup was broken...\n                log.error(\"In addition to startup fail, another problem occurred while shutting down the repository again.\", e);\n            }\n        }\n    }\n\n\n[1] http://svn.apache.org/viewvc/jackrabbit/trunk/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/RepositoryImpl.java?view=markup\n\n[2] Overlaying exception's stacktrace:\nCaused by: java.lang.NullPointerException\n\tat org.apache.jackrabbit.core.observation.ObservationManagerImpl.getRegisteredEventListeners(ObservationManagerImpl.java:143)\n\tat org.apache.jackrabbit.core.SessionImpl.removeRegisteredEventListeners(SessionImpl.java:1190)\n\tat org.apache.jackrabbit.core.SessionImpl.logout(SessionImpl.java:1215)\n\tat org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.doDispose(RepositoryImpl.java:2153)\n\tat com.day.crx.core.CRXRepositoryImpl$CRXWorkspaceInfo.doDispose(CRXRepositoryImpl.java:1095)\n\tat org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.dispose(RepositoryImpl.java:2108)\n\tat org.apache.jackrabbit.core.RepositoryImpl.doShutdown(RepositoryImpl.java:1146)\n\tat com.day.crx.core.CRXRepositoryImpl.doShutdown(CRXRepositoryImpl.java:845)\n\tat org.apache.jackrabbit.core.RepositoryImpl.shutdown(RepositoryImpl.java:1098)\n\tat org.apache.jackrabbit.core.RepositoryImpl.<init>(RepositoryImpl.java:387)\n\tat com.day.crx.core.CRXRepositoryImpl.<init>(CRXRepositoryImpl.java:201)\n\tat com.day.crx.core.CRXRepositoryImpl.create(CRXRepositoryImpl.java:190)\n\t... 28 more\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-742",
        "summary": "Abstract JCR base classes",
        "description": "Implement and use a set of abstract AbstractSession, AbstractItem, etc. classes that implement as much of the respective JCR interfaces using nothing else but calls to other JCR methods. These would be just like the AbstractMap, etc. classes in java.util.\n\n(See the related discussion at http://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/10583)",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1461",
        "summary": "Deadlock on concurrent commit/checkin operations",
        "description": "Running concurrently jackrabbit transactions including checkin operations leads to deadlock.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-310",
        "summary": "XercesImpl is missing in WebDav contrib project",
        "description": "$ /usr/local/maven/bin/maven\n __  __\n|  \\/  |__ _Apache__ ___\n| |\\/| / _` \\ V / -_) ' \\  ~ intelligent projects ~\n|_|  |_\\__,_|\\_/\\___|_||_|  v. 1.0.2\n\nbuild:start:\n\nmultiproject:install:\nmultiproject:projects-init:\n    [echo] Gathering project list\nStarting the reactor...\nOur processing order:\nJCRWebdavServer Webdav Library\nJCRWebdavServer Server Library\nJCRWebdavServer Client Library\nJCRWebdavServer WebApplication\n+----------------------------------------\n| Gathering project list JCRWebdavServer Webdav Library\n| Memory: 3M/4M\n+----------------------------------------\n+----------------------------------------\n| Gathering project list JCRWebdavServer Server Library\n| Memory: 3M/4M\n+----------------------------------------\n+----------------------------------------\n| Gathering project list JCRWebdavServer Client Library\n| Memory: 3M/4M\n+----------------------------------------\n+----------------------------------------\n| Gathering project list JCRWebdavServer WebApplication\n| Memory: 3M/4M\n+----------------------------------------\nStarting the reactor...\nOur processing order:\nJCRWebdavServer Webdav Library\nJCRWebdavServer Server Library\nJCRWebdavServer Client Library\nJCRWebdavServer WebApplication\n+----------------------------------------\n| Executing multiproject:install-callback JCRWebdavServer Webdav Library\n| Memory: 3M/4M\n+----------------------------------------\nAttempting to download jackrabbit-commons-1.0-SNAPSHOT.jar.\nResponse content length is not known\nArtifact /org.apache.jackrabbit/jars/jackrabbit-commons-1.0-SNAPSHOT.jar doesn't exists in remote repository, but it exists locally\n\nmultiproject:goal:\nbuild:start:\n\nmultiproject:install-callback:\n    [echo] Running jar:install for JCRWebdavServer Webdav Library\njava:prepare-filesystem:\n\njava:compile:\n    [echo] Compiling to /home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/target/classes\n    [javac] Compiling 109 source files to /home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/target/classes\n/home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/src/java/org/apache/jackrabbit/webdav/WebdavResponseImpl.java:26: package org.apache.xml.serialize does not exist\nimport org.apache.xml.serialize.OutputFormat;\n                                ^\n/home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/src/java/org/apache/jackrabbit/webdav/WebdavResponseImpl.java:27: package org.apache.xml.serialize does not exist\nimport org.apache.xml.serialize.XMLSerializer;\n                                ^\n/home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/src/java/org/apache/jackrabbit/webdav/WebdavResponseImpl.java:149: cannot resolve symbol\nsymbol  : class OutputFormat \nlocation: class org.apache.jackrabbit.webdav.WebdavResponseImpl\n                OutputFormat format = new OutputFormat(\"xml\", \"UTF-8\", true);\n                ^\n/home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/src/java/org/apache/jackrabbit/webdav/WebdavResponseImpl.java:149: cannot resolve symbol\nsymbol  : class OutputFormat \nlocation: class org.apache.jackrabbit.webdav.WebdavResponseImpl\n                OutputFormat format = new OutputFormat(\"xml\", \"UTF-8\", true);\n                                          ^\n/home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/src/java/org/apache/jackrabbit/webdav/WebdavResponseImpl.java:150: cannot resolve symbol\nsymbol  : class XMLSerializer \nlocation: class org.apache.jackrabbit.webdav.WebdavResponseImpl\n                XMLSerializer serializer = new XMLSerializer(out, format);\n                ^\n/home/jeremi/src/jackrabbit/trunk/contrib/jcr-server/webdav/src/java/org/apache/jackrabbit/webdav/WebdavResponseImpl.java:150: cannot resolve symbol\nsymbol  : class XMLSerializer \nlocation: class org.apache.jackrabbit.webdav.WebdavResponseImpl\n                XMLSerializer serializer = new XMLSerializer(out, format);\n                                               ^\nNote: Some input files use or override a deprecated API.\nNote: Recompile with -deprecation for details.\n6 errors\n\nBUILD FAILED\nFile...... /home/jeremi/.maven/cache/maven-multiproject-plugin-1.3.1/plugin.jelly\nElement... maven:reactor\nLine...... 217\nColumn.... -1\nUnable to obtain goal [multiproject:install-callback] -- /home/jeremi/.maven/cache/maven-java-plugin-1.5/plugin.jelly:63:-1: <ant:javac> Compile failed; see the compiler error output for details.\nTotal time: 8 seconds\nFinished at: Fri Jan 27 07:14:37 CET 2006\n\n$",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2028",
        "summary": "JSR 283: JCR Path",
        "description": "with jsr 283 the jcr path is defined to consist of a combination of the following segments\n\n\u2022\ta name segment, (J, I), where J is a JCR name and I is an integer index (I \u2265 1).\n\u2022\tan identifier segment, U, where U is a JCR identifier.\n\u2022\tthe root segment.\n\u2022\tthe self segment.\n\u2022\tthe parent segment.\n\n-> the name segment can be in extended or qualified form -> see issue JCR-1712\n-> the identifier segment is new for jsr283 and always identifies a node (-> see new method Node.getIdentifier())\n\nNon-standard parts always need to be standardized. Any of the following makes a path non-standard:\n- expanded name segments\n- trailing /\n- index [1]\n\nIdentifier-segments\n- get resolved upon being passed to any API calls that take path to an existing Node\n- don't get resolved when being used to create a PATH value object.\n\nExcept for PATH values, all jcr paths returned by the API are normalized and standard, thus never identifier-based.\n\nPATH values in contrast:\n- must be converted to standard form\n- must NOT be normalized. i.e. redundant segments and identifiers must be preserved.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2132",
        "summary": "o.a.j.core.state.ChildNodeEntries does not override equals(Object) and hashCode() methods",
        "description": "o.a.j.c.state.NodeStateMerger calls ChildNodeEntries.equals(ChildNodeEntries) to compare two child node entries collections.\nChildNodeEntries however doesn't override the equals(Object) method.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2185",
        "summary": "Encapsulate RepositoryHelper field",
        "description": "This is a first step towards a test suite that will run tests with multiple threads concurrently.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2203",
        "summary": "Create default repository in target",
        "description": "One of the JCR API tests gets a default repository from the RepositoryFactory. This default repository should use a home directory under target.",
        "label": "NUG",
        "classified": "TEST",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1281",
        "summary": "Move ocm documentation to jackrabbit-site",
        "description": "The OCM documentation from jackrabbit-ocm/xdocs should be moved to jackrabbit-site.\n\nAlso all old references to Graffito should be replaced with Jackrabbit.",
        "label": "NUG",
        "classified": "DOCUMENTATION",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-312",
        "summary": "CompactNodeTypeDefReader adds nt:base as declared supertype even if already extending",
        "description": "(reported to the list by michael singer)\n\nI wrote a simple program which uses the nt-ns-util contribution to\nregister custom node types written in CND language.\n\nI defined the following (very simple) custom node types:\n\n<test = 'http://foo.bar/test'>\n[test:firstnodetype]\n+ test:secondnodetype mandatory\n\n<test = 'http://foo.bar/test'>\n[test:secondnodetype] > test:firstnodetype\n+ test:thirdnodetype\n\n<test = 'http://foo.bar/test'>\n[test:thirdnodetype] > test:secondnodetype\n- test:catalog (string)  < 'URI', 'URN', 'DOI', 'ISBN', 'ISSN'\n- test:entry (string) m\n\n\nIn the resulting custom_nodetypes.xml each of the custom nodes has a\nsupertype of \"nt:base\" but I didn't explicitely define a supertype of\n\"nt:base\" for [test:secondnodetype] and [test:thirdnodetype].\n\nI think this behavior is wrong since the method getDeclaredSupertypes()\nof class NodeType always returns \"nt:base\" plus the explicitely declared\nSupertype (which it e.g. does not for \"nt:folder\").\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2514",
        "summary": "spi2dav: Drop Q*DefinitionImpl implementations and use spi-commons Q*DefinitionBuilder",
        "description": "spi2dav provides separate implementations of the Q*Definition interfaces that apart from the construction just duplicate the code\npresent in spi-commons. Instead the Q*DefinitionBuilder helpers could be used to generate the definition instances.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2184",
        "summary": "Allow parsing custom elements in workspace config",
        "description": "In RepositoryConfigurationParser, most *Config elements can be extended in a derived class, e.g.\n\n    public LoginModuleConfig parseLoginModuleConfig(Element security)\n\nUnfortunately, parseWorkspaceConfig expects an InputSource. One should add a\n\n    protected WorkspaceConfig parseWorkspaceConfig(Element root)\n\nto allow returning a WorkspaceConfig derived class, without having to copy the entire implementation.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-176",
        "summary": "JCRTest.java (First Steps example code): to few parameters in session.importXML",
        "description": "In the code on the First Steps page:\n\nif (!rn.hasNode(\"importxml\")) {\n        System.out.println(\"importing xml\");\n        Node n=rn.addNode(\"importxml\", \"nt:unstructured\");\n        session.importXML(\"/importxml\", new FileInputStream(\"repotest/test.xml\"));\n        session.save();\n      }\n\nThe importXML needs a third parameter, compare to: \n\nhttp://www.day.com/maven/jsr170/javadocs/jcr-1.0/javax/jcr/Session.html\n\nThis prevents the code from the First Steps page from compiling.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-1065",
        "summary": "Workspace{Copy|Move}VersionableTest assumptions on versioning",
        "description": "These test cases assume that an ancestor of a versioned node can be made versioned. This may not be true for all JCR compliant stores.\n\nThere should be a way to skip the test when it can not be executed.\n\nOne obvious approach would be to throw a NotExecutableException when the attempt to enable versioning on the parent fails. However this has the drawback that it can mask configuration errors.\n\nThoughts?\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-409",
        "summary": "Safe namespace registration",
        "description": "The namespace registration methods provided by the JCR NamespaceRegistry API are cumbersome to use and vulnerable to race conditions in the event of conflicting prefix mappings. This problem was discussed lately on the mailing list (see http://article.gmane.org/gmane.comp.apache.jackrabbit.devel/6805) and one symptom of the problem is the new code in NodeTypeManagerImpl (see JCR-349):\n\n    //  Registers a namespace...\n    try {\n        nsReg.getPrefix(uri);\n    } catch (NamespaceException e1) {\n        String original = prefix;\n        for (int i = 2; true; i++) {\n            try {\n                nsReg.registerNamespace(prefix, uri);\n                return;\n            } catch (NamespaceException e2) {\n                prefix = original + i;\n            }\n        }\n    }\n\nWe should add an internal convenience method like NamespaceRegistryImpl.safeRegisterNamespace(String prefixHint, String uri) that, instead of throwing an exception, would automatically generate and use a unique prefix based on the given hint when a prefix conflict is detected.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-282",
        "summary": "JCR-Server: respect maximal value for timeout",
        "description": "RFC 2518 states:\n\n\"The timeout value for TimeType \"Second\" MUST NOT be greater than 2^32-1.\"\n\n->> adjust constant according.\n\nBTW: sending 'Infinite' timeout in case of maximal value causes problems with microsoft builtin client, that will never unlock that resource.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1964",
        "summary": "VirtualNodeTypeStateProvider creates PropertyState with type != value(s).getType",
        "description": "VirtualNodeTypeStateProvider creates the item states for the in content representation of the node type definitions and in case of jcr:defaultValues hard codes the type of the property state (thus the jcr property) to PropertyType.STRING.\n\nthe nt-definition of nt:propertyDefinition however states that jcr:defaultValues doesn't have a required type, thus the type should rather be determined based on the values themselves.\n\nthe current behaviour leads situations where\n\nProperty.getType != Property.getValues()[0].getType()\n\nwhich from my point of view is a bug.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-445",
        "summary": "repository is locked by WorkspaceJanitor when another workspace is reindexing",
        "description": "when the searchindex is corrupt or missing, it is rebuilt lazily after initialization of a workspace. usually by the first login on that workspace. during this time, the workspaceinfo is locked. unfortunately, the workspace janitor locks the repository and checks all workspace infos, if they can be disposed. in this case, no other access to the repository can be performed until the searchindex is initialized (which can take some time).\n\nT1 -> WS1.login -> WS initializing\nJanitor -> lock repo -> scan -> try lock WS1\nT2 -> WS2.login -> must wait for T1\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-3015",
        "summary": "EntryCollector may log warning for inexistent item",
        "description": "Currently the EntryCollector may log a warning when the node reported in the event does not exist. This may happen when the repository runs in a cluster and a node is created and immediately removed again. This issue is related to JCR-3014. The call to Session.nodeExists() should actually return false when the identifier path cannot be resolved. Currently it throws a RepositoryException.",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-401",
        "summary": "contrib/bdb-persistence: update berkeleydb version",
        "description": "berkeleydb dependency should be updated to 2.0.83, already available at ibiblio. At this moment project.xml lists 1.7.1, which is very old.\nThere are no code changes required, and the PM works correctly with berkeleydb 2.0.83\n\n\t\t<dependency>\n\t\t\t<groupId>berkeleydb</groupId>\n\t\t\t<artifactId>je</artifactId>\n\t\t\t<version>2.0.83</version>\n\t\t\t<type>jar</type>\n\t\t</dependency>",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-313",
        "summary": "Allow to configure DB persistence managers through JDNI",
        "description": "Currently, DB persistence managers have hardcoded urls. Even more, they will use a single connection with the drawbacks that this have regarding concurrency, performance and transactionality. \n\nIt would be fairly better to allow to configure DB persistence managers through JDNI references to DataSource. So giving responsability to application server. Concurrency, performance and transactionability will be highly boosted with this approach. \n\nThis could be a sample configuration :\n\n<PersistenceManager class=\"org.apache.jackrabbit.core.state.db.SimpleDbPersistenceManager\">\n       <param name=\"dataSource\" value=\"jdbc/JackrabbitDS\"/>\n\n        \n       .... think also about a way to pass params to data source, it should be simple ....\n\n       <param name=\"schema\" value=\"mysql\"/>\n       <param name=\"schemaObjectPrefix\" value=\"${\nwsp.name}_\"/>\n       <param name=\"externalBLOBs\" value=\"false\"/>\n   </PersistenceManager>",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-248",
        "summary": "create configuration on InputStream",
        "description": "RepositoryConfig should be possible to create based on InputStreams (in case of URLs) ; right now it's possible only using String and InputSource. Please update also the JCA connector. ",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1819",
        "summary": "JCR2SPI: Add specific deep loading of Nodes and Properties",
        "description": "with jcr2spi an item is 'deep' loaded whenever the hierarchy is not complete. while for Session#itemExists or Session#getItem it is ok to try loading a Node first and if not found a Property, this is inconvenient (and generates unnecessary round trips to the SPI) for those cases, where the original JCR call indicates whether a Node or Property is expected.\n\nThis is the case for Node.getNode(String relPath) and Node.getProperty(String relPath) ((and maybe others))\n\nTherefore i suggest to add specific methods\n\nHierarchyManager#getNodeEntry\nHierarchyManager#getPropertyEntry\nNodeEntry#getDeepNodeEntry\nNodeEntry#getDeepPropertyEntry\n\n(or something similar)",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-612",
        "summary": "Restructure the Jackrabbit source tree",
        "description": "Reintroduce some of the changes in JCR-157 as a more general restructuring to simplify the Jackrabbit project structure. See http://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/9170/ for the rationale and discussion. The main parts of this restructuring would be:\n\n1. Create a Jackrabbit \"super-project\" (artifactId: jackrabbit) in trunk/\n\n2. Use the super-project POM as the parent of all Jackrabbit component POMs\n\n3. Move the contents of trunk/jackrabbit/src/site directly to trunk/src/site, and use the super-project to generate the web site\n\n4. Create independent subprojects for the the jackrabbit-api and jackrabbit-commons components, moving the the corresponding parts of the source tree\n\n5. Move the jcr-server subprojects on level up\n\n6. Rename the subproject directories to match their artifactIds\n\nNote that this restructuring depends on JCR-611 and JCR-332, since the best way to implement this by utilizing a snapshot repository for the component dependencies.",
        "label": "NUG",
        "classified": "TASK",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1038",
        "summary": "java.lang.ArrayIndexOutOfBoundsException while importXML in Java 6",
        "description": "Using:\n- Jackrabbit 1.3\n- Java:\n  java version \"1.6.0_02\"\n  Java(TM) SE Runtime Environment (build 1.6.0_02-b05)\n  Java HotSpot(TM) Client VM (build 1.6.0_02-b05, mixed mode, sharing)\n\nWhen importing attached XML, I get an exception:\nCaused by: java.lang.ArrayIndexOutOfBoundsException\n        at java.lang.System.arraycopy(Native Method)\n        at org.apache.jackrabbit.core.xml.BufferedStringValue.append(BufferedStringValue.java:201)\n        at org.apache.jackrabbit.core.xml.SysViewImportHandler.characters(SysViewImportHandler.java:187)\n        at org.apache.jackrabbit.core.xml.ImportHandler.characters(ImportHandler.java:200)\n        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.characters(AbstractSAXParser.java:538)\n        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:461)\n        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:807)\n        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)\n        at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:107)\n        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)\n        at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522)\n        at javax.xml.parsers.SAXParser.parse(SAXParser.java:395)\n        at org.apache.jackrabbit.core.SessionImpl.importXML(SessionImpl.java:1116)\n...\n\nIf I use Java 1.5, then it works.\n\njava version \"1.5.0_12\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_12-b04)\nJava HotSpot(TM) Client VM (build 1.5.0_12-b04, mixed mode, sharing)\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2617",
        "summary": "ItemStateMap warnings during node type changes",
        "description": "As reported already in JCR-1105, the ItemStateMap logs warnings when a cached item state is being overwritten. This shouldn't normally happen, but it turns out that virtual item state providers do this when the root of the virtual tree is modified. Probably the most common such situation is when node types are being modified. This case is luckily not troublesome for the virtual tree functionality, but the logged warnings are annoying.\n\nHere's a relevant part of a stack trace where this problem occurs:\n\n        at org.apache.jackrabbit.core.state.ItemStateMap.put(ItemStateMap.java:72)\n        at org.apache.jackrabbit.core.virtual.AbstractVISProvider.cache(AbstractVISProvider.java:324)\n        at org.apache.jackrabbit.core.virtual.AbstractVISProvider.createNodeState(AbstractVISProvider.java:284)\n        at org.apache.jackrabbit.core.nodetype.virtual.VirtualNodeTypeStateProvider.createNodeTypeState(VirtualNodeTypeStateProvider.java:157)\n        at org.apache.jackrabbit.core.nodetype.virtual.VirtualNodeTypeStateProvider.createRootNodeState(VirtualNodeTypeStateProvider.java:80)\n        at org.apache.jackrabbit.core.virtual.AbstractVISProvider.stateDiscarded(AbstractVISProvider.java:470)\n        at org.apache.jackrabbit.core.state.ItemState.notifyStateDiscarded(ItemState.java:226)\n        at org.apache.jackrabbit.core.state.ItemState.discard(ItemState.java:370)\n        at org.apache.jackrabbit.core.nodetype.virtual.VirtualNodeTypeStateProvider.onNodeTypesRemoved(VirtualNodeTypeStateProvider.java:139)\n        at org.apache.jackrabbit.core.nodetype.virtual.VirtualNodeTypeStateManager.nodeTypesUnregistered(VirtualNodeTypeStateManager.java:199)\n        at org.apache.jackrabbit.core.nodetype.virtual.VirtualNodeTypeStateManager.nodeTypeReRegistered(VirtualNodeTypeStateManager.java:174)\n        at org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.notifyReRegistered(NodeTypeRegistry.java:1821)\n        at org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.reregisterNodeType(NodeTypeRegistry.java:433)\n        at org.apache.jackrabbit.core.nodetype.NodeTypeRegistry.reregisterNodeType(NodeTypeRegistry.java:364)\n        at org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl.registerNodeTypes(NodeTypeManagerImpl.java:591)\n        at org.apache.jackrabbit.commons.cnd.CndImporter.registerNodeTypes(CndImporter.java:118)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-213",
        "summary": "Avoid creation of more than one jackrabbit instance with the same configuration",
        "description": "based on the mailing list archive, it seems new users often run more than one jackrabbit instance with the same configuration. I propose to lock the repository by creating an empty file called \".lock\" at the repository home on startup and remove it on shutdown.\nIf the lock file is found on jackrabbit startup the following message will be logged:\n\"The repository home at \" + home.getAbsolutePath() + \" appears to be in use. If you are sure it's not in use please delete the file at  \" + lock.getAbsolutePath() + \". Probably the repository was not shutdown properly.\"\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2946",
        "summary": "Jcr-Server: Improve implementation of DavResource#getProperty(DavPropertyName)",
        "description": "this issue has already been described in JCR-397\n\nproblem: even if only a subset of properties has been requested by the client dav resource initializes the complete set of properties.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1141",
        "summary": "LockOperation - In a clustered environment, a lock created on one server is not sent to the other servers.",
        "description": "The cluster operation for a lock (LockOperation) always has the isLock variable set to false.\nThe operation to represent a lock should set the isLock variable to true.\n\n    /**\n     * Flag indicating whether this is a lock. \n     */\n    private boolean isLock;\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1293",
        "summary": "ReorderReferenceableSNSTest failure",
        "description": "I have checked out the Jackrabbit 1.4 branch to a new directory, and called:\n\nmvn clean install\n\nThe error is:\n\nBuilding Jackrabbit JCR to SPI\n  task-segment: [clean, install]\n---------------------------------\n...\ntestRevertReorder(org.apache.jackrabbit.jcr2spi.ReorderReferenceableSNSTest)\njunit.framework.AssertionFailedError: Reorder added a child node.\n       at junit.framework.Assert.fail(Assert.java:47)\n       at org.apache.jackrabbit.jcr2spi.ReorderTest.testOrder(ReorderTest.java:90)\n       at org.apache.jackrabbit.jcr2spi.ReorderTest.testRevertReorder(ReorderTest.java:122)\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2465",
        "summary": "Background threads should use jackrabbit classloader as thread context classloader",
        "description": "The RepositoryImpl uses a thread executor with a default thread factory for some background threads. These threads should use the jackrabbit class loader (the classloader used for loading jackrabbit)\nas thread context classloader. Currently the classloader is used which causes a new thread to be greated.\nFor example in combination with Sling the following can happen: a jsp in sling initiates a save to jackrabbit, this causes the indexing to start which is done in a background thread. A new thread is taken from the pool and the thread context class loader is set to the thread context classloader of the jsp/sling. If now Sling is undeployed, jackrabbit still holds this class loader. This creates a hugh memory leak.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3229",
        "summary": "FileRevision should have a flag to control whether to sync the file on every write.",
        "description": "FileRevision class syncs the underlying revision.log file it uses on every write which could be a performance problem. Add a boolean flag to control whether to sync the file on every write.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1740",
        "summary": "Make ObjectIterator implement RangeIterator interface",
        "description": "Currently, it's not possible to skip a part of results returned in the form of ObjectIterator (for example, to implement db-like pagination feature with offset/max parameters).\n\nIt would be great if ObjectIterator implement RangeIterator interface, and it's trivial enough since underlying NodeIterator implements this interface.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2896",
        "summary": "WebdavResponseImpl should cache TransformerFactory",
        "description": "JackrabbitResponeImpl.sendXmlResponse creates an instance of TransformerFactory on each invocation. We see, that this TransformerFactory initialization consumes significant amount of time, because of complex logic inside:\n\n{code}\n    at java.lang.String.intern(Native Method)\n    at java.util.jar.Attributes$Name.<init>(Attributes.java:449)\n    at java.util.jar.Attributes.putValue(Attributes.java:151)\n    at java.util.jar.Attributes.read(Attributes.java:404)\n    at java.util.jar.Manifest.read(Manifest.java:234)\n    at sun.security.util.SignatureFileVerifier.processImpl(SignatureFileVerifier.java:188)\n    at sun.security.util.SignatureFileVerifier.process(SignatureFileVerifier.java:176)\n    at java.util.jar.JarVerifier.processEntry(JarVerifier.java:277)\n    at java.util.jar.JarVerifier.update(JarVerifier.java:188)\n    at java.util.jar.JarFile.initializeVerifier(JarFile.java:321)\n    at java.util.jar.JarFile.getInputStream(JarFile.java:386)\n    at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:144)\n    at java.net.URL.openStream(URL.java:1009)\n    at java.lang.ClassLoader.getResourceAsStream(ClassLoader.java:1170)\n    at javax.xml.transform.SecuritySupport$4.run(SecuritySupport.java:94)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at javax.xml.transform.SecuritySupport.getResourceAsStream(SecuritySupport.java:87)\n    at javax.xml.transform.FactoryFinder.findJarServiceProvider(FactoryFinder.java:250)\n    at javax.xml.transform.FactoryFinder.find(FactoryFinder.java:223)\n    at javax.xml.transform.TransformerFactory.newInstance(TransformerFactory.java:102)\n    at org.apache.jackrabbit.webdav.WebdavResponseImpl.sendXmlResponse(WebdavResponseImpl.java:163)\n{code}\n\nTransformerFactory can be cached in static field:\n\nprivate static final TransofmerFactory transformerFactory = TransformerFactory.newInstance().",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2443",
        "summary": "AbstractSession should not synchronize on the session instance",
        "description": "The local namespace mapping methods in AbstractSession are synchronized to protect against concurrent access. That's troublesome since our observation delivery needs to be able to get those mappings even when the session is synchronized to do something else.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-3195",
        "summary": "wrong assumptions in test cases about lock tokens",
        "description": "Several test cases assume that Lock.getLockToken has to return null for locks not attached to the current session. However, this is optional. Citing the Javadoc for getLockToken:\n\n     * May return the lock token for this lock. If this lock is open-scoped and\n     * the current session either holds the lock token for this lock, or the\n     * repository chooses to expose the lock token to the current session, then\n     * this method will return that lock token. Otherwise this method will\n     * return <code>null</code>.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2722",
        "summary": "Add a filtered RangeIterator",
        "description": "It would be useful to have a FilteredRangeIterator utility class that can be used to apply arbitrary filters on other RangeIterators.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-996",
        "summary": "Name and Path interfaces in SPI",
        "description": "The SPI interface currently has a dependency to QName and Path classes in jackrabbit-jcr-commons. Architecturally it would be better to have Name and Path interfaces in the SPI package, and have the implementing classes in commons.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-143",
        "summary": "Query for string literal broken when literal can be coerced into other type",
        "description": "When a string literal can be coerced into another type (e.g. integer) a property of type string that matches the literal is not found.\n\nE.g. the following query will match prop if its value is the string '1234'.\n//*[@prop = '1234']\n\nThe query should match properties with string value '1234' and integer value 1234.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-245",
        "summary": "Automatic repository shutdown",
        "description": "Currently Jackrabbit relies on two mechanisms for safely shutting down a repository:\n\n    1) client application invoking RepositoryImpl.shutdown(), or\n    2) the shutdown hook installed by RepositoryImpl being run\n\nBoth of these mechanisms have problems:\n\n    1) The shutdown() method is not a part of the JCR API, thus making the client application depend on a Jackrabbit-specific feature\n    2) In some cases the shutdown hook is not properly run (see issues JCR-120 and JCR-233)\n\nI think the JCR spec thinks of the Repository and Session interfaces as being somewhat similar to the JDBC DataSource and Connection interfaces. The Repository instances have no real lifecycle methods while the Session instances have clearly specified login and logout steps. (DataSource.getConnection() = Repository.login(), Session.logout() = Connection.close()) However the Jackrabbit implementation defines an explicit lifecycle for the RepositoryImpl instances.\n\nThis causes problems especially for container environments (JNDI, Spring) where it is hard or even impossible to specify a shutdown mechanism for resource factories like the Repository instances. The current solution for such environments is to use a shutdown hook, but as reported this solution does not work perfectly in all cases.\n\nHow about if we bound the RepositoryImpl lifecycle to the lifecycles of the instantiated Sessions. A RepositoryImpl instance could initialize (and lock) the repository when the first session is opened and automatically shut down when the last session has logged out. As long as the sessions are properly logged out (or finalized by the garbage collector) there would be no need for an explicitly RepositoryImpl.shutdown() call. The current behaviour of pre-initializing the repository and shutting down during a shutdown hook could be enabled with a configuration option for environments (like global JNDI resources) in which the shutdown hooks work well.\n",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-215",
        "summary": "Code depends on Log4J directly",
        "description": "The code is written against the Log4J APIs, which forces all users of Jackarabbit to pick up log4J dependency and to juggle with JDK logging and Log4J configuration if other components of the project uses JDK 1.4 logging.\nIf the code is move to depend on Apache commons-logging this issue will be resolved. Also this should be a minor fix.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-237",
        "summary": "Item.isNew() does not work correctly within a transaction",
        "description": "javadoc on Item.isNew() states:\n\n     * Returns <code>true</code> if this is a new item, meaning that it exists only in transient\n     * storage on the <code>Session</code> and has not yet been saved. Within a transaction,\n     * <code>isNew</code> on an <code>Item</code> may return <code>false</code> (because the item\n     * has been saved) even if that <code>Item</code> is not in persistent storage (because the\n     * transaction has not yet been committed).\n\nbut currently, Item.isNew() returns \"true\" after beeing saved in a transaction.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-857",
        "summary": "Basic support for fn:name()",
        "description": "Add basic support for fn:name() in XPath queries. Jackrabbit should at least support the the fn:name() function within an equals expression.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-2547",
        "summary": "Setting a property which has been transiently removed fails with a PathNotFoundException",
        "description": "The following tests currently all fail with a PathNotFoundException\n\norg.apache.jackrabbit.jcr2spi.AddPropertyTest#testReplacingProperty\norg.apache.jackrabbit.jcr2spi.AddPropertyTest#testReplacingProperty2\norg.apache.jackrabbit.jcr2spi.AddPropertyTest#testAddingProperty\norg.apache.jackrabbit.jcr2spi.AddPropertyTest#testAddingProperty2\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1229",
        "summary": "Remove build.xml from jackrabbit-core",
        "description": "After JCR-1203 the build.xml within jackrabbit-core contains only a single Ant task, that could just as well be moved into the pom.xml file to be run inline with the maven antrun plugin.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2649",
        "summary": "Provide means to display the effective policies for a given set of principals",
        "description": "JSR 283 currently defines AccessControlManager#getEffectivePolicies(String nodePath) that would allow any Permission related UI to\ndisplay what policies contribute to a particular set of privileges. In addition the API defines AccessControlManager#getPrivileges(String nodePath) which\nreturns the privileges the editing session has at the specified path.\n\nIn order to have additional flexibility we started to add custom extensions (-> JackrabbitAccessControlManager) that allows e.g. to retrieve the privileges any set\nof principals has hat a specified path. I would like to extend this and in addition provide a method that allows to retrieve the effective policies for a set of principals.\nCurrently this can only be achieved by relying on a specific access control model and making assumptions about it's implementation, which obviously isn't\nthe desired effect.\nI",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-1341",
        "summary": "Cluster Journal directory should be created automatically",
        "description": "If the cluster journal directory does not exist when starting the cluster, an exception is thrown: ERROR org.apache.jackrabbit.core.RepositoryImpl - failed to start Repository: Directory specified does either not exist or is not a directory: ...\n\nAs far as I know, this is not consistent with how all other components of Jackrabbit work. I think the directory should be created automatically if it does not exist:\n\nnew File(...).mkdirs();\n\nI know you could argue this is not a bug, but in my view it is an important usability issue.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-49",
        "summary": "SQL query with jcr:path LIKE '/foo/%' only selects children",
        "description": "A query like: \n\nSELECT * FROM nt:base WHERE jcr:path LIKE '/foo/%'\n\nonly selects the children of /foo instead off all descendants of /foo.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-434",
        "summary": "ArrayIndexOutOfBoundsException in NodeTypeDefDiff",
        "description": "It appears that the code for building diffs in child node definitions loops incorrectly, opening the possibility for an ArrayIndexOutOfBounds exception. The offending portion is in the \"buildChildNodeDefDiffs\" method:\n\n<<\nNodeDef[] cnda2 = newDef.getChildNodeDefs();\nHashMap defs2 = new HashMap();\nfor (int i = 0; i < cnda1.length; i++) {\n    defs2.put(cnda2[i].getId(), cnda2[i]);\n}\n>>\n\nIt seems like simply changing the length check to be cnda2 (as it is in \"buildPropDefsDiff\") would suffice.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1112",
        "summary": "CacheManager interval between recalculation of cache sizes should be configurable",
        "description": "Currently interval between recaluclation of cahce size is hard coded to 1000 ms. Resizing/recalculation of cache size is quite expensive method (especially getMemoryUsed on MLRUItemStateCache is time consuming)\n\nDepending on the configuration, we realized that under some load up to 10-15% percent of CPU time (profiler metrics) could be spend doing such recalculations. It does not seem to be needed to resize cache every second. Best this interval should be configurable in external config. file with other cache settings (like memory sizes).",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-912",
        "summary": "OverlappingFileLockException with JRE 1.6",
        "description": "Per email discussion:\nOn Mon, 2007-02-26 at 10:26 +0100, Marcel Reutegger wrote:\n> > just my 2c, I didn't really investigated this issue in more detail...\n> >\n> > according to the javadoc of FileChannel.tryLock() the\n> > OverlappingFileLockException is thrown if the JVM already holds a lock on the\n> > channel.\n> >\n> > in contrast, the current check in the repository startup method primarily\n> > focuses on the situation where *two* JVMs start a repository on the same home\n> > directory.\n> >\n> > I'd say the OverlappingFileLockException is thrown because two repository\n> > instances are startup within the *same* JVM using the same repository home\n> > directory.\n> >\n> > I suggest we add a catch clause, which also covers OverlappingFileLockException\n> > in addition to IOException.\n> >\n> > regards\n> >   marcel\n> >\n> > Stefan Guggisberg wrote:\n> > > btw, afaik OverlappingFileLockException is only thrown on linux,\n> > > FileChannel#getLock on windows e.g. returns null in the same situation.\n> > >\n> > > you might want to test on a different platform to further isolate the\n> > > issue.\n> > > you could also place a breakpoint at the top of the\n> > > RepositoryImpl#acquireRepositoryLock\n> > > method, step through the code, verify the contents of your fs etc.\n> >\n>\n\n\n=== Original email\n\nOn 2/19/07, Patrick Haggood <codezilla@> wrote:\nI'm using Linux, Sun Java 6 and Jackrabbit 1.3 with Derby persistance.\nI have a putNode(object) function that's giving the above error in unit\ntests.  It always fails after the second update, even when I swap tests\n(i.e. save user doc then save user).  Prior to each test, I delete the\nrepository directory.\n\nDo I need to set explicit locks before/after each session.save()?\n\n*********** Unit Test\nDBConn dbc;\n\n    public SessionUtilTest(String testName) {\n        super(testName);\n        dbc = new DBConn();\n    }\n\n// Note - putUser and putDocument both use putNode after determining\nwhich rootnode will be used\n\n   /**\n     * Test of putUnityUser method, of class unityjsr170.jr.SessionUtil.\n     */\n    public void testPutUnityUser() {\n        System.out.println(\"putUnityUser\");\n        UnityUser usr = usr1;\n        SessionUtil instance = dbc.getSutil();\n        String result = instance.putUnityUser(usr1);\n        assertNotNull(result);\n        usr = (UnityUser) instance.getUnityUserByID(result);\n        assertEquals(usr1.getName(),usr.getName());\n    }\n       \n    /**\n     * Test of putUnityDocument method, of class\nunityjsr170.jr.SessionUtil.\n     */\n    public void testPutUnityDocument() {\n        System.out.println(\"putUnityDocument\");\n        UnityDocument udoc = adr1;\n        SessionUtil instance = dbc.getSutil();\n        String result = instance.putUnityDocument(udoc);   <---- File\nLock Error\n        assertNotNull(result);\n        udoc = (UnityDocument) instance.getUnityDocumentByID(result);\n        assertEquals(adr1.getName(),udoc.getName());\n    }\n\n\n********* Here's where I setup my repository connection\n\n    public DBConn(){\n        sutil = null;\n        try {\n            rp = new TransientRepository();\n            sutil= new SessionUtil(rp);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n    \n    public void shutdown(){\n        sutil.closeAll();\n    }\n    \n    public SessionUtil getSutil(){\n        return sutil;\n    }\n\n****************  SessionUtil\n\n    public SessionUtil(Repository rp){\n        try {\n            session = rp.login(new\nSimpleCredentials(\"username\",\"password\".toCharArray()));\n            \n        } catch (LoginException ex) {\n            ex.printStackTrace();\n        } catch (RepositoryException ex) {\n            ex.printStackTrace();\n        } \n        \n    }\n    \n    public void closeAll(){\n        try {\n            session.logout();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.out.println(\"Error closing repository\");\n        }\n    }\n    \n // Put a node on the tree under the root node, return the uuid of the\nnew or updated node\n    private String putNode(String nodetype, UnityBaseObject ubo){\n        String resultuuid =null;\n        String uname = ubo.getName();\n        String utype = ubo.getType();\n        String objectuid = ubo.getId();\n        Node pnode; //  node to add or update\n        Session ses = null;\n        try {\n            ses = getSession();\n            // Does updateable node already have node Id?\n            if (objectuid==null) {\n                Node rn = ses.getRootNode();\n                pnode = rn.addNode(utype);\n                pnode.addMixin(\"mix:referenceable\");\n            } else{\n                // grab existing node by uuid\n                pnode = ses.getNodeByUUID(objectuid);\n            }\n            // Did we get an updateable node?\n            if (pnode!=null){\n                ubo.setId(pnode.getUUID());\n                String unityXML =\nutrans.getXMLStringFromUnityBaseObject(ubo);\n                // update all the properties\n                pnode.setProperty(\"name\",ubo.getName());\n                pnode.setProperty(\"type\",ubo.getType());\n                pnode.setProperty(\"xmldata\",unityXML);\n                ses.save();\n                resultuuid = ubo.getId();\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        } \n        return resultuuid;\n    }\n\n    private Session getSession(){\n        return session;\n    }\n    \n\n************  repository.xml\n\n <Workspace name=\"${wsp.name}\">\n        <FileSystem\nclass=\"org.apache.jackrabbit.core.fs.local.LocalFileSystem\">\n            <param name=\"path\" value=\"${wsp.home}\"/>\n        </FileSystem>\n        <PersistenceManager\nclass=\"org.apache.jackrabbit.core.state.db.DerbyPersistenceManager\">\n            <param name=\"url\" value=\"jdbc:derby:\n${wsp.home}/db;create=true\"/>\n            <param name=\"schemaObjectPrefix\" value=\"${wsp.name}_\"/>\n        </PersistenceManager>\n        <SearchIndex\nclass=\"org.apache.jackrabbit.core.query.lucene.SearchIndex\">\n            <param name=\"path\" value=\"${wsp.home}/index\"/>\n            <param name=\"useCompoundFile\" value=\"true\"/>\n            <param name=\"minMergeDocs\" value=\"100\"/>\n            <param name=\"volatileIdleTime\" value=\"3\"/>\n            <param name=\"maxMergeDocs\" value=\"100000\"/>\n            <param name=\"mergeFactor\" value=\"10\"/>\n            <param name=\"bufferSize\" value=\"10\"/>\n            <param name=\"cacheSize\" value=\"1000\"/>\n            <param name=\"forceConsistencyCheck\" value=\"false\"/>\n            <param name=\"autoRepair\" value=\"true\"/>\n            <param name=\"analyzer\"\nvalue=\"org.apache.lucene.analysis.standard.StandardAnalyzer\"/>\n        </SearchIndex>\n    </Workspace>\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1790",
        "summary": "terminology: source uses \"protected  property\" for something that only only indirectly has to do with that term",
        "description": "Documentation and method names (DavProperty) use \"protected\" as pseudonym for \"return upon PROPFIND/allprop\". This isn't really accurate, because the live properties defined in RFC2518/4918 *are* protected, but are returned with PROPFIND/allprop nevertheless.\n\nProposal: update documentation and method names to say something like \"visibleInAllprop\".\n",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "BUG"
    },
    {
        "key": "JCR-2282",
        "summary": "SQL2 parser may infer type for UncastLiteral from static analysis",
        "description": "The spec says:\n\n\"An UncastLiteral is always interpreted as a Value of property type STRING. A CastLiteral, on the other hand, is interpreted as the string form of a Value of the PropertyType indicated.\"\n\nThere are also two test cases in NodeNameTest that need to be fixed accordingly: testLongLiteral and testBooleanLiteral\n",
        "label": "NUG",
        "classified": "SPEC",
        "type": "BUG"
    },
    {
        "key": "JCR-1718",
        "summary": "repository-1.5.dtd: change order of main elements",
        "description": "Currently the order of elements in repository.xml is:\n<!ELEMENT Repository (FileSystem,Security,Workspaces,Workspace,Versioning,SearchIndex?,Cluster?,DataStore?)>\n\nI would like to change it to\n<!ELEMENT Repository (Cluster?,FileSystem,DataStore?,Security,Workspaces,Workspace,Versioning,SearchIndex?)>\nbecause I think that makes more sense.\n\nCurrently XML validation is disabled, and therefore the order of elements in the DTD does not need to match the repository.xml file. However as soon as XML validation is enabled, repository.xml files that use the wrong order will no longer work (the repository can not be started).\n\nThere is a request to enable XML validation at http://issues.apache.org/jira/browse/JCR-1462\n",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-951",
        "summary": "OracleFileSystem uses getClass().getResourceAsStream to load schema file",
        "description": "org.apache.jackrabbit.core.fs.db.OracleFileSystem loads the schema via getClass().getResourceAsStream(...).\nThis makes it impossible to extend the class without either copying the schema ddl file, or overwriting checkSchema(...),\nas the schema file is not accessible.\n\nThe solution is to use OracleFilesystem.class.getResourceAsStream(...).\n\nSee JCR-595 which fixed this already for org.apache.jackrabbit.core.persistence.db.DatabasePersistenceManager.",
        "label": "NUG",
        "classified": "DESIGN_DEFECT",
        "type": "BUG"
    },
    {
        "key": "JCR-1107",
        "summary": "ObjectIterator may return null, which is not readily expected from an Iterator",
        "description": "The ObjectIterator class implements an Iterator of objects mapped from an underlying NodeIterator. This ObjectIterator may return null from next() if no mapping for a node in the iterator exists. Rather than returning null, the iterator should probably just ignore the unmappable node and return an object from the next node in the underlying iterator which is mappable.",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-993",
        "summary": "corrupted paths after moving nodes",
        "description": "we just found a bug which corrupts the results of Node.getPath() - it seems to be related to older Jackrabbit bugs (e.g. JCR-768) but still happens in jackrabbit 1.3 and jackrabbit-1.4-SNAPSHOT\n\nBasically we have a node with 3 subnodes (a, b, c), we move all of them to index 1 - this works fine, unless we call getPath() of the third Node before moving it.\n\nThe expected paths after moving would be:\na: /pages[37]/page/element[3]\nb: /pages[37]/page/element[2]\nc: /pages[37]/page/element\n\nBut we get these paths:\n\na: /pages[37]/page/element[3]\nb: /pages[37]/page/element\nc: /pages[37]/page/element",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-507",
        "summary": "TCK: NodeTest#testMixinTypesProtected incorrectly fails",
        "description": "The test calls addMixin to add mix:referenceable to a node.  This step is not required to test that jcr:mixinTypes is protected, yet may fail if the node is already mix:referenceable or cannot be mix:referenceable.\n\nProposal: remove the call to addMixin.\n\nThe test attempts to set jcr:mixinTypes to a scalar value, but reports a failure if the implementation throws ValueFormatException instead of ConstraintViolationException.\n\nProposal: set jcr:mixinTypes to an array of length 1.\n\n--- NodeTest.java       (revision 422074)\n+++ NodeTest.java       (working copy)\n@@ -1130,10 +1142,9 @@\n         Node defaultRootNode = (Node) superuser.getItem(testRootNode.getPath());\n  \n         Node testNode = defaultRootNode.addNode(nodeName1, testNodeType);\n-        testNode.addMixin(mixReferenceable);\n  \n         try {\n-            testNode.setProperty(jcrMixinTypes,mixLockable);\n+            testNode.setProperty(jcrMixinTypes, new String[] { mixLockable });\n             fail(\"Manually setting jcr:mixinTypes should throw a ConstraintViolationException\");\n         }\n         catch (ConstraintViolationException success) {\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2057",
        "summary": "When creating multiple repository instances pointing to the same home, opening a second session will remove the .lock file",
        "description": "The following test case can be used to reproduce the bug:\nRepository repo1 = new TransientRepository(repoConfig);\nSession session1_1 = repo1.login(...);\nSession session2_2 = repo1.login(...);\nRepository repo2 = new TransientRepository(repoConfig); // Will not fail (expected)\nSession session2_1 = repo2.login(...); // Will fail with javax.jcr.RepositoryException: The repository home /tmp/_repository appears to be already locked by the current process (expected)\nSession session2_2 = repo2.login(...); // Will work!\nRepository repo3 = new TransientRepository(repoConfig); // Will not fail either (expected)\nSession session3_1 = repo3.login(...); // Will fail with javax.jcr.RepositoryException: The repository home /tmp/_repository appears to be already locked by the current process (expected)\nSession session3_2 = repo3.login(...); // Will fail with javax.jcr.RepositoryException: Directory was previously created with a different LockFactory instance\n\nOpen the first session in repo2 will fails but will also remove the .lock file, thus the second\nsession will succeed and may corrupt the repository because there are multiple session\nopened from multiple repository.\nThe same behaviour occurs for repo3, the .lock file is removed but it is a slightly different case\nas a new exception will be thrown while creating the Lucene index.\n\nThis is a clearly a twisted case as repositories pointing to the same home must not be created\nsimultaneously but i think that it must be more robust to prevent data corruption.\n\nI reproduce the bug on JR 1.4.7 and 1.5.3 but i think it affects at least all versions of JR < 1.5.3.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-346",
        "summary": "Jcr-Server: ItemDefinitionImpl.toXml throws NPE for the root node.",
        "description": "ItemDefinitionImpl.toXml throws NPE for the root node due to a missing assertion regarding the declaring nodetype.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-651",
        "summary": "Improve performance for queries with large result sets",
        "description": "The current implementation of QueryResult requires that access rights are checked on all NodeIds before they are passed ot the QueryResult. This handling should be improved to a more lazy approach where result nodes are checked in configurable batches. Usually a client is only interested in the top scoring results.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3115",
        "summary": "Versioning fixup leaves persistence in a state where the node can't be made versionable again",
        "description": "Jackrabbit's version recovery mode (org.apache.jackrabbit.version.recovery system property) disconnects all version histories that expose problems that manifest in unexpected exceptions being thrown. \"disconnects\" means removing the properties defined for mix:versionable and removing the mixin type. The actual versioning related nodes remain in place.\n\nThe problem: when re-adding mix:versionable, ItemSaveOperation.initVersionHistories tries to create the new version history in the same location (the path being derived from the versionable node's identifier), and consequently fails because of the broken underlying storage.\n\n(attaching a work-in-progress test case that illustrates the problem)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2050",
        "summary": "Optimize refresh operations ",
        "description": "With the current implementation (recursive) refresh operations cause a full traversal of the sub-tree rooted at the item causing the refresh. This is potentially expensive. \n\nInstead of invalidating each item in the respective sub-tree I propose to mark the root of the sub-tree as invalidated. Such a mark would include a time stamp. Also individual items would be time stamped with their resolution time. When an item is accessed, it would check if its resolution time stamp is older than the latest invalidation time stamp. If so, it checks whether the invalidation applies to it at all (by traversing up the path) and if so it would re-resolve itself. In any case its resolution time stamp will be updated.\n\nThis approach would make invalidation much cheaper without putting much additional load to simple item access. Moreover most of the additional load (traversing up the path) only applies when an invalidation is pending.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3112",
        "summary": "NodeTypeDefDiff.PropDefDiff.init() constraints change check bugs",
        "description": "Two bugs have been found in NodeTypeDefDiff.PropDefDiff.init() when try to modify property constraints of an already registered node type:\n\n1) according to the java doc it should be possible to remove all constraints from a property, but it is not (marked as a MAJOR change).\n \n2) it's allowed (TRIVIAL) to set a constraint to a property that had no constraint at all before, which is wrong, because it could affect the consistency of existing repository content.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2436",
        "summary": "webdav's PropertyDefinitionImpl's toXML doesn't seem to attach query operators element to the returned dom",
        "description": "PropertyDefinitionImpl.toXML does\n\n        // JCR 2.0 extension\n        Element qopElem = document.createElement(AVAILABLE_QUERY_OPERATORS_ELEMENT);\n        String[] qops = getAvailableQueryOperators();\n        for (int i = 0; i < qops.length; i++) {\n            Element opElem = document.createElement(AVAILABLE_QUERY_OPERATOR_ELEMENT);\n            DomUtil.setText(opElem, qops[i]);\n            qopElem.appendChild(opElem);\n        }\n\n        return elem;\n\nwhich doesn't attach the qopElem to the returned dom.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-904",
        "summary": "non mantatory revision property in the Journal configuration",
        "description": "An exception is thrown if property 'revision' is not set. I think it would be great to save the revision file in the repository home dir \nwhen the property is not set.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-473",
        "summary": "Some enhancements to jackrabbit commons",
        "description": "I would like to suggest a couple of  enhancements to the commons module. \n\nThe patch was created against rev. 417443 and the tests did not reveal any \nproblems.\n\nSummary of suggestion modifications:\n\nQName\n-------------------------------------------------------------------------------------------------------------------------\n- reduce QName to its core functionality and put conversion from and to JCR name to\n  a separate class 'NameFormat'\n- in order not to break existing code, all methods that deal with the conversion in QName\n  are marked deprecated.\n- add constant for the name of the root node.\n\nPath\n-------------------------------------------------------------------------------------------------------------------------\n- reduce Path to its core functionality and put conversion from and to JCR path to\n  a separate class 'PathFormat'\n- in order not to break existing code, all methods that deal with the conversion in Path\n  are marked deprecated.\n- introduce new constants for UNDEFINED_INDEX (0) and DEFAULT_INDEX (1), that\n   are currently hardcoded throughout  the jackrabbit project.\n- new method Path.getElement(int) [PathElement]\n- make PathElement constants public (used by PathFormat)\n\nPath.PathBuilder\n-------------------------------------------------------------------------------------------------------------------------\n- additional constructor  PathBuilder(Path)\n\nPath.PathElement\n-------------------------------------------------------------------------------------------------------------------------\n- add PathElement.getNormalizedIndex() that always asserts a 1-based index.\n- change subclasses to be private (no usage within the jackrabbit, except inside Path).\n\nPathMap\n-------------------------------------------------------------------------------------------------------------------------\n- move o.a.j.core.PathMap  to o.a.j.util.PathMap in order to make it available in the\n  commons module.\n\nNamespaceResolver\n-------------------------------------------------------------------------------------------------------------------------\n- add methods for resolution of paths:\n   > getQPath(String jcrPath) [Path]\n   > getJCRPath(Path qPath) [String]\n\nNamespaceListener\n-------------------------------------------------------------------------------------------------------------------------\n- add method 'namespaceRemove(String)'\n\nValueHelper\n-------------------------------------------------------------------------------------------------------------------------\ncurrently  JCR value objects are 'manually' created in the ValueHelper despite the\nfact, that JSR170 defines a ValueFactory interface. Consequently the ValueHelper\npresent in the commons module can only be used by implementations that use\nthe same value implementations.\n\n- add new helper methods that take a ValueFactory as argument.\n- in order not to break existing code the original methods are marked deprecated and\n  may be removed at a later time.\n\nconsequently:\n- modify signature of  InternalValue.create that include a value conversion to take a\n  ValueFactory param and adjust all usages inside the core package.\n\nValueFactoryImpl\n-------------------------------------------------------------------------------------------------------------------------\n- createValue(String, int ): used to call the conversion on ValueHelper. with the \n   changes suggested to ValueHelper, the code must be changed in order to\n   created instances of the Value implementations within the factory.\n- together with the modification to ValueHelper, stefan suggested to replace the public \n  constructor with a static 'getInstance' method. All usages within jackrabbit.core, were\n   modified accordingly.\n\nText\n-------------------------------------------------------------------------------------------------------------------------\n- add getName(String, boolean) where the boolean flag indicates whether  a trailing slash \n   should be ignored.\n- add getRelativeParent(String, int, boolean) where the boolean flag indicates whether  a \n  trailing slash should be ignored.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2948",
        "summary": "jcr-server: add possibility to PROPFIND the JCR_NODETYPES_CND_LN property",
        "description": "patch by uwe jaeger see JCR-2454\n\nin didn't include in the resolution of JCR-2454 since i would like to have JCR-2946 fixed as a prerequisite.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-398",
        "summary": "maven2 repository",
        "description": "Could somebody care to upload jackrabbit to maven2 repo's at ibiblio? (ideally libraries, javadocs, source, pom's - but at least the lib's)",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2123",
        "summary": "Better name and path factory exception messages",
        "description": "I've ran across a few cases where the name and path factories throw an exception about an invalid path or name, but fail to include the actual path or name in the exception message. It would be very helpful to have that extra bit of information included.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2299",
        "summary": "Bad check for sv:name attribute presence in system view import",
        "description": "sax content handler checks the wrong variable to see if it's null in SysViewImportHandler\n\nname vs. svName\n\npatch fixes this",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1167",
        "summary": "Paths not correct after reordering children",
        "description": "Reordered, unsaved children of a node do not have the correct path. In the test case attached, the following operation is attempted with three SNS children named b[1], b[2], b[3]: the last element is ordered before the first three times, which should result in the initial children order.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2555",
        "summary": "Improved reusability of the JCA package",
        "description": "The jackrabbit-jca package currently has hardcoded references to jackrabbit-core, which makes it difficult to reuse the packaging and related code with other JCR implementations. With the RepositoryFactory interface from JCR 2.0 we can avoid this hard dependency.",
        "label": "NUG",
        "classified": "REFACTORING",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-368",
        "summary": "Add support for simple test cases",
        "description": "As discussed on the mailing list, I'd like to add a simple org.apache.jackrabbit.core.TestRepository helper class that could be used in a simple unit test template.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-197",
        "summary": "Index merging should run in a separate thread",
        "description": "Indexes are merged using the configuration parameters mergeFactor and minMergeDocs. With the default value of 10 for mergeFactor and 100 for minMergeDocs, as soon as 10 index directories exist with less or equal than 100 nodes they are merged into a single one. This process is then repeated by multiplying the minMergeDocs with the mergeFactor. Therefore the second round will merge 10 index directories with less or equal than 1000 nodes.\n\nBecause the above process is part of the regular workspace store operation an index merge with more than let's say 10'000 nodes can block the store operation for a couple of seconds. With the current synchronization scheme, all other threads are blocked from writing. This is not acceptable.\n\nIndex merging should run in a separate thread in the background.\n\nThe process needs to take care of the following:\n- While merging indexes, deletes on those indexes must not get lost\n- Switching between the indexes that are merged and the new index must be atomic\n- Recovery if merging is interrupted, e.g. jackrabbit is shutdown",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-3080",
        "summary": "Add User#changePassword(String newPw, String oldPw)",
        "description": "... where the oldPw must match in order to have the password of the user successfully changed.\n\nwhile this could be done by applications with quite some effort, the implementation can easily achieve this\nas the functionality required is already present.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-218",
        "summary": "[JCR-RMI] Have ClientItem.isSame throw RepositoryException",
        "description": "Currently the ClientItem.isSame(Item) method wraps a RepositoryException thrown from the path comparison into a RuntimeException and omits an exception declaration on the method. This contrasts with the API specification which allows for a RepositoryExcption to be thrown.\n\nI suggest, to modify ClientItem.isSame(Item) such that the RepositoryException is declared and thrown.",
        "label": "NUG",
        "classified": "SPEC",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-762",
        "summary": "System view XML uses hardcoded sv: prefix",
        "description": "Jackrabbit enforces that the xml docment that imported into repository through the use of  ContentHandler have attributte \"name\" with specific prefix (\"sv\"), instead of specific namespace (\"com.cisco.topos.jcr.sv\").\n\nExample of wrong behavior:\nCalling\nmarshaller.marshal(entry, session.getImportContentHandler(session.getNodeByUUID(channelId).getPath(), ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW));\n\nwhere entry is object that represent xml structure with namespace \"com.cisco.topos.jcr.sv\" assigned to prefix other then \"sv\" or as default namespace  will cause  exception\njava.lang.RuntimeException: javax.xml.bind.MarshalException\n\n javax.jcr.InvalidSerializedDataException: missing mandatory sv:name attribute of element sv:node\n\tat org.apache.jackrabbit.core.xml.SysViewImportHandler.startElement(SysViewImportHandler.java:122)\n\tat org.apache.jackrabbit.core.xml.ImportHandler.startElement(ImportHandler.java:192)\n\tat com.sun.xml.bind.v2.runtime.output.SAXOutput.endStartTag(SAXOutput.java:80)\n\tat com.sun.xml.bind.v2.runtime.XMLSerializer.endAttributes(XMLSerializer.java:273)\n\tat com.sun.xml.bind.v2.runtime.XMLSerializer.childAsSoleContent(XMLSerializer.java:531)\n\tat com.sun.xml.bind.v2.runtime.ClassBeanInfoImpl.serializeRoot(ClassBeanInfoImpl.java:283)\n\tat com.sun.xml.bind.v2.runtime.XMLSerializer.childAsRoot(XMLSerializer.java:461)\n\tat com.sun.xml.bind.v2.runtime.MarshallerImpl.write(MarshallerImpl.java:292)\n\t... 24 more\n\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2270",
        "summary": "Restoring a deleted version does not work (throws Exception)",
        "description": "java.lang.IllegalStateException: Not in edit mode\n\tat org.apache.jackrabbit.core.state.LocalItemStateManager.createNew(LocalItemStateManager.java:258)\n\tat org.apache.jackrabbit.core.version.NodeStateEx.createChildNode(NodeStateEx.java:561)\n\tat org.apache.jackrabbit.core.version.NodeStateEx.addNode(NodeStateEx.java:525)\n\tat org.apache.jackrabbit.core.version.NodeStateEx.addNode(NodeStateEx.java:505)\n\tat org.apache.jackrabbit.core.version.VersionManagerImplRestore.restore(VersionManagerImplRestore.java:201)\n\tat org.apache.jackrabbit.core.VersionManagerImpl.restore(VersionManagerImpl.java:240)\n\tat org.apache.jackrabbit.core.NodeImpl.restore(NodeImpl.java:3379)\n\tat org.apache.jackrabbit.test.api.version.RestoreTest.testRestoreRemoved(RestoreTest.java:812)",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-1171",
        "summary": "Contribute Pluggable Permission and User Management to Jackrabbit",
        "description": "Working with a Jackrabbit based appliction I had to extend its security handling.\nThe aim of this extension has been to allow for a eitable resource based authorization.\nThe solution ended up in beeing plugable and extendable.\nAs there have been some questions in the Jackrabbit Developper-list about custom implementation of security or the management of privileges in Jackrabbit, I like to suggest my implementation as contribution with attached patches. \n\nBelow you can find some high-level explanation of the contained files and concepts\n\nI hope the prove to be usable and enhance this great repository.\nI welcome your feed-back and like to thank for your kind inspection\n\nRegards\nChristian Keller\n\nThe patch contains the following:\n=========================\n\n1) API [jackrabbit-core-changes.20071010.patch]\n-------------------------------------------------------------------\nAPI which allows to implement and configure a mechanisms for Authentication and Authorization. \nThe API is ACL- and Principal-based.\nACL and Principals Management is independent of the JCR api, to allow implementations to use different back-end systems like a Directory Server.\n\n2) Changes to current core [jackrabbit-core-changes.20071010.patch]\n-----------------------------------------------------------------------------------------------\nSome small changes have been necessary to core to enable configuration and access of Management, like session access to UserManager.\n\n3) Implementation [jackrabbit-core-implementation.20071010.patch]\n-----------------------------------------------------------------------------------------------\nAdditionally an implemenation is contained. It is not dependent on any back-end system, and may therefore be used as a default.\n\n\nDescription:\n==========\nThe extensions hook into Jackrabbit bei implementations of the Intefaces: AccessManager and LoginModule. \nAdditionally there are changes for configuration, set-up and access of the used Object.\n\nThe patch extends the API, in order to allow client inspections of Users and Permission. These are contained in the api.patch\n\nSee a short Introduction below:\n=========================\n\nThe Security extensions of this Patch contain both, Authentication and Authorization extensions for which the follwoing two modells are introduced:\n\nI) The Authorizable\n----------------------------\nThese are User's and Groups of Users. Users can authenticate. \nAuthentication in Jackrabbit is done by LoginModules which issue Principals as result of an Authentication.\nThe Users are the objects which can be represented by such an Principal\nThey are therfore are the base for the Authorization.\n\nII) The ACL\n----------------\nThe ACL is the Policy for Authorziation. \nThe ACL grants or denies a Principal Privileges which are called Actions.\n\nAdditional ther is a Management for Principals:\n\nThe Principal is the link between User and permission.\nA User may related to multiple Principals. As this dependes on the LoginModules verfiying the Idendity of the login-attemp.\nThe LoginModules may expose their Principals to the Repository via a Provider interface, to allow for usage in ACEs.\n\nAll Modells and their Managing Classes API's are abstracted from the fact, that they are used in a JC-Repository. Aka there is no reference to javax.jcr.Items, Sessions etc.\nThis should allow to implement both for external sources for both without imposing any JCR specific methods. Taken an LDAP as UserBase for example.\n\nThe managing classes are UserManger, PrincpalManager and ACLManager. \nThey are set-up and maintained by a repsoitory singular SecurityManger. \nSession specific versions of this Managers are exposed via Session.\n\nPrincipalManger and ACLManger are feed by one to multiple Providers. \nPrincipalProviders may exist per LoginModule, ACLProvider per Workspace.\n\nAuthentication:\n--------------------\nThe User will be used by the LoginModule. It will be resolved based on the given Credentials. If the Credentials can be validated, the User will be used to resolve Principals according its Group-Membership. As a result the Session's Subject will be extended by this principals.\n\nAuthorization:\n-------------------\nThe ACL will be use be an Implementation of the AccessManager-Interface\nAn ACLManger relates Items to ACLs and the ACL evaluates the Permission for the current Subject's Principals.\n\nDefault Implementation\n===================\nThe Default Implementation uses the Repository itself to store its security data.\nThe Users are stored within a dedicated workspace. \nThe ACL are attached to the Nodes they relate to.\nThe ACLs are inherited along the Item-Hierarchy.\nThe Principals are taken from the Authorables.\n\nConfiguration\n===========\nThe LoginModules may declare their PrincipalProvider class via a property key with the name \"principal_provider.class\"\n\nThe Workspace specific ACL Providers may be added via a configuration element in Worskspace.xml, called WorkspaceSecurity.\nA Factory class can be configured there.",
        "label": "NUG",
        "classified": "RFE",
        "type": "RFE"
    },
    {
        "key": "JCR-3142",
        "summary": "Create OSGi Bundles from jackrabbit-webdav and jackrabbit-jcr-server libraries",
        "description": "Propose to generate bundles from the jackrabbit-webdav (exporting everything) and jackrabbit-jcr-server (exporting nothing) libraries. In addition a new class is added to the jackrabbit-jcr-server library, which in case of deployment in an OSGi framework will register a Servlet with the OSGi HttpService to expose the JcrRemotingServlet.",
        "label": "NUG",
        "classified": "BUILD_SYSTEM",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1638",
        "summary": "Redundant calls to RepositoryService.getChildInfos",
        "description": "In some cases jcr2spi issues calls to RepositoryService.getChildInfos for items which haven been returned by the last call to RepositoryService.getItemInfos. \n\nThis happens because WorkspaceItemStateFactory.createDeepPropertyState is asked to create the node states for all items returned by RepositoryService.getChildInfos in the order they are returned by the Iterator. When trying to create an item state for an item which is deeper down the hierarchy than another item which comes later in the iterator, a call to RepositoryService.getChildInfos is issued for the latter. ",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2140",
        "summary": "JSR 283: Configurations and Baselines",
        "description": "",
        "label": "NUG",
        "classified": "RFE",
        "type": ""
    },
    {
        "key": "JCR-2749",
        "summary": "Closing a session twice shouldn't write a warning in the log",
        "description": "When closing a session twice the following warning is written to the log file as of JCR-2741:\n\n\"This session has already been closed. See the chained exception for a trace of where the session was closed.\"\n\nI think the second \"close()\" should simply be ignored, without warning.\n",
        "label": "NUG",
        "classified": "CLEANUP",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-2261",
        "summary": "Enable FileSystem unit tests",
        "description": "The FileSystem tests are implemented, but not actually run, because the TestAll class is missing.\nAlso, there is a bug in the tests that causes the tests to fail.",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-182",
        "summary": "add calendar mime types to jcr-server's mime type registry",
        "description": "attached is a patch that adds mime types for .ics and .ifb files to jcr-server's mime type registry.",
        "label": "NUG",
        "classified": "RFE",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-1076",
        "summary": "Some tests try to add new nodes without specifying the node type",
        "description": "Some tests try to add new nodes without specifying the node type, which may not be supported by a repository.\n\nIn particular:\n\n- NodeAddMixinTest.testAddNonExisting\n- NodeCanAddMixinTest.testNonExisting\n- ValueFactoryTest.testValueType\n- ValueFactoryTest.testValueFormatException\n\nProposal: update test cases to obtain the node type from the test config.\n",
        "label": "NUG",
        "classified": "TEST",
        "type": "BUG"
    },
    {
        "key": "JCR-2024",
        "summary": "Bundle cache is not cleared when *BundlePersistenceManager is closed",
        "description": "Close method of persistence managers is responsible for releasing all acquired resources. In case of BundlePersistenceManager it should also free memory by clearing the bundle cache.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "BUG"
    },
    {
        "key": "JCR-2888",
        "summary": "Namespace comparison in Namespace.java doesn't work, if a node return null, but it expects an empty string",
        "description": "If a node returns null for Node.getNamespaceUri(), but Namespace.EMPTY_NAMESPACE expects an empty string, the comparison fails. But to my knowledge a null and \"\" namespaceUri should be treated the same.\n\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2835",
        "summary": "Poor performance of ISDESCENDANTNODE on SQL 2 queries",
        "description": "Using the latest source code, I have noticed very bad performance on SQL-2 queries that use the ISDESCENDANTNODE constraint on a large sub-tree. For example, the query : \n\nselect * from [jnt:news] as news where ISDESCENDANTNODE(news,'/root/site') order by news.[date] desc \n\nexecutes in 600ms \n\nselect * from [jnt:news] as news order by news.[date] desc\n\nexecutes in 4ms\n\nFrom looking at the problem in the Yourkit profiler, it seems that the culprit is the constraint building, that uses recursive Lucene searches to build the list of descendant node IDs : \n\n    private Query getDescendantNodeQuery(\n            DescendantNode dn, JackrabbitIndexSearcher searcher)\n            throws RepositoryException, IOException {\n        BooleanQuery query = new BooleanQuery();\n\n        try {\n            LinkedList<NodeId> ids = new LinkedList<NodeId>();\n            NodeImpl ancestor = (NodeImpl) session.getNode(dn.getAncestorPath());\n            ids.add(ancestor.getNodeId());\n            while (!ids.isEmpty()) {\n                String id = ids.removeFirst().toString();\n                Query q = new JackrabbitTermQuery(new Term(FieldNames.PARENT, id));\n                QueryHits hits = searcher.evaluate(q);\n                ScoreNode sn = hits.nextScoreNode();\n                if (sn != null) {\n                    query.add(q, SHOULD);\n                    do {\n                        ids.add(sn.getNodeId());\n                        sn = hits.nextScoreNode();\n                    } while (sn != null);\n                }\n            }\n        } catch (PathNotFoundException e) {\n            query.add(new JackrabbitTermQuery(new Term(\n                    FieldNames.UUID, \"invalid-node-id\")), // never matches\n                    SHOULD);\n        }\n\n        return query;\n    }\n\nIn the above example this generates over 2800 Lucene queries, which is the culprit. I wonder if it wouldn't be faster to retrieve the IDs by using the JCR to retrieve the list of child IDs ?\n\nThis was probably also missed because I didn't seem to find any performance tests on this constraint.",
        "label": "NUG",
        "classified": "IMPROVEMENT",
        "type": "IMPROVEMENT"
    },
    {
        "key": "JCR-894",
        "summary": "rep:excerpt() not working for attribute searches",
        "description": "example: //element(*, nt:unstructured)[jcr:contains(@textProp, 'foobar')]/(rep:excerpt())\n\nproduces empty excerpts.",
        "label": "BUG",
        "classified": "BUG",
        "type": "BUG"
    },
    {
        "key": "JCR-2634",
        "summary": "weird error when adding a node using an abstract/mixin nodetype",
        "description": "when trying to add a node \"files\" with an abstract nodetype, i.e. nt:base, the following error is reported:\n\njavax.jcr.nodetype.ConstraintViolationException: {}files is abstract  be used as primary node type.\n\nthe correct wording could be:\n\njavax.jcr.nodetype.ConstraintViolationException: not allowed to add node {}files: {http://www.jcp.org/jcr/nt/1.0}base is abstract and cannot be used as primary node type.\n",
        "label": "BUG",
        "classified": "BUG",
        "type": "IMPROVEMENT"
    }
]